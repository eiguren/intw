var tipuesearch = {"pages":[{"title":" INTW ","text":"INTW INTW project Compilation notes Setting a specific compiler and flags Dependencies BLAS/LAPACK (required) Spglib (required to use SIESTA) triangle and tetgen (optional) OpenMP (optional) Wannier90 (optional) Python 3 (optional) Test suite Test dependencies python3 (required) Wannier90 (required for test_mmn and test_w902intw) QE or SIESTA (required for test_matrix_elements, test_mmn and test_w902intw) INTW project INTW is a modular set of Fortran tools designed for advanced electronic structure calculations, helping researchers to create customized utilities for specific applications. INTW implements a collection of functions and subroutines for computing various electron- and phonon-related properties, particularly standig out in the use of crystal symmetry to enhance efficiency, and it is capable of reading Density Functional Theory (DFT) results from both the plane-wave based Quantum Espresso code and from the localized basis set SIESTA code. Additionally, INTW provides a set of ready-to-use utilities for calculating electron-phonon coupling matrix elements and Eliashberg functions, Wannier functions, elctron band structure and phonon dispersion interpolations, and Fermi surface triangulations. Compilation notes To build INTW CMake (>=3.12), a supported build tool like Makefile or Ninja and C and Fortran compilers are required. All of them can be easily installed in most systems. Additionally, a supported version of Quantum Espresso or SIESTA (or both) is needed. Currently, the following versions are supported: DFT code Supported versions Quantum Espresso • 6.6 • 6.7MaX • 6.8 SIESTA • 4.1.5 • 5.0.0 • 5.0.1 • 5.0.2 • 5.2.0 • 5.2.1 • 5.2.2 To build INTW to work with both DFT codes: mkdir build cd build QE_HOME = /path/to/QE SIESTA_HOME = /path/to/SIESTA cmake ..\nmake If QE_HOME and SIESTA_HOME are defined as environmental variables CMake will use the value of the environmental variable. If QE_HOME is not specified, CMake will disable the components related to QE automatically. Similarly, if SIESTA_HOME is not specified, the components related to SIESTA will be disabled. Setting a specific compiler and flags CMake will find and select automatically the compilers and required libraries. However, it is possible to set a specific set of compilers using CMake's variable CMAKE_<LANG>_COMPILER : cmake -DCMAKE_Fortran_COMPILER = ifort .. Alternatively, the compiler can be specified using environmental variables: export FC = ifort CC = icc or FC = ifort cmake .. Similarly, CMake's variable CMAKE_<LANG>_FLAGS or FFLAGS and CFLAGS environmental variables can be used to set a specific set of compilation flags. Dependencies BLAS/LAPACK (required) BLAS and LAPACK libraries are found by CMake find_package modules. To set a specific BLAS/LAPACK library use BLA_VENDOR variable. For example, to enforce CMake to use OpenBLAS use: cmake -DBLA_VENDOR = OpenBLAS .. The complete list of allowed BLAS/LAPACK vendors, together with other options to find BLAS and LAPACK with CMake can be found here . Spglib (required to use SIESTA) Spglib is a C library for finding and handling crystal symmetries, which also has a Fortran interface. When INTW is used in conjunction with SIESTA, Spglib is used to find crystal symmetries and use them to reduce computational costs. In particular, Spglib is a used by the following components of INTW:\n- siesta2ph : Symmetries are used to reduce the required number of atomic displacements to completely determine the interatomic force constants and the induced potentials.\n- siesta2intw : Symmetries are used to reduce the Brillouin zone sampling to the irreducible q-points. CMake will attempt to download and build Spglib automatically inside the build directory of INTW. A working installation of Git is required for this process to work, since the library will be downloaded using Git. By default the original Spglib repository will be used, however, the user can override this by specifying an alternative repository via the SPGLIB_GIT_REPOSITORY variable (this is useful in case the library repository changes location): cmake -DSPGLIB_GIT_REPOSITORY = \"https://some.repository.url\" .. Similarly, while a tested version of the library is downloaded by default, the user can specify a different version by setting the SPGLIB_GIT_TAG variable: cmake -DSPGLIB_GIT_TAG = \"v2.6.0\" .. triangle and tetgen (optional) triangle is a Two-Dimensional Quality Mesh Generator and Delaunay Triangulator. And tetgen is a program to generate tetrahedral meshes of any 3D polyhedral domains. Both, triangle and tetgen codes, are used by INTW's triFS.x utility to obtain a fully symmetric triangulated Fermi surface. In order to triFS.x be compiled, ensure that both codes are installed and available in your system's PATH . Both codes can be downloaded directly from their official websites or, alternatively, in some distributions they can also be installed from the system's package repositories. For example: # Ubuntu sudo apt install triangle-bin tetgen If triangle and tetgen executables are not found by CMake in the configuring step, triFS.x utility will not be compiled, however, the rest of the utilities will still be successfully built. OpenMP (optional) Some parts of INTW are parallelized using OpenMP to take advantage of shared-memory multicore architectures. To use the parallelized version, ensure to compile INTW with OpenMP support enabled by setting USE_OPENMP=ON (by default OpenMP support is disabled): cmake -DUSE_OPENMP = ON .. Additionally, depending on the size of the calculation, it may be necessary to set the OpenMP environmental variable OMP_STACKSIZE to avoid segmentation faults. For example: #Bash export OMP_STACKSIZE = \"1GB\" Wannier90 (optional) Wannier90 is used only in the test suite. Read Test suite section for more information. Python 3 (optional) Python 3 is used only in the test suite. Read Test suite section for more information. Test suite INTW's test suite can be executed by using ctest , an executable that is available with CMake. Alternatively, when using the Makefile generator, make test can be used also. The test suite has 5 differentiated parts:\n- test_dummy : It does not contain any actual code test at all, but consists of some simplified tests to serve as examples for developers when creating new tests.\n- test_IO : To check the IO routines of INTW.\n- test_matrix_elements : A set of tests on different systems to check the electron-phonon matrix element calculation with ep_melements.x .\n- test_mmn : A set of tests on different systems to check the $A_{mn}$ and $M_{mn}$ matrices calculated with intw2W90.x .\n- test_w902intw : A set of tests on different systems to check the interface w902intw.x . Test dependencies Some components of the test suite need some specific software to be executed. python3 (required) Since most tests use python3 scripts to compare the results, if CMake does not find any python3 executable, the whole test suite will be disabled. Wannier90 (required for test_mmn and test_w902intw ) Wannier90 is used in test_mmn and test_w902intw scripts. Only the wannier90.x executable is needed, but the Wannier90 directory has to be specified to CMake: W_HOME = /path/to/WANNIER90 QE_HOME = /path/to/QE SIESTA_HOME = /path/to/SIESTA cmake .. If W_HOME is not specified, test_mmn and test_w902intw will be disabled. QE or SIESTA (required for test_matrix_elements , test_mmn and test_w902intw ) test_matrix_elements , test_mmn and test_w902intw tests run QE or SIESTA calculations, therefore, at least one of them must be specified to CMake, otherwise test_matrix_elements , test_mmn and test_w902intw will be disabled. Developer Info INTW group","tags":"home","url":"index.html"},{"title":"s – INTW","text":"function s(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/s.html"},{"title":"pz_func – INTW","text":"function pz_func(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/pz_func.html"},{"title":"px – INTW","text":"function px(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/px.html"},{"title":"py – INTW","text":"function py(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/py.html"},{"title":"dz2 – INTW","text":"function dz2(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/dz2.html"},{"title":"dxz – INTW","text":"function dxz(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/dxz.html"},{"title":"dyz – INTW","text":"function dyz(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/dyz.html"},{"title":"dx2my2 – INTW","text":"function dx2my2(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/dx2my2.html"},{"title":"dxy – INTW","text":"function dxy(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/dxy.html"},{"title":"fz3 – INTW","text":"function fz3(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/fz3.html"},{"title":"fxz2 – INTW","text":"function fxz2(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/fxz2.html"},{"title":"fyz2 – INTW","text":"function fyz2(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/fyz2.html"},{"title":"fzx2my2 – INTW","text":"function fzx2my2(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/fzx2my2.html"},{"title":"fxyz – INTW","text":"function fxyz(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/fxyz.html"},{"title":"fxx2m3y2 – INTW","text":"function fxx2m3y2(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/fxx2m3y2.html"},{"title":"fy3x2my2 – INTW","text":"function fy3x2my2(cost, phi) Uses intw_useful_constants kinds Arguments Type Intent Optional Attributes Name real(kind=dp) :: cost real(kind=dp) :: phi Return Value real(kind=dp)","tags":"","url":"proc/fy3x2my2.html"},{"title":"cfftnd – INTW","text":"subroutine cfftnd(nd, n, sgn, c) Uses fftpack5 DESCRIPTION:\n In-place fast Fourier transform for complex arrays in $n_d$ dimensions. The\n forward transform is scaled by one over the size of the array. Uses a\n modified version of the FFTPACK5 library. INPUT/OUTPUT PARAMETERS:\n  nd  : number of dimensions (in,integer)\n  n   : mesh size (in,integer(nd))\n  sgn : FFT direction, -1: forward, 1: backward (in,integer)\n  c   : array to transform (inout,complex(n(1) n(2) ...*n(nd))) Copyright (C) 2005 J. K. Dewhurst\n Distributed under the terms of the GNU General Public License.\n See the file COPYING for license details. Notes by ASIER\nsgn=+1 Means         Fourier Transform, i.e. Sum_{r=1,N} Exp[+I*k*r] u_r\nsgn=-1 Means Inverse Fourier Transform, i.e. Sum_{k=1,N} Exp[-I*k*r] u_k/N Arguments Type Intent Optional Attributes Name integer, intent(in) :: nd integer, intent(in) :: n (nd) integer, intent(in) :: sgn complex(kind=prec), intent(inout) :: c (*)","tags":"","url":"proc/cfftnd.html"},{"title":"cfftmi – INTW","text":"subroutine cfftmi(n, wsave, lensav) Uses fftpack5 CFFTMI: initialization for CFFTMB and CFFTMF. Arguments Type Intent Optional Attributes Name integer :: n real(kind=prec) :: wsave (lensav) integer :: lensav","tags":"","url":"proc/cfftmi.html"},{"title":"mcfti1 – INTW","text":"subroutine mcfti1(n, wa, fnf, fac) Uses fftpack5 MCFTI1 is an FFTPACK5 auxiliary routine. Arguments Type Intent Optional Attributes Name integer :: n real(kind=prec) :: wa (*) real(kind=prec) :: fnf real(kind=prec) :: fac (*)","tags":"","url":"proc/mcfti1.html"},{"title":"factor – INTW","text":"subroutine factor(n, nf, fac) Uses fftpack5 FACTOR determines the factors of an integer. Arguments Type Intent Optional Attributes Name integer :: n integer :: nf real(kind=prec) :: fac (*)","tags":"","url":"proc/factor.html"},{"title":"tables – INTW","text":"subroutine tables(ido, ip, wa) Uses fftpack5 TABLES computes trigonometric tables needed by the FFT routines. Arguments Type Intent Optional Attributes Name integer :: ido integer :: ip real(kind=prec) :: wa (ido,ip-1,2)","tags":"","url":"proc/tables.html"},{"title":"cmfm1b – INTW","text":"subroutine cmfm1b(lot, jump, n, inc, c, ch, wa, fnf, fac) Uses fftpack5 CMFM1B is an FFTPACK5 auxiliary routine. Arguments Type Intent Optional Attributes Name integer :: lot integer :: jump integer :: n integer :: inc complex(kind=prec) :: c (*) real(kind=prec) :: ch (*) real(kind=prec) :: wa (*) real(kind=prec) :: fnf real(kind=prec) :: fac (*)","tags":"","url":"proc/cmfm1b.html"},{"title":"cmfm1f – INTW","text":"subroutine cmfm1f(lot, jump, n, inc, c, ch, wa, fnf, fac) Uses fftpack5 CMFM1F is an FFTPACK5 auxiliary routine. Arguments Type Intent Optional Attributes Name integer :: lot integer :: jump integer :: n integer :: inc complex(kind=prec) :: c (*) real(kind=prec) :: ch (*) real(kind=prec) :: wa (*) real(kind=prec) :: fnf real(kind=prec) :: fac (*)","tags":"","url":"proc/cmfm1f.html"},{"title":"cmf2kb – INTW","text":"subroutine cmf2kb(lot, ido, l1, na, cc, im1, in1, ch, im2, in2, wa) Uses fftpack5 CMF2KB is an FFTPACK5 auxiliary routine. Arguments Type Intent Optional Attributes Name integer :: lot integer :: ido integer :: l1 integer :: na real(kind=prec) :: cc (2,in1,l1,ido,2) integer :: im1 integer :: in1 real(kind=prec) :: ch (2,in2,l1,2,ido) integer :: im2 integer :: in2 real(kind=prec) :: wa (ido,1,2)","tags":"","url":"proc/cmf2kb.html"},{"title":"cmf2kf – INTW","text":"subroutine cmf2kf(lot, ido, l1, na, cc, im1, in1, ch, im2, in2, wa) Uses fftpack5 CMF2KF is an FFTPACK5 auxiliary routine. Arguments Type Intent Optional Attributes Name integer :: lot integer :: ido integer :: l1 integer :: na real(kind=prec) :: cc (2,in1,l1,ido,2) integer :: im1 integer :: in1 real(kind=prec) :: ch (2,in2,l1,2,ido) integer :: im2 integer :: in2 real(kind=prec) :: wa (ido,1,2)","tags":"","url":"proc/cmf2kf.html"},{"title":"cmf3kb – INTW","text":"subroutine cmf3kb(lot, ido, l1, na, cc, im1, in1, ch, im2, in2, wa) Uses fftpack5 CMF3KB is an FFTPACK5 auxiliary routine. Arguments Type Intent Optional Attributes Name integer :: lot integer :: ido integer :: l1 integer :: na real(kind=prec) :: cc (2,in1,l1,ido,3) integer :: im1 integer :: in1 real(kind=prec) :: ch (2,in2,l1,3,ido) integer :: im2 integer :: in2 real(kind=prec) :: wa (ido,2,2)","tags":"","url":"proc/cmf3kb.html"},{"title":"cmf3kf – INTW","text":"subroutine cmf3kf(lot, ido, l1, na, cc, im1, in1, ch, im2, in2, wa) Uses fftpack5 CMF3KF is an FFTPACK5 auxiliary routine. Arguments Type Intent Optional Attributes Name integer :: lot integer :: ido integer :: l1 integer :: na real(kind=prec) :: cc (2,in1,l1,ido,3) integer :: im1 integer :: in1 real(kind=prec) :: ch (2,in2,l1,3,ido) integer :: im2 integer :: in2 real(kind=prec) :: wa (ido,2,2)","tags":"","url":"proc/cmf3kf.html"},{"title":"cmf4kb – INTW","text":"subroutine cmf4kb(lot, ido, l1, na, cc, im1, in1, ch, im2, in2, wa) Uses fftpack5 CMF4KB is an FFTPACK5 auxiliary routine. Arguments Type Intent Optional Attributes Name integer :: lot integer :: ido integer :: l1 integer :: na real(kind=prec) :: cc (2,in1,l1,ido,4) integer :: im1 integer :: in1 real(kind=prec) :: ch (2,in2,l1,4,ido) integer :: im2 integer :: in2 real(kind=prec) :: wa (ido,3,2)","tags":"","url":"proc/cmf4kb.html"},{"title":"cmf4kf – INTW","text":"subroutine cmf4kf(lot, ido, l1, na, cc, im1, in1, ch, im2, in2, wa) Uses fftpack5 CMF4KF is an FFTPACK5 auxiliary routine. Arguments Type Intent Optional Attributes Name integer :: lot integer :: ido integer :: l1 integer :: na real(kind=prec) :: cc (2,in1,l1,ido,4) integer :: im1 integer :: in1 real(kind=prec) :: ch (2,in2,l1,4,ido) integer :: im2 integer :: in2 real(kind=prec) :: wa (ido,3,2)","tags":"","url":"proc/cmf4kf.html"},{"title":"cmf5kb – INTW","text":"subroutine cmf5kb(lot, ido, l1, na, cc, im1, in1, ch, im2, in2, wa) Uses fftpack5 CMF5KB is an FFTPACK5 auxiliary routine. Arguments Type Intent Optional Attributes Name integer :: lot integer :: ido integer :: l1 integer :: na real(kind=prec) :: cc (2,in1,l1,ido,5) integer :: im1 integer :: in1 real(kind=prec) :: ch (2,in2,l1,5,ido) integer :: im2 integer :: in2 real(kind=prec) :: wa (ido,4,2)","tags":"","url":"proc/cmf5kb.html"},{"title":"cmf5kf – INTW","text":"subroutine cmf5kf(lot, ido, l1, na, cc, im1, in1, ch, im2, in2, wa) Uses fftpack5 CMF5KF is an FFTPACK5 auxiliary routine. Arguments Type Intent Optional Attributes Name integer :: lot integer :: ido integer :: l1 integer :: na real(kind=prec) :: cc (2,in1,l1,ido,5) integer :: im1 integer :: in1 real(kind=prec) :: ch (2,in2,l1,5,ido) integer :: im2 integer :: in2 real(kind=prec) :: wa (ido,4,2)","tags":"","url":"proc/cmf5kf.html"},{"title":"cmfgkb – INTW","text":"subroutine cmfgkb(lot, ido, ip, l1, lid, na, cc, cc1, im1, in1, ch, ch1, im2, in2, wa) Uses fftpack5 CMFGKB is an FFTPACK5 auxiliary routine. Arguments Type Intent Optional Attributes Name integer :: lot integer :: ido integer :: ip integer :: l1 integer :: lid integer :: na real(kind=prec) :: cc (2,in1,l1,ip,ido) real(kind=prec) :: cc1 (2,in1,lid,ip) integer :: im1 integer :: in1 real(kind=prec) :: ch (2,in2,l1,ido,ip) real(kind=prec) :: ch1 (2,in2,lid,ip) integer :: im2 integer :: in2 real(kind=prec) :: wa (ido,ip-1,2)","tags":"","url":"proc/cmfgkb.html"},{"title":"cmfgkf – INTW","text":"subroutine cmfgkf(lot, ido, ip, l1, lid, na, cc, cc1, im1, in1, ch, ch1, im2, in2, wa) Uses fftpack5 CMFGKF is an FFTPACK5 auxiliary routine. Arguments Type Intent Optional Attributes Name integer :: lot integer :: ido integer :: ip integer :: l1 integer :: lid integer :: na real(kind=prec) :: cc (2,in1,l1,ip,ido) real(kind=prec) :: cc1 (2,in1,lid,ip) integer :: im1 integer :: in1 real(kind=prec) :: ch (2,in2,l1,ido,ip) real(kind=prec) :: ch1 (2,in2,lid,ip) integer :: im2 integer :: in2 real(kind=prec) :: wa (ido,ip-1,2)","tags":"","url":"proc/cmfgkf.html"},{"title":"read_input – INTW","text":"public  subroutine read_input(read_status) Uses intw_useful_constants This subroutine reads all namelists from standard input,\nand checks their validity and consistency. Arguments Type Intent Optional Attributes Name logical :: read_status","tags":"","url":"proc/read_input.html"},{"title":"read_cards – INTW","text":"public  subroutine read_cards() This subroutine reads K_PATH and Q_PATH cards from standard input if present. IMPORTANT: some cards may be missing, but the present\nones must be ordered as described below. K_PATH\n    label(1) k_x(1) k_y(1) k_z(1)\n    label(2) k_x(2) k_y(2) k_z(2)\n    ...\n    label(nkspecial) k_x(nkspecial) k_y(nkspecial) k_z(nkspecial)\nQ_PATH\n    nqpath nqspecial\n    label(1) q_x(1) q_y(1) q_z(1)\n    label(2) q_x(2) q_y(2) q_z(2)\n    ...\n    label(nqspecial) q_x(nqspecial) q_y(nqspecial) q_z(nqspecial) where nkpath indicate the desired total number of k-points along the path,\nand nkspecial specifies the number of intermediate special points,\nwhich are given below in crystal coordinates. MBR 03/05/2024 Arguments None","tags":"","url":"proc/read_cards.html"},{"title":"intw_input_parameters – INTW","text":"This module contains the definitions of all input parameters for INTW\nas well as subroutines for reading and checking the input. Details Input parameters &input\n    outdir                = 'directory'\n    prefix                = 'prefix'\n    nk1                   = integer\n    nk2                   = integer\n    nk3                   = integer\n    tr_symmetry           = T or F (Default: T)\n    chemical_potential    = real (Default: 0.0 eV)\n    use_exclude_bands     = 'none', 'wannier' or 'custom'\n    include_bands_initial = integer\n    include_bands_final   = integer\n/\n&intw2W\n    intw2w_fullzone = T or F (Default: F)\n    intw2w_method   = 'CONVOLUTION' or 'FFT' (Default: 'CONVOLUTION')\n    compute_amn     = T or F (Default: T)\n    compute_mmn     = T or F (Default: T)\n/\n&ph\n    qlist           = 'file' (Default: 'qlist.txt')\n    read_for_dynmat = 'fc' or 'dynq' (Default: 'dynq')\n    fc_mat          = 'file'\n    nq1             = integer\n    nq2             = integer\n    nq3             = integer\n    nqirr           = integer\n    apply_asr       = T or F (Default: T)\n/\n&DOS\n    nk1_dos    = integer (Default: 20)\n    nk2_dos    = integer (Default: 20)\n    nk3_dos    = integer (Default: 20)\n    ne_dos     = integer (Default: 100)\n    eini_dos   = real (Default: -10.0 eV)\n    efin_dos   = real (Default: 10.0 eV)\n    esmear_dos = real (Default: 0.05 eV)\n    ktsmear    = real (Default: 0.01 eV)\n/\n&DOS_ph\n    nq1_dosph = integer (Default: 20)\n    nq2_dosph = integer (Default: 20)\n    nq3_dosph = integer (Default: 20)\n    nomega    = integer (Default: 100)\n    omega_ini = real (Default: 0.0 Ry)\n    omega_fin = real (Default: 0.005 Ry)\n    osmear_q  = real (Default: 0.000075 Ry)\n    omega_cut = real (Default: 0.0 Ry)\n/\n&elphon\n    ep_mat_file         = 'file' (Default: 'ep_mat.dat')\n    ep_bands            = 'intw' or 'custom' (Default: 'intw')\n    ep_bands_initial    = integer\n    ep_bands_final      = integer\n    ep_interp_method    = 'wannier' or 'dV_interpolate'\n    ep_interp_bands     = 'intw_bands' or 'ef_crossing' (Default: 'intw_bands')\n    nfs_sheets_initial  = integer\n    nfs_sheets_final    = integer\n    nscf_code           = 'QE' or 'SIESTA'\n    command_pw          = 'command'\n    command_pw2intw     = 'command'\n    file_pw             = 'file'\n    command_siesta2intw = 'command'\n    file_siesta2intw    = 'file'\n/\nK_PATH\n    nkpath nkspecial\n    label(1) kspecial_x(1) kspecial_y(1) kspecial_z(1)\n    label(2) kspecial_x(2) kspecial_y(2) kspecial_z(2)\n    ...\n    label(nkspecial) kspecial_x(nkspecial) kspecial_y(nkspecial) kspecial_z(nkspecial)\nQ_PATH\n    nqpath nqspecial\n    label(1) qspecial_x(1) qspecial_y(1) qspecial_z(1)\n    label(2) qspecial_x(2) qspecial_y(2) qspecial_z(2)\n    ...\n    label(nqspecial) qspecial_x(nqspecial) qspecial_y(nqspecial) qspecial_z(nqspecial) K_PATH and Q_PATH cards are used to generate the path along the Brilloin zone\nto plot electron band structure and phonon frequency dispersion, respectively. Variables without default values must be explicitly set in the input\nfile; otherwise, an error will be raised. Uses kinds Variables Type Visibility Attributes Name Initial character(len=256), public :: outdir = 'unassigned' The directory where the DFT calculations are stored character(len=256), public :: prefix = 'unassigned' The prefix of the DFT calculation integer, public :: nk1 = -1 Monkhorst-Pack mesh indices for the coarse k-mesh integer, public :: nk2 = -1 Monkhorst-Pack mesh indices for the coarse k-mesh integer, public :: nk3 = -1 Monkhorst-Pack mesh indices for the coarse k-mesh real(kind=dp), public :: chemical_potential = 0.0_dp The value which determines the occupation factors (Units: eV) logical, public :: TR_symmetry = .true. If TR symmetry is present TR_symmetry = .true. character(len=256), public :: use_exclude_bands = \"unassigned\" Three options to select the bands used in various utilities: use_exclude_bands='none' : we don't exclude any band and therefore we use all bands from the DFT calculation\n  (Error if nnkp file is present) use_exclude_bands='wannier' : we exclude the bands indicated by Wannier90 in nnkp file\n  (Error if nnkp file is NOT present) use_exclude_bands='custom' : use the subset of bands ( include_bands_initial:include_bands_final )\n  from the bands considered by the DFT calculation and exclude the rest of bands\n  (Error if include_bands_initial, include_bands_final not present) integer, public :: include_bands_initial = 0 The initial and final band indices for use_exclude_bands='custom' integer, public :: include_bands_final = 0 The initial and final band indices for use_exclude_bands='custom' logical, public :: intw2W_fullzone = .false. If True, the code wil assume that a full zone DFT calculation\nhas been performed and that wavefunctions for every k-point\nare available. This is mostly for testing and directly comparing\nthe results of intw2W90 and pw2wannier character(len=256), public :: intw2W_method = 'CONVOLUTION' Two options to select which method use to compute matrix elements: intw2W_method = 'CONVOLUTION' intw2W_method = 'FFT' logical, public :: compute_mmn = .true. If True, the code produces the $prefix.mmn and $prefix.eig files logical, public :: compute_amn = .true. If True, the code produces the $prefix.amn file character(len=256), public :: qlist = 'qlist.txt' Name of the file containing the irreducible q-points list (relative to outdir) character(len=256), public :: fc_mat = '--.fc' Name of the force constants matrix (relative to outdir) character(len=256), public :: read_for_dynmat = 'dynq' Two options to choose: read_for_dynmat = 'fc' : to read force constants from fc_mat file read_for_dynmat = 'dynq' : to read .dyn files from the phonon calculations logical, public :: apply_asr = .true. Whether apply Acoustic Sum Rule or not integer, public :: nq1 = -1 Monkhorst-Pack mesh indices for the coarse q-mesh integer, public :: nq2 = -1 Monkhorst-Pack mesh indices for the coarse q-mesh integer, public :: nq3 = -1 Monkhorst-Pack mesh indices for the coarse q-mesh integer, public :: nqirr = -1 Number of irreducible q-points integer, public :: nk1_dos = 20 Interpolation k-grid for DOS plot integer, public :: nk2_dos = 20 Interpolation k-grid for DOS plot integer, public :: nk3_dos = 20 Interpolation k-grid for DOS plot integer, public :: ne_dos = 100 Number of energy points in DOS plot real(kind=dp), public :: eini_dos = -10.0_dp Energy range for electron DOS plot (Units: eV) real(kind=dp), public :: efin_dos = 10.0_dp Energy range for electron DOS plot (Units: eV) real(kind=dp), public :: esmear_dos = 0.05_dp Smearing width for electron DOS plot (Units: eV) real(kind=dp), public :: ktsmear = 0.01_dp Smearing (kT) for Fermi level electron DOS calculation (Units: eV) integer, public :: nq1_dosph = 20 Interpolation q-grid for phonon DOS plot integer, public :: nq2_dosph = 20 Interpolation q-grid for phonon DOS plot integer, public :: nq3_dosph = 20 Interpolation q-grid for phonon DOS plot integer, public :: nomega = 100 Number of energy points in DOS plot real(kind=dp), public :: omega_ini = 0.0_dp Energy range for phonon DOS plot (Units: Ry) real(kind=dp), public :: omega_fin = 0.005_dp Energy range for phonon DOS plot (Units: Ry) real(kind=dp), public :: osmear_q = 0.000075 Smearing width for phonon DOS plot (Units: Ry) real(kind=dp), public :: omega_cut = -1.0_dp Phonon frequency cut-off for removing w -> 0 peak in a2F (Units: Ry) character(len=256), public :: ep_mat_file = \"ep_mat.dat\" Name of the electron-phonon matrix elements file character(len=256), public :: ep_bands = 'intw' Two options to select the subset of bands for computing the electron-phonon\nmatrix elements: ep_bands = 'intw' : compute matrix elements for all bands considered by INTW (See use_exclude_bands variable) ep_bands = 'custom' : compute matrix elements for the custom subset of bands (ep_bands_initial:ep_bands_final)\n  from the bands considered by INTW (See use_exclude_bands variable) integer, public :: ep_bands_initial = 0 The initial and final band indices for ep_bands = 'custom' integer, public :: ep_bands_final = 0 The initial and final band indices for ep_bands = 'custom' character(len=256), public :: ep_interp_method = 'unassigned' Two options to choose the interpolation method: ep_interp_method = 'wannier' ep_interp_method = 'dV_interpolate' character(len=256), public :: ep_interp_bands = 'intw_bands' Two options to select the subset of bands to interpolate electron-phonon matrix elements: ep_interp_bands = 'intw_bands' : interpolate matrix elements for all bands considered by INTW (See use_exclude_bands variable) ep_interp_bands = 'ef_crossing' : interpolate matrix elements for the substet of bands that cross the Fermi level (nfs_sheets_initial:nfs_sheets_final)\n  from the bands considered by INTW (See use_exclude_bands variable) integer, public :: nfs_sheets_initial = 0 The initial band index for ep_interp_bands = 'ef_crossing' integer, public :: nfs_sheets_final = 0 The final band index for ep_interp_bands = 'ef_crossing' character(len=256), public :: nscf_code = 'unassigned' The DFT code used for running the nscf calculation (only needed if ep_interp_method = 'dV_interpolate' is chosen): nscf_code = 'QE' nscf_code = 'SIESTA' character(len=256), public :: command_pw = 'unassigned' pw.x executable, with optional running options\nthat go ahead of the executable like 'mpirun -np N', 'nice', etc. character(len=256), public :: command_pw2intw = 'unassigned' pw2intw.x executable, with optional running options\nthat go ahead of the executable like 'mpirun -np N', 'nice', etc. character(len=256), public :: file_pw = 'unassigned' The input file for pw.x. character(len=256), public :: command_siesta2intw = 'unassigned' siesta2intw.x executable, with optional running options\nthat go ahead of the executable like 'mpirun -np N', 'nice', etc. character(len=256), public :: file_siesta2intw = 'unassigned' The input file for siesta2intw.x. logical, public :: exist_kpath integer, public :: nkpath Number of total k-points in the path integer, public :: nkspecial Number of special k-points in the path real(kind=dp), public, allocatable :: kspecial (:,:) List of special k-points in crystal coordinates logical, public :: exist_qpath integer, public :: nqpath Number of total q-points in the path integer, public :: nqspecial Number of special q-points in the path real(kind=dp), public, allocatable :: qspecial (:,:) List of special q-points in crystal coordinates Subroutines public  subroutine read_input (read_status) This subroutine reads all namelists from standard input,\nand checks their validity and consistency. Arguments Type Intent Optional Attributes Name logical :: read_status public  subroutine read_cards () This subroutine reads K_PATH and Q_PATH cards from standard input if present. Read more… Arguments None","tags":"","url":"module/intw_input_parameters.html"},{"title":"triFS_input_parameters – INTW","text":"This module contains the definitions of input parameters for triFS utility. Details Input parameters &tri_FS\n    n1           = integer\n    n2           = integer\n    n3           = integer\n    volume_nodes = T or F (Default: T)\n    volnodfac    = real (Default: 1.0)\n    hr_file      = 'file'\n    ef           = real (Default: 0.0 eV)\n    verbose      = T or F (Default: F)\n    plot_BZ      = T or F (Default: T)\n    dos          = T or F (Default: T)\n    eps_dupv     = real (Default: 1.0E-06)\n/\n&FS_opt\n    collapse          = T or F (Default: T)\n    collapse_criteria = real (Default: 0.2)\n    relax             = T or F (Default: T)\n    relax_iter        = integer (Default: 1000)\n    newton_raphson    = 0: not applied, 1: only in the end, 2: beginning and end (Default: 2)\n    newton_iter       = integer (Default: 10)\n    relax_vinface     = T or F (Default: F)\n    eps_vinface       = real (Default: 1.0E-5)\n/ Variables without default values must be explicitly set in the input\nfile; otherwise, an error will be raised. Uses kinds Variables Type Visibility Attributes Name Initial integer, public :: n1 = -1 BZ sampling for creating tetrahedra integer, public :: n2 = -1 BZ sampling for creating tetrahedra integer, public :: n3 = -1 BZ sampling for creating tetrahedra logical, public :: volume_nodes = .true. .true. if nodes are to be added inside the IBZ volume as Steiner points real(kind=dp), public :: volnodfac = 1.0_dp Factor with which multiply n1, n2, n3 to add points within IBZ volume character(len=256), public :: hr_file = 'unassigned' Wannier90 $seedname.hr file real(kind=dp), public :: ef = 0.0_dp Fermi level (Units: eV) logical, public :: verbose = .false. Verbose output logical, public :: plot_BZ = .true. Plot BZ edges logical, public :: dos = .true. Compute Fermi level DOS real(kind=dp), public :: eps_dupv = 1.0E-06_dp Threshold parameter to detect duplicated vertices logical, public :: collapse = .true. Collapse edges of triangulated mesh real(kind=dp), public :: collapse_criteria = 0.2_dp Shortest edge to longest edge ratio to proceed with collapse logical, public :: relax = .true. Tangentially relax edges of triangulated mesh integer, public :: relax_iter = 1000 Number of tangential relax iterations integer, public :: newton_raphson = 2 Newthon-Raphson relax edges of triangulated mesh: 0 : not applied 1 : applied only at the end 2 : applied at beginning and end integer, public :: newton_iter = 10 Number of Newthon-Raphson relax iterations logical, public :: relax_vinface = .false. Relax vertices on faces. May give erros in some examples. real(kind=dp), public :: eps_vinface = 1.0E-5_dp Threshold to detect vertices on BZ faces","tags":"","url":"module/trifs_input_parameters.html"},{"title":"intw_useful_constants – INTW","text":"This module defines useful constants including mathematical values,\nphysical constants, conversion factors, and Pauli matrices. Uses kinds","tags":"","url":"module/intw_useful_constants.html"},{"title":"intw_version – INTW","text":"This module handles the version information of INTW.","tags":"","url":"module/intw_version.html"},{"title":"triFS_isosurface – INTW","text":"This module contains all the variables and subroutines for reading\nWannier hamiltonian and creating symmetric isosurface for triFS utility. Uses kinds","tags":"","url":"module/trifs_isosurface.html"},{"title":"intw_symmetries – INTW","text":"This module handles the space group symmetry operations. Details The subroutines in this module handle the space group symmetries and\ntheir effect on wave functions and matrix elements. They also allow the\nidentification of an irreducible set of k-vectors in the 1BZ, forming the\nIBZ. It is advantageous to perform symmetry operations in crystal coordinates;\nindeed, in these coordinates, the zone is simply a cube and MP meshes are\nnice and regular. However, the crystal coordinate system introduces minor\ncomplications in the application of point group symmetry. A full\ndescription is given in algorithms.pdf. Uses kinds","tags":"","url":"module/intw_symmetries.html"},{"title":"triFS_geometry – INTW","text":"This module contains all the necessary variables and subroutines\nrelated to triangles and tetrahedra for triFS utility. Uses kinds","tags":"","url":"module/trifs_geometry.html"},{"title":"intw_w90_setup – INTW","text":"This module contains subroutines and variables for reading and storing\nWannier90 data, and for preforming Wannier interpolation. Details The utility W902INTW should:\n1. call read_nnkp_file in intw_intw2wannier module to obtain\n    nnkp_exclude_bands, nnkp_kpoints, etc.\n2. call read_w90_chk\n3. call allocate_and_build_u_mesh\n4. call write_formatted_u_mesh Then, any utility using u_mesh can simply obtain it by using\nread_formatted_u_mesh Uses kinds","tags":"","url":"module/intw_w90_setup.html"},{"title":"intw_intw2wannier – INTW","text":"This module contains variables and subroutines to perform the same tasks\nas the Quantum Espresso post-processing program \"pw2wannier90\", but using\nsymmetries. Details In particular, this module contains:\n- subroutines and variables for reading and storing $seed.nnkp file data.\n- subroutines for producing the $seed.mmn and $seed.amn files using\n  only the wave functions in the IBZ, rotating them appropriately. Uses kinds","tags":"","url":"module/intw_intw2wannier.html"},{"title":"intw_pseudo_local – INTW","text":"This module contains variables and subroutines for obtaining the local\npart of the pseudo-potentials. Uses kinds","tags":"","url":"module/intw_pseudo_local.html"},{"title":"intw_ph – INTW","text":"This module contains the main variables related to phonon modes. Uses kinds","tags":"","url":"module/intw_ph.html"},{"title":"intw_fft_interp – INTW","text":"Note 29/11/2024: This module is not used anywhere and it is not tested, so it could be removed. Uses kinds","tags":"","url":"module/intw_fft_interp.html"},{"title":"intw_matrix_vector – INTW","text":"This module contains functions and subroutines for matrix\nand vector operations. Uses kinds","tags":"","url":"module/intw_matrix_vector.html"},{"title":"intw_pseudo – INTW","text":"This module contains the pseudo-potentials in intwpseudo type,\nand the subroutine read_all_pseudo for reading them from the PP files. Uses kinds","tags":"","url":"module/intw_pseudo.html"},{"title":"fftpack5 – INTW","text":"","tags":"","url":"module/fftpack5.html"},{"title":"intw_fft – INTW","text":"This module contains variables and subroutines for handling most of the g -> r and\nr -> g transformations using FFT. Details The correspondence between the nr1 nr2 nr3 FFT grid with the G list\nof the calculation is taken into account, and for wave functions,\nthe reduced G list inside the cut-off is considered. Uses kinds","tags":"","url":"module/intw_fft.html"},{"title":"intw_reading – INTW","text":"This module contains variables and subroutines for reading and\nmanaging input data from DFT calculations. Uses kinds","tags":"","url":"module/intw_reading.html"},{"title":"intw_ph_interpolate – INTW","text":"This module contains the necessary tools for interpolating phonons. Details So far, it contains routines to generate Wigner-Seitz real meshes,\nFourier transforms of the dynamical matrix, interpolation at a given q-point. Those tools are similar to some routines in w90_setup, which have been\nadapted here for phonon meshes. MBR 24/01/24 Uses kinds","tags":"","url":"module/intw_ph_interpolate.html"},{"title":"intw_pseudo_non_local – INTW","text":"This module contains variables and subroutines for obtaining the non-local\npart of the pseudo-potentials. Uses kinds","tags":"","url":"module/intw_pseudo_non_local.html"},{"title":"intw_utility – INTW","text":"This module contains useful functions and subroutines that implement common tasks. Details It will be VERY useful to call these functions instead\nof reimplementing them every time they are needed, especially\nto ensure CONSISTENCY. Uses kinds","tags":"","url":"module/intw_utility.html"},{"title":"kinds – INTW","text":"This module defines kind parameters for specifying the precision\nof real and integer variables.","tags":"","url":"module/kinds.html"},{"title":"intw_matrix_elements – INTW","text":"This module contains subroutines for computing matrix elements of operators\nbetween wave functions, particularly for plane wave matrix elements. Uses kinds","tags":"","url":"module/intw_matrix_elements.html"},{"title":"triFS_mesh_opt – INTW","text":"This module contains all the necessary subroutines for optimizing a\ntriangulated FS mesh for triFS utility. Uses kinds","tags":"","url":"module/trifs_mesh_opt.html"},{"title":"intw_allwfcs – INTW","text":"This module contains variables and subroutines for obtaining wave functions. Details Wave functions for irreducible k points are read and stored, and wave functions\nfor general k points are obtained using symmetry. Uses kinds","tags":"","url":"module/intw_allwfcs.html"},{"title":"ep_on_trFS_dV – INTW","text":"Uses intw_fft intw_ph intw_symmetries intw_useful_constants omp_lib intw_matrix_vector intw_pseudo_non_local intw_pseudo intw_reading intw_ph_interpolate intw_version intw_pseudo_local intw_utility intw_input_parameters kinds Compute electron-phonon matrix elements on a triangulated Fermi\nsurface using induced potential interpolation. Details This utility calculates electron-phonon matrix elements interpolated on a Fermi surface triangulation\nfollowing the method of: A. Eiguren, C. Ambrosch-Draxl, Phys. Rev. B 78, 045124 (2008) For that, the induced potentials calculated with QE on the q-grid are read in\nand interpolated to the non-uniform q-list corresponding to the triangulation (q=k'-k)\nNeeded wavefunctions on the triangulated k-points are calculated on the fly by calling QE and stored.\nIf such calculations preexist, those wavefunctions are read. 1st part: 1.- From files prefix.N_FS_tri.off, where N is the Fermi surface (FS) sheet,\n    it reads the lists of k-points at the vertices, and the faces, in order to calculate\n    areas. 2.- It writes a prefix-nscf.nscf.in input for pw.x by reading prefix.scf.in\n    and replacing the k-points by the FS triangulation information. 3.- It writes a prefix-nscf.pw2intw.in file, which will convert wfc data from\n    prefix-nscf.save directory. 4.- It sets a directory prefix-nscf.save and initializes it with the scf charge density.\n    It runs pw.x and applies pw2intw.x to the obtained wfcs. In case the prefix-nscf.save/wfc\n    files exist, it skips this and warns the user. (In the case of using SIESTA step 2 to 4 are done with siesta2intw.x) 2nd part: Read derivative of local potential (dvq_local) on the real space unit cell for\nq-vectors of full BZ and Fourier transform to R (Wigner-Seitz)\nas the first step of the interpolation.\nThe non-local part will be added on the fly when interpolating over the triangulated k-points. 3rd part: Loop over FS (one loop over irreducible BZ wedge, one loop over full BZ).\nFor each k, k' interpolate the potential for q = k' - k.\nRead the wave functions for k and k' from their corresponding prefix-nscf.save/wfc files.\nCalculate electron-phonon matrix elements (local + non-local) as done in ep_melements utility.\nFinally, interpolated matrix elements are saved to file. MBR 24/04/2024 Input parameters &input\n    outdir                = 'directory'\n    prefix                = 'prefix'\n    TR_symmetry           = T or F\n    use_exclude_bands     = 'none', 'wannier' or 'custom'\n    include_bands_initial = integer\n    include_bands_final   = integer\n/\n&ph\n    qlist           = 'file'\n    nq1             = integer\n    nq2             = integer\n    nq3             = integer\n    nqirr           = integer\n/\n&elphon\n    ep_interp_method    = 'dV_interpolate'\n    ep_interp_bands     = 'intw_bands' or 'ef_crossing'\n    nfs_sheets_initial  = integer\n    nfs_sheets_final    = integer\n    nscf_code           = 'QE' or 'SIESTA'\n    command_pw          = 'command'\n    command_pw2intw     = 'command'\n    file_pw             = 'file'\n    command_siesta2intw = 'command'\n    file_siesta2intw    = 'file'\n/ See intw_input_parameters module for the description of each parameter.","tags":"","url":"program/ep_on_trfs_dv.html"},{"title":"triFS – INTW","text":"Uses triFS_input_parameters triFS_isosurface triFS_geometry intw_reading intw_version triFS_mesh_opt intw_input_parameters kinds intw_utility Triangulate Fermi surface. Details Input parameters &input\n    outdir = 'directory'\n    prefix = 'prefix'\n    TR_symmetry = T or F\n/\n&tri_FS\n    n1           = integer\n    n2           = integer\n    n3           = integer\n    volume_nodes = T or F\n    volnodfac    = real\n    hr_file      = 'file'\n    ef           = real\n    verbose      = T or F\n    plot_BZ      = T or F\n    dos          = T or F\n    eps_dupv     = real\n/\n&FS_opt\n    collapse          = T or F\n    collapse_criteria = real\n    relax             = T or F\n    relax_iter        = integer\n    newton_raphson    = 0: not applied, 1: only in the end, 2: beginning and end\n    newton_iter       = integer\n    relax_vinface     = T or F\n    eps_vinface       = real\n/ triFS.x utility uses special tri_FS and FS_opt namelists,\nsee triFS_input_parameters module for the description of each parameter in those namelists.\nSee intw_input_parameters module for the description of each parameter in the input namelist.","tags":"","url":"program/trifs.html"},{"title":"intw2W90 – INTW","text":"Uses intw_fft intw_intw2wannier omp_lib intw_allwfcs intw_reading intw_version intw_symmetries intw_input_parameters kinds intw_utility Interface for Wannier90. Details The purpose of this utility is to perform the same tasks as the\nprogram \"pw2wannier90\" which is part of the QE distribution, but\nutilizing a minimum set of (QE generated) Bloch functions, using\nsymmetry. The code reads the seedname.nnkp file generated by wannier90 and\ncomputes and writes overlap matrices (seedname.mmn), energy\neigenvalues (seedname.eig) and initial projections (seedname.amn). Input parameters &input\n    outdir                = 'directory'\n    prefix                = 'prefix'\n    nk1                   = integer\n    nk2                   = integer\n    nk3                   = integer\n    TR_symmetry           = T or F\n    use_exclude_bands     = 'none', 'wannier' or 'custom'\n    include_bands_initial = integer\n    include_bands_final   = integer\n/\n&intw2W\n    intw2W_fullzone = T or F\n    intw2W_method   = 'CONVOLUTION' or 'FFT'\n    compute_amn     = T or F\n    compute_mmn     = T or F\n/ See intw_input_parameters module for the description of each parameter.","tags":"","url":"program/intw2w90.html"},{"title":"interpolate – INTW","text":"Uses omp_lib intw_reading intw_w90_setup intw_version intw_utility intw_input_parameters kinds Interpolate electron band structure and DOS using Wannier interpolation. Details Uses nnkp and ham_r files to write an interpolated band structure and DOS.\nProjections on Wannier functions are also provided, so that \"fatband\"\nand PDOS plots can be made. MBR 2024 Input parameters &input\n    outdir                = 'directory'\n    prefix                = 'prefix'\n    chemical_potential    = real\n    use_exclude_bands     = 'none', 'wannier' or 'custom'\n    include_bands_initial = integer\n    include_bands_final   = integer\n/\n&DOS\n    nk1_dos    = integer\n    nk2_dos    = integer\n    nk3_dos    = integer\n    ne_dos     = integer\n    eini_dos   = real\n    efin_dos   = real\n    esmear_dos = real\n    kTsmear    = real\n/\nK_PATH\n    nkpath nkspecial\n    label(1) kspecial_x(1) kspecial_y(1) kspecial_z(1)\n    label(2) kspecial_x(2) kspecial_y(2) kspecial_z(2)\n    ...\n    label(nkspecial) kspecial_x(nkspecial) kspecial_y(nkspecial) kspecial_z(nkspecial) See intw_input_parameters module for the description of each parameter.","tags":"","url":"program/interpolate.html"},{"title":"ep_melements – INTW","text":"Uses intw_fft intw_ph intw_symmetries intw_useful_constants intw_pseudo_non_local intw_matrix_vector intw_allwfcs intw_reading intw_version intw_pseudo_local intw_pseudo intw_input_parameters kinds intw_utility Compute electron-phonon matrix elements in a regular k- and q-mesh. Details This program calculates the electron-phonon matrix elements for\na given mesh of k- and q-points. It reads wave functions,\npseudopotentials, and phonon data, then computes the matrix elements\nby integrating over the Brillouin zone. The program can handle custom band selections or all available bands. Input parameters &input\n    outdir                = 'directory'\n    prefix                = 'prefix'\n    nk1                   = integer\n    nk2                   = integer\n    nk3                   = integer\n    TR_symmetry           = T or F\n    use_exclude_bands     = 'none', 'wannier' or 'custom'\n    include_bands_initial = integer\n    include_bands_final   = integer\n/\n&ph\n    qlist = 'file'\n    nq1   = integer\n    nq2   = integer\n    nq3   = integer\n    nqirr = integer\n/\n&elphon\n    ep_mat_file      = 'file'\n    ep_bands         = 'intw' or 'custom'\n    ep_bands_initial = integer\n    ep_bands_final   = integer\n/ See intw_input_parameters module for the description of each parameter.","tags":"","url":"program/ep_melements.html"},{"title":"ep_on_trFS_wannier – INTW","text":"Uses intw_ph intw_useful_constants omp_lib intw_matrix_vector intw_intw2wannier intw_ph_interpolate intw_reading intw_version intw_w90_setup intw_utility intw_input_parameters kinds Compute electron-phonon matrix elements on a triangulated Fermi\nsurface using Wannier interpolation. Details This utility reads the electron-phonon matrix elements calculated by the utility ep_melements of INTW and interpolates them on a triangulated Fermi surface,\nfollowing the method of:\nF. Giustino et al, Phys. Rev. B 76, 165108 (2007)\nFinally, interpolated matrix elements are saved to file. MBR 24/04/2024 Input parameters &input\n    outdir                = 'directory'\n    prefix                = 'prefix'\n    nk1                   = integer\n    nk2                   = integer\n    nk3                   = integer\n    TR_symmetry           = T or F\n    use_exclude_bands     = 'none', 'wannier' or 'custom'\n    include_bands_initial = integer\n    include_bands_final   = integer\n/\n&ph\n    qlist           = 'file'\n    nq1             = integer\n    nq2             = integer\n    nq3             = integer\n    nqirr           = integer\n/\n&elphon\n    ep_mat_file         = 'file'\n    ep_bands            = 'intw' or 'custom'\n    ep_bands_initial    = integer\n    ep_bands_final      = integer\n    ep_interp_method    = 'wannier'\n    ep_interp_bands     = 'intw_bands' or 'ef_crossing'\n    nfs_sheets_initial  = integer\n    nfs_sheets_final    = integer\n/ See intw_input_parameters module for the description of each parameter.","tags":"","url":"program/ep_on_trfs_wannier.html"},{"title":"w902intw – INTW","text":"Uses intw_intw2wannier intw_reading intw_w90_setup intw_version intw_utility intw_input_parameters kinds Build and save Wannier U and H(R) matrices for use within INTW. Details Input parameters &input\n    outdir                = 'directory'\n    prefix                = 'prefix'\n    nk1                   = integer\n    nk2                   = integer\n    nk3                   = integer\n    use_exclude_bands     = 'none', 'wannier' or 'custom'\n    include_bands_initial = integer\n    include_bands_final   = integer\n/ See intw_input_parameters module for the description of each parameter.","tags":"","url":"program/w902intw.html"},{"title":"a2F_on_trFS – INTW","text":"Uses intw_ph intw_symmetries intw_ph_interpolate intw_matrix_vector kinds intw_reading intw_version intw_utility intw_input_parameters intw_useful_constants Calculate Eliashberg function from electron-phonon coupling\nmatrix elements interpolated on a triangulated Fermi surface. Details a2F integral = double loop on kpoints of the FS triangulation.\nThe ep element calculated for q=k'-k is read from a file.\nThe needed phonons and dynamical matrices calculated by QE are\nread in and then interpolated as in the method of:\nF. Giustino et al, Phys. Rev. B 76, 165108 (2007) MBR 26/04/2024 Input parameters &input\n    outdir                = 'directory'\n    prefix                = 'prefix'\n    TR_symmetry           = T or F\n    use_exclude_bands     = 'none', 'wannier' or 'custom'\n    include_bands_initial = integer\n    include_bands_final   = integer\n/\n&ph\n    qlist           = 'file'\n    read_for_dynmat = 'fc' or 'dynq'\n    fc_mat          = 'file'\n    nq1             = integer\n    nq2             = integer\n    nq3             = integer\n    nqirr           = integer\n    apply_asr       = T or F\n/\n&DOS_ph\n    nomega    = integer\n    omega_ini = real\n    omega_fin = real\n    osmear_q  = real\n    omega_cut = real\n/\n&elphon\n    ep_interp_bands     = 'intw_bands' or 'ef_crossing'\n    nfs_sheets_initial  = integer\n    nfs_sheets_final    = integer\n/ See intw_input_parameters module for the description of each parameter.","tags":"","url":"program/a2f_on_trfs.html"},{"title":"interpolate_phonons – INTW","text":"Uses intw_ph intw_symmetries intw_useful_constants omp_lib intw_ph_interpolate intw_reading intw_version intw_utility intw_input_parameters kinds Interpolate phonon dispersion and DOS using Fourier interpolation. Details Uses atom-pair-adapted WS vectors to interpolate dynamical matrices. MBR June 2024 Input parameters &input\n    outdir                = 'directory'\n    prefix                = 'prefix'\n    TR_symmetry           = T or F\n    use_exclude_bands     = 'none', 'wannier' or 'custom'\n    include_bands_initial = integer\n    include_bands_final   = integer\n/\n&ph\n    qlist           = 'file'\n    read_for_dynmat = 'fc' or 'dynq'\n    fc_mat          = 'file'\n    nq1             = integer\n    nq2             = integer\n    nq3             = integer\n    nqirr           = integer\n    apply_asr       = T or F\n/\n&DOS_ph\n    nq1_dosph = integer\n    nq2_dosph = integer\n    nq3_dosph = integer\n    nomega    = integer\n    omega_ini = real\n    omega_fin = real\n    osmear_q  = real\n/\nQ_PATH\n    nqpath nqspecial\n    label(1) qspecial_x(1) qspecial_y(1) qspecial_z(1)\n    label(2) qspecial_x(2) qspecial_y(2) qspecial_z(2)\n    ...\n    label(nqspecial) qspecial_x(nqspecial) qspecial_y(nqspecial) qspecial_z(nqspecial) See intw_input_parameters module for the description of each parameter.","tags":"","url":"program/interpolate_phonons.html"},{"title":"ep_interp_on_trFS_dV.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! program ep_on_trFS_dV !! display: none !! !! Compute electron-phonon matrix elements on a triangulated Fermi !! surface using induced potential interpolation. !! !! ### Details !! !! This utility calculates electron-phonon matrix elements interpolated on a Fermi surface triangulation !! following the method of: !! !! A. Eiguren, C. Ambrosch-Draxl, Phys. Rev. B 78, 045124 (2008) !! !! For that, the induced potentials calculated with QE on the q-grid are read in !! and interpolated to the non-uniform q-list corresponding to the triangulation (q=k'-k) !! Needed wavefunctions on the triangulated k-points are calculated on the fly by calling QE and stored. !! If such calculations preexist, those wavefunctions are read. !! !! ##### 1st part: !! !! 1.- From files prefix.N_FS_tri.off, where N is the Fermi surface (FS) sheet, !!     it reads the lists of k-points at the vertices, and the faces, in order to calculate !!     areas. !! !! 2.- It writes a prefix-nscf.nscf.in input for pw.x by reading prefix.scf.in !!     and replacing the k-points by the FS triangulation information. !! !! 3.- It writes a prefix-nscf.pw2intw.in file, which will convert wfc data from !!     prefix-nscf.save directory. !! !! 4.- It sets a directory prefix-nscf.save and initializes it with the scf charge density. !!     It runs pw.x and applies pw2intw.x to the obtained wfcs. In case the prefix-nscf.save/wfc !!     files exist, it skips this and warns the user. !! !!    (In the case of using SIESTA step 2 to 4 are done with siesta2intw.x) !! !! ##### 2nd part: !! !! Read derivative of local potential (dvq_local) on the real space unit cell for !! q-vectors of full BZ and Fourier transform to R (Wigner-Seitz) !! as the first step of the interpolation. !! The non-local part will be added on the fly when interpolating over the triangulated k-points. !! !! ##### 3rd part: !! !! Loop over FS (one loop over irreducible BZ wedge, one loop over full BZ). !! For each k, k' interpolate the potential for q = k' - k. !! Read the wave functions for k and k' from their corresponding prefix-nscf.save/wfc files. !! Calculate electron-phonon matrix elements (local + non-local) as done in [[ep_melements]] utility. !! Finally, interpolated matrix elements are saved to file. !! !! MBR 24/04/2024 !! !! #### Input parameters !! !! ```{.txt} !! &input !!     outdir                = 'directory' !!     prefix                = 'prefix' !!     TR_symmetry           = T or F !!     use_exclude_bands     = 'none', 'wannier' or 'custom' !!     include_bands_initial = integer !!     include_bands_final   = integer !! / !! &ph !!     qlist           = 'file' !!     nq1             = integer !!     nq2             = integer !!     nq3             = integer !!     nqirr           = integer !! / !! &elphon !!     ep_interp_method    = 'dV_interpolate' !!     ep_interp_bands     = 'intw_bands' or 'ef_crossing' !!     nfs_sheets_initial  = integer !!     nfs_sheets_final    = integer !!     nscf_code           = 'QE' or 'SIESTA' !!     command_pw          = 'command' !!     command_pw2intw     = 'command' !!     file_pw             = 'file' !!     command_siesta2intw = 'command' !!     file_siesta2intw    = 'file' !! / !! ``` !! !! See [[intw_input_parameters]] module for the description of each parameter. !! #ifdef _OPENMP use omp_lib , only : omp_get_num_threads , omp_get_thread_num #endif use kinds , only : dp use intw_version , only : print_intw_version use intw_useful_constants , only : cmplx_0 , cmplx_i , tpi use intw_utility , only : get_timing , print_threads , print_date_time , find_free_unit , & cryst_to_cart , generate_kmesh , joint_to_triple_index_r use intw_matrix_vector , only : area_vec use intw_input_parameters , only : outdir , prefix , & nq1 , nq2 , nq3 , nqirr , & ep_interp_method , ep_interp_bands , & nfs_sheets_initial , nfs_sheets_final , & nscf_code , read_input use intw_reading , only : num_bands_intw , nGk_max , at , nr1 , nr2 , nr3 , & nat , tau , nsym , s , nspin , lspin , & read_parameters_data_file , set_num_bands , & get_gvec , get_K_folder_data use intw_pseudo , only : read_all_pseudo use intw_pseudo_local , only : calculate_local_part_dv , dvqpsi_local use intw_pseudo_non_local , only : init_KB_PP , multiply_psi_by_dvKB use intw_symmetries , only : rtau , rtau_cryst , rtau_index , symtable , & set_symmetry_relations , multable , rot_atoms , & allocate_and_build_spin_symmetry_matrices , & find_inverse_symmetry_matrices_indices , & find_size_of_irreducible_k_set use intw_fft , only : generate_nl , allocate_fft use intw_ph , only : nqmesh , qmesh , q_irr_cryst , & QE_folder_nosym_q , QE_folder_sym_q , symlink_q , & read_ph_information , read_allq_dvr , get_dv use intw_ph_interpolate , only : irvec_q , nrpts_q , ndegen_q , & allocate_and_build_ws_irvec_q implicit none ! FS triangulation integer :: nfs_sheets_tot ! number of FS sheets considered integer :: nkpt_tr_tot , nkpt_tr_ibz_tot ! total number of kpoints in the FS and in the irreducible BZ wedge integer , allocatable :: nfs_sheet (:), & ! band indices of the FS sheets (from num_bands_intw set) nkpt_tr (:), & ! number of kpoints in each FS sheet nkpt_tr_ibz (:), & ! number of kpoints in each FS sheet irreducible BZ wedge nface_tr (:) ! number of faces in each FS sheet real ( dp ), allocatable :: kpts_tr (:,:), & ! list of all kpoints kpts_tr_area (:) ! area of each kpoint in the FS integer , allocatable :: ikibz_2_ik (:), & ! index of the ikibz kpoint inside the irreducible BZ wedge in the list of all kpoints ik_2_ish (:), & ! FS sheet index of kpts_tr(:,ik) ik_2_iks (:) ! index of kpts_tr(:,ik) in its FS sheet kpoints list ! for part I logical :: read_status character ( 5 ) :: ish_loc , comment character ( 100 ) :: file_off integer :: unit_off real ( dp ) :: k1 ( 3 ), k2 ( 3 ), k3 ( 3 ), kwei ! for part II logical :: full_mesh_q , IBZ_q integer :: qmesh_nqirr real ( dp ) :: qpoint ( 3 ), rvec ( 3 ) complex ( dp ) :: facq complex ( dp ), allocatable :: dvq_local_R (:,:,:,:,:) integer :: iq_start , iq_end #ifdef _OPENMP integer :: nq , nq_remaining integer :: thread_id , thread_num #endif ! for part III logical :: have_ep character ( 256 ) :: altprefix , file_ep integer :: unit_ep integer :: nG , nG_p integer , allocatable :: list_iG (:), list_iG_p (:) real ( dp ) :: kpoint ( 3 ), kpoint_p ( 3 ) real ( dp ), allocatable :: QE_eig (:), QE_eig_p (:) complex ( dp ), allocatable :: wfc (:,:,:), wfc_p (:,:,:) complex ( dp ), allocatable :: wfc_all (:,:,:) complex ( dp ), allocatable :: dvq_local (:,:,:,:) complex ( dp ), allocatable :: dvpsi (:,:,:,:,:) complex ( dp ), allocatable :: aep_mat_el (:,:,:,:,:) ! loop variables and indices integer :: ik , ikp , ikibz , ikibz_global , ikibz_do , iks , iksp integer :: ish , ishp , ib , ibp integer :: ik1 , ik2 , ik3 integer :: ir1 , ir2 , ir3 integer :: iface , iedge integer :: is , js integer :: ir , jr integer :: iat integer :: iq ! timing real ( dp ) :: time1 , time2 complex ( dp ), external :: zdotc 20 format ( A ) 30 format ( A , F8 . 2 , 6 X , A ) !================================================================================ ! Beginning !================================================================================ call get_timing ( time1 ) write ( * , 20 ) '=====================================================' write ( * , 20 ) '|               program ep_on_triFS_dV              |' write ( * , 20 ) '|         e-p calculation on triangulated FS        |' write ( * , 20 ) '|  using interpolation of dV on the triangulated q  | ' write ( * , 20 ) '|         ---------------------------------         |' call print_intw_version () call print_threads () call print_date_time ( \"Start of execution\" ) write ( * , 20 ) '=====================================================' !================================================================================ ! Read the input file !================================================================================ call read_input ( read_status ) if ( read_status ) stop ! check right method is chosen in intw.in if ( ep_interp_method /= 'dV_interpolate' ) then write ( * , * ) 'ep_interp_method /= dV_interpolate in input. Stopping.' stop end if !================================================================================ ! Read the parameters from the SCF calculation !================================================================================ write ( * , 20 ) '| - Reading calculation parameters...               |' call read_parameters_data_file () !================================================================================ ! Set the number of bands !================================================================================ ! this will read num_wann_intw and num_bands_intw dimensions call set_num_bands () !================================================================================ ! Print spin information !================================================================================ if ( lspin ) then write ( * , 20 ) '| - Spin-polarized calculation nspin = 2            |' else write ( * , 20 ) '| - Paramagnetic calculation nspin = 1              |' endif write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Set symmetry arrays !================================================================================ write ( * , 20 ) '| - Setting symmetry arrays...                      |' ! Set the rotation table for each atom and symmetry allocate ( rtau_index ( nat , nsym )) allocate ( rtau ( 3 , nsym , nat )) allocate ( rtau_cryst ( 3 , nsym , nat )) call rot_atoms ( nat , nsym , tau ) ! Compute the indices of the inverse rotation matrices call find_inverse_symmetry_matrices_indices () ! Calculate the multiplication talble for symmetry operations allocate ( symtable ( nsym , nsym )) call multable ( nsym , s , symtable ) ! Set up spin_symmetry_matrices, needed to rotate wave functions and indueced potential for non-colinear calculations call allocate_and_build_spin_symmetry_matrices ( nsym ) write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Set up the gvec array and all FFT variables !================================================================================ write ( * , 20 ) '| - Reading G vectors...                            |' call get_gvec () ! Allocate useful variables call allocate_fft () ! Generate some important indices for FFT call generate_nl () write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Read PPs !================================================================================ write ( * , 20 ) '| - Reading pseudopotentials...                     |' call read_all_pseudo () write ( * , 20 ) '|                    PPs are OK                     |' ! Allocate and set PP variables call init_KB_PP () !================================================================================ ! Choose Fermi surface sheets according to ep_interp_bands !================================================================================ if ( ep_interp_bands == 'intw_bands' ) then nfs_sheets_tot = num_bands_intw allocate ( nfs_sheet ( nfs_sheets_tot )) do ib = 1 , num_bands_intw nfs_sheet ( ib ) = ib end do else if ( ep_interp_bands == 'ef_crossing' ) then nfs_sheets_tot = nfs_sheets_final - nfs_sheets_initial + 1 allocate ( nfs_sheet ( nfs_sheets_tot )) do ib = 1 , nfs_sheets_tot nfs_sheet ( ib ) = nfs_sheets_initial + ib - 1 end do end if !================================ Part I ==================================== !================================================================================ ! Read .off files !================================================================================ write ( * , 20 ) '=====================================================' write ( * , 20 ) '| - Reading .off files...                           |' allocate ( nkpt_tr ( nfs_sheets_tot ), nface_tr ( nfs_sheets_tot )) allocate ( nkpt_tr_ibz ( nfs_sheets_tot )) ! open all sheet files just to see dimensions of kpoint lists do ish = 1 , nfs_sheets_tot if ( ish < 10 ) write ( ish_loc , \"(i1)\" ) nfs_sheet ( ish ) if ( 10 <= ish . and . ish < 100 ) write ( ish_loc , \"(i2)\" ) nfs_sheet ( ish ) file_off = trim ( outdir ) // trim ( prefix ) // trim ( '.' ) // trim ( adjustl ( ish_loc )) // trim ( '_FS_tri.off' ) write ( * , '(A)' ) '|     ' // file_off ( 1 : max ( 45 , len ( trim ( file_off )))) // ' |' unit_off = find_free_unit () open ( unit_off , file = file_off , status = 'old' ) read ( unit_off , * ) comment read ( unit_off , * ) nkpt_tr ( ish ), nface_tr ( ish ), iedge ! number of vertices and faces (ignore edges) close ( unit_off ) ! open the IBZ off file and search for dimension nkpt_tr_ibz(ish). ! Its vertices coincide with the first nkpt_tr_ibz(ish) vertices of the full off vertex list. file_off = trim ( outdir ) // trim ( prefix ) // trim ( '.' ) // trim ( adjustl ( ish_loc )) // trim ( '_IBZ_FS_tri.off' ) unit_off = find_free_unit () open ( unit_off , file = file_off , status = 'old' ) read ( unit_off , * ) comment read ( unit_off , * ) nkpt_tr_ibz ( ish ), iface , iedge ! number of vertices (ignore faces and edges) close ( unit_off ) end do ! total number of k-points to be calculated nkpt_tr_tot = sum ( nkpt_tr ) nkpt_tr_ibz_tot = sum ( nkpt_tr_ibz ) write ( * , 20 ) '|   Number of k-points (total vertices):            |' write ( * , '(A1,3X,I6,42X,A1)' ) '|' , nkpt_tr_tot , '|' write ( * , 20 ) '|   Number of k-points in IBZ (total vertices):     |' write ( * , '(A1,3X,I6,42X,A1)' ) '|' , nkpt_tr_ibz_tot , '|' write ( * , 20 ) '|   Number of faces (total triangles):              |' write ( * , '(A1,3X,I6,42X,A1)' ) '|' , sum ( nface_tr ), '|' allocate ( kpts_tr ( 3 , nkpt_tr_tot ), kpts_tr_area ( nkpt_tr_tot )) allocate ( ikibz_2_ik ( nkpt_tr_ibz_tot )) allocate ( ik_2_ish ( nkpt_tr_tot )) allocate ( ik_2_iks ( nkpt_tr_tot )) ikibz_2_ik = - 10 ik_2_ish = - 10 ik_2_iks = - 10 ! open .off files again to read k-points do ish = 1 , nfs_sheets_tot if ( ish < 10 ) write ( ish_loc , \"(i1)\" ) nfs_sheet ( ish ) if ( 10 <= ish . and . ish < 100 ) write ( ish_loc , \"(i2)\" ) nfs_sheet ( ish ) ! .off file for this sheet file_off = trim ( outdir ) // trim ( prefix ) // trim ( '.' ) // trim ( adjustl ( ish_loc )) // trim ( '_FS_tri.off' ) unit_off = find_free_unit () open ( unit_off , file = file_off , status = 'old' ) read ( unit_off , * ) comment read ( unit_off , * ) ik , iface , iedge ! number vertices, faces and edges (I will ignore edges) ! read(unit_off,'(/)') ! DUDA... This will depend on how the line break is written in the file, I think... if ( ( ik /= nkpt_tr ( ish )) . or . ( iface /= nface_tr ( ish )) ) then write ( * , * ) 'Error reading ' , file_off , '. Stopping.' stop end if ! read vertices do iks = 1 , nkpt_tr ( ish ) ik = iks + sum ( nkpt_tr (: ish - 1 )) ik_2_ish ( ik ) = ish ik_2_iks ( ik ) = iks if ( iks <= nkpt_tr_ibz ( ish )) then ! kpoint is in the irreducible BZ wedge ikibz = iks + sum ( nkpt_tr_ibz (: ish - 1 )) ikibz_2_ik ( ikibz ) = ik endif read ( unit_off , * ) kpts_tr (:, ik ) ! units in the trFS.off file are cartesian 2pi/alat (\"tpiba\" for QE) end do ! Read (triangular) faces on this sheet. ! Each face contributes with 1/3 of its area to the effective area of each of its vertices. ! Calculate the are on the go and add the contribution to each vertex, storing for global indices (i.e. ik). do iface = 1 , nface_tr ( ish ) read ( unit_off , * ) ik , ik1 , ik2 , ik3 ! indices ik of the vertices of the face, indexed from 0 if ( ik /= 3 ) then write ( * , * ) 'Error reading ' , file_off , 'Only triangles allowed. Stopping.' stop end if ik1 = ik1 + 1 ik2 = ik2 + 1 ik3 = ik3 + 1 ! now, ik of the vertices of the face, indexed from 1 ik1 = ik1 + sum ( nkpt_tr (: ish - 1 )) ik2 = ik2 + sum ( nkpt_tr (: ish - 1 )) ik3 = ik3 + sum ( nkpt_tr (: ish - 1 )) ! now, ik in the global ik list ! triangle vertex vectors (cartesian 2pi/alat) k1 = kpts_tr (:, ik1 ) k2 = kpts_tr (:, ik2 ) k3 = kpts_tr (:, ik3 ) ! get spanned area and add contribution to each vertex ! function copied from FSH/modules/geometry.f90 kwei = area_vec ( k2 - k1 , k3 - k1 ) / 3.0_dp kpts_tr_area ( ik1 ) = kpts_tr_area ( ik1 ) + kwei kpts_tr_area ( ik2 ) = kpts_tr_area ( ik2 ) + kwei kpts_tr_area ( ik3 ) = kpts_tr_area ( ik3 ) + kwei end do close ( unit_off ) end do if ( any ( ikibz_2_ik == - 10 )) stop \"ERROR ikibz_2_ik\" if ( any ( ik_2_ish == - 10 )) stop \"ERROR ik_2_ib\" if ( any ( ik_2_iks == - 10 )) stop \"ERROR ik_2_iks\" write ( * , 20 ) '|   .... reading done                               |' write ( * , 20 ) '|   Total FS area:                                  |' write ( * , '(A1,3X,F12.6,A19,17X,A1)' ) '|' , sum ( kpts_tr_area ), ' (2 x pi / alat)&#94;2 ' , '|' write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Run nscf calculation for the FS k-points !================================================================================ if ( nscf_code == \"QE\" ) then call QE_nscf () else if ( nscf_code == \"SIESTA\" ) then call SIESTA_nscf () else stop \"ERROR: Invalid value for nscf_code variable.\" endif write ( * , 20 ) '|                                                   |' write ( * , 20 ) '| ---------------- Part I completed --------------- |' write ( * , 20 ) '|                                                   |' write ( * , 20 ) '=====================================================' !================================ Part II ==================================== !================================================================================ ! Read phonon information !================================================================================ write ( * , 20 ) '| - Reading phonon info...                          |' ! Read irreducible q-points and irreducible patterns call read_ph_information () write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Build the phonon q-mesh !================================================================================ write ( * , 20 ) '| - Building q-mesh...                              |' nqmesh = nq1 * nq2 * nq3 allocate ( qmesh ( 3 , nqmesh )) call generate_kmesh ( qmesh , nq1 , nq2 , nq3 ) ! Find the size of the irreducible set of q-points (IBZ) call find_size_of_irreducible_k_set ( nq1 , nq2 , nq3 , qmesh_nqirr ) !================================================================================ ! Set symmetry relations between irreducible q-points and full q-mesh !================================================================================ allocate ( QE_folder_nosym_q ( nqmesh )) allocate ( QE_folder_sym_q ( nqmesh )) allocate ( symlink_q ( nqmesh , 2 )) call set_symmetry_relations ( nq1 , nq2 , nq3 , nqirr , q_irr_cryst , & QE_folder_nosym_q , QE_folder_sym_q , symlink_q , & full_mesh_q , IBZ_q ) !================================================================================ ! Check that the number of q-points corresponds to either a full mesh or the IBZ !================================================================================ if ( full_mesh_q . and . IBZ_q ) then write ( * , 20 ) '| - The qpoints present in the QE folders           |' write ( * , 20 ) '|   are consistent with a full 1BZ and a            |' write ( * , 20 ) '|   IBZ has also been found.                        |' else if ( IBZ_q ) then write ( * , 20 ) '| - The qpoints present in the QE folders           |' write ( * , 20 ) '|   are consistent with an IBZ.                     |' else write ( * , 20 ) '**********************************************************' write ( * , 20 ) '* The qpoints present in the QE folders are not consistent' write ( * , 20 ) '* with the parameters of the input file!                 ' write ( * , 20 ) '**********************************************************' write ( * , 20 ) '* debug information:                                *' write ( * , * ) '*        nqpoints_QE = ' , nqirr write ( * , * ) '*        nqmesh      = ' , nqmesh write ( * , * ) '*        qmesh_nqirr = ' , qmesh_nqirr stop end if !================================================================================ ! Obtain dV(q) (as in the ep_elements utility written by Haritz). !================================================================================ write ( * , 20 ) '| - Reading induced potentials...                   |' call read_allq_dvr () write ( * , 20 ) '=====================================================' !================================================================================ ! Fourier transform a la Wannier of q->R of dvq_local using the Wigner-Seitz supercell grid. ! Loop over whole mesh: obtain dvq_local for each q-point and add it to the Fourier transform !================================================================================ ! Wigner-Seitz R points write ( * , 20 ) '| - Building WS mesh...                             |' call allocate_and_build_ws_irvec_q () write ( * , 20 ) '| - Fourier transform induced potential...          |' ! Potential in the supercell using Wigner-Seitz R points allocate ( dvq_local_R ( nrpts_q , nr1 * nr2 * nr3 , 3 * nat , nspin , nspin )) allocate ( dvq_local ( nr1 * nr2 * nr3 , 3 * nat , nspin , nspin )) dvq_local_R = cmplx_0 !$omp parallel reduction(+: dvq_local_R) & !$omp default(none) & !$omp shared(nqmesh, qmesh) & !$omp shared(nr1, nr2, nr3) & !$omp shared(nrpts_q, irvec_q) & !$omp private(iq, qpoint, dvq_local, facq) & !$omp private(ir, ir1, ir2, ir3, rvec, jr) & !$omp shared(thread_num, nq, nq_remaining) & !$omp private(thread_id, iq_start, iq_end) ! ! Calculate the range of iterations for this thread. ! If nqmesh is a multiple of thread_num, each thread ! will run nq iterations. ! Otherwise, the first nq_remaining threads will run ! an extra iteration. ! #ifdef _OPENMP !$omp single thread_num = omp_get_num_threads () nq = int ( nqmesh / thread_num ) ! Number of iterations for each thread nq_remaining = mod ( nqmesh , thread_num ) ! Remainig q-points that need to be distributed !$omp end single ! thread_id = omp_get_thread_num () iq_start = nq * thread_id + min ( thread_id , nq_remaining ) + 1 iq_end = nq * ( thread_id + 1 ) + min ( thread_id + 1 , nq_remaining ) #else iq_start = 1 iq_end = nqmesh #endif ! !$omp parallel do reduction(+: dvq_local_R) & !$omp default(none) & !$omp shared(nqmesh, qmesh) & !$omp shared(nr1, nr2, nr3) & !$omp shared(nrpts_q, irvec_q) & !$omp private(qpoint, dvq_local, facq) & !$omp private(ir, ir1, ir2, ir3, rvec, jr) & !$omp shared(iq_start, iq_end) do iq = iq_start , iq_end qpoint = qmesh (:, iq ) write ( * , '(A12,I5,3f11.5,A3)' ) '|     qpoint' , iq , qpoint , \"  |\" ! Compute induced potential using symmetries dvq_local = cmplx_0 call get_dv ( qpoint , dvq_local ) ! Compute local part of the derivative of the KB PP call calculate_local_part_dv ( qpoint , dvq_local ) ! transform with phase: iq*(r-R) do ir = 1 , nr1 * nr2 * nr3 ! unit cell coordinates(1:nr1) ! ir to (ir1,ir2,ir3), 3rd index fastest call joint_to_triple_index_r ( nr1 , nr2 , nr3 , ir , ir1 , ir2 , ir3 ) rvec ( 1 ) = real ( ir1 - 1 , dp ) / real ( nr1 , dp ) ! r-vector in fractional coord. rvec ( 2 ) = real ( ir2 - 1 , dp ) / real ( nr2 , dp ) rvec ( 3 ) = real ( ir3 - 1 , dp ) / real ( nr3 , dp ) do jr = 1 , nrpts_q facq = exp ( cmplx_i * tpi * dot_product ( qpoint , rvec (:) - irvec_q (:, jr ))) dvq_local_R ( jr , ir ,:,:,:) = dvq_local_R ( jr , ir ,:,:,:) + facq * dvq_local ( ir ,:,:,:) end do ! R in WS end do ! e in unit cell end do !$omp end parallel do !$omp end parallel dvq_local_R = dvq_local_R / real ( nqmesh , dp ) ! normalize Fourier transform write ( * , 20 ) '|                                                   |' write ( * , 20 ) '|  --------------- Part II completed -------------- |' write ( * , 20 ) '|                                                   |' write ( * , 20 ) '=====================================================' ! DUDA dvq_local_R in the supercell should be real? !=============================== Part III ===================================== write ( * , 20 ) '| - Interpolating e-p elements...                   |' ! For the a2F integral we will need a double loop on kpoints of the FS triangulation. ! In this part the final ep element is calculated on the go for q=k'-k after ! backtransform of dV local: ! dvq_local(k+q,k) = dvq_local(k',k) ! allocate dvpsi for only one band, as band index is included in the k indices and thus ! run one-by-one in the loops below allocate ( dvpsi ( nGk_max , 1 , nspin , nspin , 3 * nat )) allocate ( aep_mat_el ( nkpt_tr_tot , nkpt_tr_ibz_tot , nspin , nspin , 3 * nat )) allocate ( list_iG ( nGk_max ), list_iG_p ( nGk_max )) allocate ( QE_eig ( num_bands_intw ), QE_eig_p ( num_bands_intw )) allocate ( wfc_all ( nGk_max , num_bands_intw , nspin )) allocate ( wfc ( nGk_max , 1 , nspin ), wfc_p ( nGk_max , 1 , nspin )) altprefix = trim ( prefix ) // '-nscf' file_ep = trim ( outdir ) // trim ( prefix ) // trim ( '_ep_interp.dat' ) inquire ( file = file_ep , exist = have_ep ) if (. not . have_ep ) then ! calculate interpolated ep elements and write to file_ep ikibz_global = 0 !$omp parallel do & !$omp default(none) & !$omp shared(at, nat, nspin, nr1, nr2, nr3, nGk_max) & !$omp shared(ikibz_2_ik, ik_2_iks, ik_2_ish, nfs_sheet) & !$omp shared(kpts_tr, nkpt_tr_tot, nkpt_tr_ibz_tot) & !$omp shared(ndegen_q, irvec_q, nrpts_q, dvq_local_R) & !$omp shared(wfc_all, altprefix) & !$omp shared(aep_mat_el) & !$omp shared(ikibz_global) & !$omp private(ikibz, ik, iks, ish, ib) & !$omp private(kpoint, list_iG, wfc, QE_eig, nG) & !$omp private(ikp, iksp, ishp, ibp) & !$omp private(kpoint_p, list_iG_p, wfc_p, QE_eig_p, nG_p) & !$omp private(ir, jr, ir1, ir2, ir3, rvec, facq) & !$omp private(qpoint, dvq_local, dvpsi) & !$omp private(iat, is, js) do ikibz_do = 1 , nkpt_tr_ibz_tot !$omp critical ikibz_global = ikibz_global + 1 ikibz = ikibz_global ! ikibz is the k-index over kpoints in the irreducible BZ wedge ik = ikibz_2_ik ( ikibz ) ! ik is the corresponding k-index over kpoints in the full BZ kpts_tr list iks = ik_2_iks ( ik ) ! iks is the corresponding k-index over the kpoints in the FS sheet ! ish = ik_2_ish ( ik ) ! FS sheet index for k ib = nfs_sheet ( ish ) ! band index for k write ( * , '(A14,I4,A1,I4,A6,I5,A19)' ) '|     ik_IBZ: ' , ikibz , \"/\" , nkpt_tr_ibz_tot , ' (ik: ' , ik , \")                 |\" kpoint = kpts_tr (:, ik ) ! this is cartesians x 2pi/alat. Transform to cryst. call cryst_to_cart ( 1 , kpoint , at , - 1 ) ! Read wavefunction k call get_K_folder_data ( ik , list_iG , wfc_all , QE_eig , nG , altprefix ) wfc = wfc_all (:, ib : ib ,:) !$omp end critical !$omp parallel do & !$omp default(none) & !$omp shared(at, nat, nspin, nr1, nr2, nr3, nGk_max) & !$omp shared(ik_2_iks, ik_2_ish, nfs_sheet) & !$omp shared(kpts_tr, nkpt_tr_tot) & !$omp shared(ndegen_q, irvec_q, nrpts_q, dvq_local_R) & !$omp shared(wfc_all, altprefix) & !$omp shared(kpoint, QE_eig, nG) & !$omp shared(ikibz, iks) & !$omp firstprivate(list_iG, wfc) & !$omp shared(aep_mat_el) & !$omp private(iksp, ishp, ibp) & !$omp private(kpoint_p, list_iG_p, wfc_p, QE_eig_p, nG_p) & !$omp private(ir, jr, ir1, ir2, ir3, rvec, facq) & !$omp private(qpoint, dvq_local, dvpsi) & !$omp private(iat, is, js) do ikp = 1 , nkpt_tr_tot iksp = ik_2_iks ( ikp ) ! iksp is the corresponding k-index over the kpoints in the FS sheet ! ishp = ik_2_ish ( ikp ) ! FS sheet index for k ibp = nfs_sheet ( ishp ) ! band index for k' kpoint_p = kpts_tr (:, ikp ) ! this is cartesians x 2pi/alat. Transform to cryst. call cryst_to_cart ( 1 , kpoint_p , at , - 1 ) ! Read wavefunction k' !$omp critical call get_K_folder_data ( ikp , list_iG_p , wfc_all , QE_eig_p , nG_p , altprefix ) wfc_p = wfc_all (:, ibp : ibp ,:) !$omp end critical qpoint = kpoint_p - kpoint ! Fourier backtransform a la Wannier: interpolation of dV local at qpoint ! with e&#94;{-iq.(r-R)}, where R is a lattice vector of the WS supercell, as ! we would do in Wannier. dvq_local = cmplx_0 ! watch out: I am reusing this array in this step of k,k' double loop do ir = 1 , nr1 * nr2 * nr3 ! unit cell coordinates(1:nr1) ! ir to (ir1,ir2,ir3), 3rd index fastest call joint_to_triple_index_r ( nr1 , nr2 , nr3 , ir , ir1 , ir2 , ir3 ) rvec ( 1 ) = real ( ir1 - 1 , dp ) / real ( nr1 , dp ) ! r-vector in fractional coord. rvec ( 2 ) = real ( ir2 - 1 , dp ) / real ( nr2 , dp ) rvec ( 3 ) = real ( ir3 - 1 , dp ) / real ( nr3 , dp ) do jr = 1 , nrpts_q facq = exp ( - cmplx_i * tpi * dot_product ( qpoint , rvec (:) - irvec_q (:, jr ))) / real ( ndegen_q ( jr ), dp ) dvq_local ( ir ,:,:,:) = dvq_local ( ir ,:,:,:) + facq * dvq_local_R ( jr , ir ,:,:,:) end do ! R in WS end do ! r in unit cell ! Multiply psi_k with induced potential + local part of the KB PP: !   dvpsi_{k+q} = dv_local_{q} x |psi_{k}> call dvqpsi_local ( 1 , list_iG , list_iG_p , wfc , dvq_local , dvpsi ) ! Add non-local contribution: Multiply psi_k with non-local part of the KB PP: !   dvpsi_{k+q} --> dvpsi_{k+q} + d_{q} [ KB ] |psi_{k}> !                   (local)     + (non-local) call multiply_psi_by_dvKB ( kpoint , qpoint , list_iG , list_iG_p , 1 , wfc , dvpsi ) ! Compute matrix elements: Multiply dvpsi with psi_{k+q} do iat = 1 , 3 * nat do js = 1 , nspin do is = 1 , nspin aep_mat_el ( ikp , ikibz , js , is , iat ) = & zdotc ( nGk_max , wfc_p (:, 1 , js ), 1 , dvpsi (:, 1 , js , is , iat ), 1 ) enddo ! is enddo ! js enddo ! iat end do ! k' !$omp end parallel do end do ! k !$omp end parallel do ! Save interpolated matrix elements unit_ep = find_free_unit () open ( unit_ep , file = file_ep , status = 'unknown' ) write ( unit_ep , * ) '# ik(irr)   jk(full)    is js   g(canonical modes)' ! do ikibz = 1 , nkpt_tr_ibz_tot ! ik = ikibz_2_ik ( ikibz ) ! ik is the corresponding k-index over kpoints in the full BZ kpts_tr list iks = ik_2_iks ( ik ) ! iks is the corresponding k-index over the kpoints in the FS sheet ish = ik_2_ish ( ik ) ! FS sheet index for k ib = nfs_sheet ( ish ) ! band index for k ! do ikp = 1 , nkpt_tr_tot ! iksp = ik_2_iks ( ikp ) ! iksp is the corresponding k-index over the kpoints in the FS sheet ishp = ik_2_ish ( ikp ) ! FS sheet index for k ibp = nfs_sheet ( ishp ) ! band index for k' ! do js = 1 , nspin do is = 1 , nspin write ( unit_ep , fmt = \"(6i6,100e16.6)\" ) ibp , iksp , ikp , ib , iks , ikibz , & ( aep_mat_el ( ikp , ikibz , js , is , iat ), iat = 1 , 3 * nat ) end do end do ! end do ! k' ! end do ! k ! close ( unit_ep ) ! write ( * , 20 ) '| - e-p elements interpolated and written to file:  |' write ( * , 20 ) \"|   \" // file_ep ( 1 : max ( 47 , len ( trim ( file_ep )))) // \" |\" else ! have_ep--> read interpolated matrix elements write ( * , 20 ) '| - interpolated e-p file already exists. Check!    |' write ( * , 20 ) \"|   \" // file_ep ( 1 : max ( 47 , len ( trim ( file_ep )))) // \" |\" end if write ( * , 20 ) '|                                                   |' write ( * , 20 ) '|  -------------- Part III completed -------------- |' write ( * , 20 ) '|                                                   |' write ( * , 20 ) '=====================================================' !================================================================================ ! Finish !================================================================================ call get_timing ( time2 ) write ( * , 20 ) '|                      ALL DONE                     |' write ( * , 30 ) '|     Total time: ' , time2 - time1 , ' seconds            |' call print_date_time ( 'End of execution  ' ) write ( * , 20 ) '=====================================================' contains subroutine QE_nscf () implicit none character ( 100 ) :: file_nscf_in , file_nscf_out character ( 100 ) :: file_pw2intw_in , file_pw2intw_out character ( 100 ) :: dir_nscf , dir_nscf_intw logical :: have_nscf_out , have_nscf_wfcN , have_nscf_wfc1 character ( 5 ) :: ik_loc !================================================================================ ! Read prefix.scf.in file line by line and dump information to prefix-nscf.nscf.in. ! For that, the lines containing calculation and prefix are modified. ! When arriving at KPOINTS, reading stops and the triangle list is dumped to the ! prefix-nscf.nscf.in file. ! Note: this is done only in case the nscf files do not exist (otherwise, ! it is assumed that the wfcs have already been calculated and transformed to intw format) !================================================================================ !================================================================================ ! Check pw2intw ! Check if first and last wfc are present. If so, it probably means that the nscf ! calculation was already made, so skip this step !================================================================================ file_pw2intw_in = trim ( outdir ) // trim ( prefix ) // '-nscf.pw2intw.in' file_pw2intw_out = trim ( outdir ) // trim ( prefix ) // '-nscf.pw2intw.out' dir_nscf_intw = trim ( outdir ) // trim ( prefix ) // \"-nscf.save.intw/\" inquire ( file = file_pw2intw_out , exist = have_nscf_out ) write ( ik_loc , \"(i5.5)\" ) 1 inquire ( file = trim ( dir_nscf_intw ) // 'wfc' // trim ( adjustl ( ik_loc )) // '.dat' , exist = have_nscf_wfc1 ) write ( ik_loc , \"(i5.5)\" ) nkpt_tr_tot inquire ( file = trim ( dir_nscf_intw ) // 'wfc' // trim ( adjustl ( ik_loc )) // '.dat' , exist = have_nscf_wfcN ) if ( have_nscf_out . and . have_nscf_wfc1 . and . have_nscf_wfcN ) then write ( * , '(A)' ) '| - INTW nscf wfcs seem to be already available.    |' write ( * , '(A)' ) '|   Skipping nscf calculation!                      |' return endif !================================================================================ ! Check QE nscf ! Check if first and last wfc are present. If so, it probably means that the nscf ! calculation was already made, so skip this step !================================================================================ file_nscf_in = trim ( outdir ) // trim ( prefix ) // '-nscf.nscf.in' file_nscf_out = trim ( outdir ) // trim ( prefix ) // '-nscf.nscf.out' dir_nscf = trim ( outdir ) // trim ( prefix ) // \"-nscf.save/\" inquire ( file = file_nscf_out , exist = have_nscf_out ) write ( ik_loc , \"(i5)\" ) 1 inquire ( file = trim ( dir_nscf ) // 'wfc' // trim ( adjustl ( ik_loc )) // '.dat' , exist = have_nscf_wfc1 ) write ( ik_loc , \"(i5)\" ) nkpt_tr_tot inquire ( file = trim ( dir_nscf ) // 'wfc' // trim ( adjustl ( ik_loc )) // '.dat' , exist = have_nscf_wfcN ) if ( have_nscf_out . and . have_nscf_wfc1 . and . have_nscf_wfcN ) then write ( * , '(A)' ) '| - QE nscf wfcs seem to be already available.      |' write ( * , '(A)' ) '|   Skipping QE nscf calculation!                   |' call run_pw2intw ( file_pw2intw_in , file_pw2intw_out ) else write ( * , '(A)' ) '| - Calculating nscf wfcs with QE...                |' call run_pw ( file_nscf_in , file_nscf_out , dir_nscf ) call run_pw2intw ( file_pw2intw_in , file_pw2intw_out ) end if end subroutine QE_nscf subroutine run_pw ( file_nscf_in , file_nscf_out , dir_nscf ) ! Create the input file and run the nscf calculation with pw.x use intw_input_parameters , only : command_pw , file_pw implicit none character ( 100 ), intent ( in ) :: file_nscf_in , file_nscf_out character ( 100 ), intent ( in ) :: dir_nscf logical :: exists_charge_density , exists_schema , exists_charge_density_qe , exists_schema_qe character ( 70 ) :: line , lleft character ( 100 ) :: dir_scf , dir_scf_intw character ( 200 ) :: comando , datafile integer :: unit_pw , unit_nscf , ios integer :: ikpt ! Create input file for nscf calculation unit_pw = find_free_unit () open ( unit_pw , file = trim ( file_pw ), status = 'old' , iostat = ios ) if ( ios /= 0 ) stop \"ERROR opening file_pw! Stopping.\" unit_nscf = find_free_unit () open ( unit_nscf , file = trim ( file_nscf_in ), status = 'unknown' , iostat = ios ) if ( ios /= 0 ) stop \"ERROR opening file_nscf_in! Stopping.\" do read ( unit_pw , '(a)' , iostat = ios ) line if ( ios /= 0 ) stop \"ERROR reading file_pw! Stopping.\" lleft = trim ( adjustl ( line )) if ( lleft ( 1 : 11 ) == 'calculation' ) then write ( unit_nscf , * ) \" calculation = 'nscf'\" else if ( lleft ( 1 : 6 ) == 'prefix' ) then write ( unit_nscf , * ) \" prefix = '\" // trim ( prefix ) // \"-nscf'\" else if ( lleft ( 1 : 8 ) == 'K_POINTS' ) then exit else write ( unit_nscf , * ) line end if end do write ( unit_nscf , * ) \" K_POINTS {tpiba} \" write ( unit_nscf , * ) nkpt_tr_tot do ikpt = 1 , nkpt_tr_tot write ( unit_nscf , '(3f16.9,2x,f4.1)' ) kpts_tr (:, ikpt ), 1.0_dp end do close ( unit_pw ) close ( unit_nscf ) ! Create directory for nscf calculation prefix-nscf.save comando = 'mkdir -p ' // trim ( dir_nscf ) ! it will not create it if it already exists call execute_command_line ( comando ) ! copy scf input files (force copy) to prefix-nscf.save ! If charge-density.dat and data-file-schema.xml have already been stored in ! prefix.save.intw directory, first try to get them from there. ! Otherwise, attempt to get them from prefix.save (the scf QE calculation directory, ! if it still exists) ! Try INTW directory (.save.intw) dir_scf_intw = trim ( outdir ) // trim ( prefix ) // \".save.intw/\" datafile = trim ( dir_scf_intw ) // 'charge-density.dat' inquire ( file = datafile , exist = exists_charge_density ) datafile = trim ( dir_scf_intw ) // 'data-file-schema.xml' inquire ( file = datafile , exist = exists_schema ) if ( exists_schema . and . exists_charge_density ) then ! Continuation files found in INTW directory dir_scf = dir_scf_intw else ! Try searching them in QE scf directory (prefix.save) write ( * , '(A)' ) '| - Continuation files for nscf not present in:     |' write ( * , '(A)' ) '|   ' // dir_scf_intw ( 1 : max ( 47 , len ( trim ( dir_scf_intw )))) // \" |\" dir_scf = trim ( outdir ) // trim ( prefix ) // \".save/\" write ( * , '(A)' ) '| - Searching in:                                   |' write ( * , '(A)' ) '|   ' // dir_scf ( 1 : max ( 47 , len ( trim ( dir_scf )))) // \" |\" datafile = trim ( dir_scf ) // 'charge-density.dat' inquire ( file = datafile , exist = exists_charge_density_qe ) datafile = trim ( dir_scf ) // 'data-file-schema.xml' inquire ( file = datafile , exist = exists_schema_qe ) if ( (. not . exists_schema_qe ) . or . (. not . exists_charge_density_qe ) ) then write ( * , * ) 'Continuation files for nscf neither present in: ' , trim ( dir_scf ) write ( * , * ) 'Error. Stopping' stop end if end if write ( * , '(A)' ) '| - Using continuation files for nscf from:         |' write ( * , '(A)' ) '|   ' // dir_scf ( 1 : max ( 47 , len ( trim ( dir_scf )))) // \" |\" ! copy scf input files (force copy) comando = 'cp -f ' // trim ( dir_scf ) // 'charge-density.dat ' // trim ( dir_nscf ) call execute_command_line ( comando ) comando = 'cp -f ' // trim ( dir_scf ) // 'data-file-schema.xml ' // trim ( dir_nscf ) call execute_command_line ( comando ) ! Invoke QE pw.x to do nscf. ! command_pw may contain running options (e.g. mpirun) if ( command_pw == \"unassigned\" ) then stop \"ERROR: Unassigned command_pw variable.\" else comando = trim ( command_pw ) // \" < \" // trim ( file_nscf_in ) // \" > \" // trim ( file_nscf_out ) end if write ( * , '(A)' ) \"| - Running QE with command:                        |\" write ( * , '(A)' ) \"|   \" // comando ( 1 : max ( 47 , len ( trim ( comando )))) // \" |\" call execute_command_line ( comando ) end subroutine run_pw subroutine run_pw2intw ( file_pw2intw_in , file_pw2intw_out ) ! Create input file and run pw2intw.x use intw_input_parameters , only : command_pw2intw implicit none character ( 100 ), intent ( in ) :: file_pw2intw_in , file_pw2intw_out character ( 200 ) :: comando integer :: unit_pw2intw , ios ! Create input file for pw2intw unit_pw2intw = find_free_unit () open ( unit_pw2intw , file = trim ( file_pw2intw_in ), status = 'unknown' , iostat = ios ) if ( ios /= 0 ) stop \"ERROR opening file_pw2intw_in! Stopping.\" write ( unit_pw2intw , * ) trim ( prefix ) write ( unit_pw2intw , * ) \"&inputpp\" write ( unit_pw2intw , * ) \"  outdir = './'\" write ( unit_pw2intw , * ) \"  prefix = '\" // trim ( prefix ) // \"-nscf'\" write ( unit_pw2intw , * ) \"  phonons = .false.\" write ( unit_pw2intw , * ) \"/\" close ( unit_pw2intw ) ! Invoke pw2intw.x to transform nscf data to INTW format ! command_pw2intw may contain running options (e.g. mpirun) if ( command_pw2intw == \"unassigned\" ) then stop \"ERROR: Unassigned command_pw2intw variable.\" else comando = trim ( command_pw2intw ) // \" < \" // trim ( file_pw2intw_in ) // \" > \" // trim ( file_pw2intw_out ) end if write ( * , '(A)' ) \"| - Running pw2intw with command:                   |\" write ( * , '(A)' ) \"|   \" // comando ( 1 : max ( 47 , len ( trim ( comando )))) // \" |\" call execute_command_line ( comando ) end subroutine run_pw2intw subroutine SIESTA_nscf () implicit none character ( 100 ) :: file_s2intw_nscf_in , file_s2intw_nscf_out character ( 100 ) :: dir_nscf_intw logical :: have_nscf_out , have_nscf_wfc1 , have_nscf_wfcN character ( 5 ) :: ik_loc !================================================================================ ! Read s2intw.in file line by line and dump information to s2intw.in_nscf. ! nscf data will be written in prefix-nscf.save.intw directory. ! For that, the prefix is modified. ! The triangle list is added to the s2intw.in_nscf file. ! Note: this is done only in case the siesta2intw-nscf.out does not exist (otherwise, ! it is assumed that the wfcs have already been calculated and transformed to intw format) !================================================================================ !================================================================================ ! Check siesta2intw ! Check if first and last wfc are present. If so, it probably means that the nscf ! calculation was already made, so skip this step !================================================================================ file_s2intw_nscf_in = trim ( outdir ) // trim ( prefix ) // '-nscf.siesta2intw.in' file_s2intw_nscf_out = trim ( outdir ) // trim ( prefix ) // '-nscf.siesta2intw.out' dir_nscf_intw = trim ( outdir ) // trim ( prefix ) // \"-nscf.save.intw/\" inquire ( file = file_s2intw_nscf_out , exist = have_nscf_out ) write ( ik_loc , \"(i5.5)\" ) 1 inquire ( file = trim ( dir_nscf_intw ) // 'wfc' // trim ( adjustl ( ik_loc )) // '.dat' , exist = have_nscf_wfc1 ) write ( ik_loc , \"(i5.5)\" ) nkpt_tr_tot inquire ( file = trim ( dir_nscf_intw ) // 'wfc' // trim ( adjustl ( ik_loc )) // '.dat' , exist = have_nscf_wfcN ) if ( have_nscf_out . and . have_nscf_wfc1 . and . have_nscf_wfcN ) then write ( * , '(A)' ) '| - INTW nscf wfcs seem to be already available.    |' write ( * , '(A)' ) '|   Skipping nscf calculation!                      |' else write ( * , '(A)' ) '| - Calculating nscf wfcs with siesta2intw...       |' call run_siest2intw ( file_s2intw_nscf_in , file_s2intw_nscf_out ) endif end subroutine SIESTA_nscf subroutine run_siest2intw ( file_s2intw_nscf_in , file_s2intw_nscf_out ) ! Create input file and run siesta2intw.x use intw_input_parameters , only : command_siesta2intw , file_siesta2intw implicit none character ( 100 ), intent ( in ) :: file_s2intw_nscf_in , file_s2intw_nscf_out logical :: exists_density_matrix character ( 70 ) :: line , lleft logical :: write_nk character ( 200 ) :: comando , datafile integer :: unit_s2intw , unit_s2intw_nscf , ios integer :: ikpt real ( dp ), dimension ( 3 ) :: kpts_tr_cryst ! Create input file for siesta2intw unit_s2intw = find_free_unit () open ( unit_s2intw , file = trim ( file_siesta2intw ), status = 'old' , iostat = ios ) if ( ios /= 0 ) stop \"ERROR opening file_siesta2intw! Stopping.\" unit_s2intw_nscf = find_free_unit () open ( unit_s2intw_nscf , file = trim ( file_s2intw_nscf_in ), status = 'unknown' , iostat = ios ) if ( ios /= 0 ) stop \"ERROR opening file_s2intw_nscf_in! Stopping.\" write_nk = . true . do read ( unit_s2intw , '(a)' , iostat = ios ) line if ( ios /= 0 ) stop \"ERROR reading file_siesta2intw! Stopping.\" lleft = trim ( adjustl ( line )) if ( lleft ( 1 : 6 ) == 'prefix' ) then write ( unit_s2intw_nscf , * ) \" prefix = '\" // trim ( prefix ) // \"-nscf'\" else if ( lleft ( 1 : 7 ) == 'phonons' ) then write ( unit_s2intw_nscf , * ) \" phonons = .false.\" else if ( lleft ( 1 : 3 ) == 'nk1' . or . lleft ( 1 : 3 ) == 'nk2' . or . lleft ( 1 : 3 ) == 'nk3' ) then if ( write_nk ) write ( unit_s2intw_nscf , * ) \" nk1=0, nk2=0, nk3=0\" write_nk = . false . else if ( lleft ( 1 : 1 ) == '/' ) then exit else write ( unit_s2intw_nscf , * ) trim ( line ) end if end do close ( unit_s2intw ) write ( unit_s2intw_nscf , * ) \"/\" write ( unit_s2intw_nscf , * ) \"KPOINTS\" write ( unit_s2intw_nscf , * ) nkpt_tr_tot do ikpt = 1 , nkpt_tr_tot kpts_tr_cryst = kpts_tr (:, ikpt ) ! this is cartesians x 2pi/alat. Transform to cryst. call cryst_to_cart ( 1 , kpts_tr_cryst , at , - 1 ) write ( unit_s2intw_nscf , '(3f16.9,2x,f4.1)' ) kpts_tr_cryst end do close ( unit_s2intw_nscf ) ! Check if density matrix file is present datafile = trim ( outdir ) // trim ( prefix ) // \".DM\" inquire ( file = datafile , exist = exists_density_matrix ) if ( . not . exists_density_matrix ) then write ( * , * ) 'Density matrix file needed for nscf not present: ' , trim ( datafile ) write ( * , * ) 'Error. Stopping' stop end if write ( * , '(A)' ) '| - Using density matrix file:                      |' write ( * , '(A)' ) '|   ' // datafile ( 1 : max ( 47 , len ( trim ( datafile )))) // \" |\" ! Invoke siesta2intw.x to do nscf and transform nscf data to INTW format ! command_siesta2intw may contain running options (e.g. mpirun) if ( command_siesta2intw == \"unassigned\" ) then stop \"ERROR: Unassigned command_siesta2intw variable.\" else comando = trim ( command_siesta2intw ) // \" < \" // trim ( file_s2intw_nscf_in ) // \" > \" // trim ( file_s2intw_nscf_out ) end if write ( * , '(A)' ) \"| - Running siesta2intw with command:               |\" write ( * , '(A)' ) \"|   \" // comando ( 1 : max ( 47 , len ( trim ( comando )))) // \" |\" call execute_command_line ( comando ) end subroutine run_siest2intw end program ep_on_trFS_dV","tags":"","url":"sourcefile/ep_interp_on_trfs_dv.f90.html"},{"title":"input_parameters.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_input_parameters !! display: public !! !! This module contains the definitions of all input parameters for INTW !! as well as subroutines for reading and checking the input. !! !! ### Details !! !! #### Input parameters !! !! ```{.txt} !! &input !!     outdir                = 'directory' !!     prefix                = 'prefix' !!     nk1                   = integer !!     nk2                   = integer !!     nk3                   = integer !!     tr_symmetry           = T or F (Default: T) !!     chemical_potential    = real (Default: 0.0 eV) !!     use_exclude_bands     = 'none', 'wannier' or 'custom' !!     include_bands_initial = integer !!     include_bands_final   = integer !! / !! &intw2W !!     intw2w_fullzone = T or F (Default: F) !!     intw2w_method   = 'CONVOLUTION' or 'FFT' (Default: 'CONVOLUTION') !!     compute_amn     = T or F (Default: T) !!     compute_mmn     = T or F (Default: T) !! / !! &ph !!     qlist           = 'file' (Default: 'qlist.txt') !!     read_for_dynmat = 'fc' or 'dynq' (Default: 'dynq') !!     fc_mat          = 'file' !!     nq1             = integer !!     nq2             = integer !!     nq3             = integer !!     nqirr           = integer !!     apply_asr       = T or F (Default: T) !! / !! &DOS !!     nk1_dos    = integer (Default: 20) !!     nk2_dos    = integer (Default: 20) !!     nk3_dos    = integer (Default: 20) !!     ne_dos     = integer (Default: 100) !!     eini_dos   = real (Default: -10.0 eV) !!     efin_dos   = real (Default: 10.0 eV) !!     esmear_dos = real (Default: 0.05 eV) !!     ktsmear    = real (Default: 0.01 eV) !! / !! &DOS_ph !!     nq1_dosph = integer (Default: 20) !!     nq2_dosph = integer (Default: 20) !!     nq3_dosph = integer (Default: 20) !!     nomega    = integer (Default: 100) !!     omega_ini = real (Default: 0.0 Ry) !!     omega_fin = real (Default: 0.005 Ry) !!     osmear_q  = real (Default: 0.000075 Ry) !!     omega_cut = real (Default: 0.0 Ry) !! / !! &elphon !!     ep_mat_file         = 'file' (Default: 'ep_mat.dat') !!     ep_bands            = 'intw' or 'custom' (Default: 'intw') !!     ep_bands_initial    = integer !!     ep_bands_final      = integer !!     ep_interp_method    = 'wannier' or 'dV_interpolate' !!     ep_interp_bands     = 'intw_bands' or 'ef_crossing' (Default: 'intw_bands') !!     nfs_sheets_initial  = integer !!     nfs_sheets_final    = integer !!     nscf_code           = 'QE' or 'SIESTA' !!     command_pw          = 'command' !!     command_pw2intw     = 'command' !!     file_pw             = 'file' !!     command_siesta2intw = 'command' !!     file_siesta2intw    = 'file' !! / !! K_PATH !!     nkpath nkspecial !!     label(1) kspecial_x(1) kspecial_y(1) kspecial_z(1) !!     label(2) kspecial_x(2) kspecial_y(2) kspecial_z(2) !!     ... !!     label(nkspecial) kspecial_x(nkspecial) kspecial_y(nkspecial) kspecial_z(nkspecial) !! Q_PATH !!     nqpath nqspecial !!     label(1) qspecial_x(1) qspecial_y(1) qspecial_z(1) !!     label(2) qspecial_x(2) qspecial_y(2) qspecial_z(2) !!     ... !!     label(nqspecial) qspecial_x(nqspecial) qspecial_y(nqspecial) qspecial_z(nqspecial) !! ``` !! !! `K_PATH` and `Q_PATH` cards are used to generate the path along the Brilloin zone !! to plot electron band structure and phonon frequency dispersion, respectively. !! !! Variables without default values must be explicitly set in the input !! file; otherwise, an error will be raised. !! use kinds , only : dp ! implicit none ! save ! ! variables ! &input public :: input , outdir , prefix , nk1 , nk2 , nk3 , TR_symmetry , chemical_potential , & use_exclude_bands , include_bands_initial , include_bands_final ! &intw2W public :: intw2W , intw2W_fullzone , intw2W_method , compute_mmn , compute_amn ! &ph public :: ph , qlist , read_for_dynmat , fc_mat , & nq1 , nq2 , nq3 , nqirr , apply_asr ! &DOS public :: DOS , ne_dos , eini_dos , efin_dos , esmear_dos , ktsmear , nk1_dos , nk2_dos , nk3_dos ! &DOS_ph public :: DOS_ph , nq1_dosph , nq2_dosph , nq3_dosph , nomega , omega_ini , omega_fin , osmear_q , omega_cut ! &elphon public :: elphon , ep_mat_file , ep_bands , ep_bands_initial , ep_bands_final , ep_interp_method , & ep_interp_bands , nfs_sheets_initial , nfs_sheets_final , nscf_code , & command_pw , command_pw2intw , file_pw , & command_siesta2intw , file_siesta2intw ! K_PATH public :: exist_kpath , nkpath , nkspecial , kspecial ! Q_PATH public :: exist_qpath , nqpath , nqspecial , qspecial ! ! subroutines public :: read_input , read_cards ! private !----------------------------------------------------------------------------! ! &input namelist variables !----------------------------------------------------------------------------! character ( len = 256 ) :: outdir = 'unassigned' !! The directory where the DFT calculations are stored character ( len = 256 ) :: prefix = 'unassigned' !! The prefix of the DFT calculation integer :: nk1 = - 1 , nk2 = - 1 , nk3 = - 1 !! Monkhorst-Pack mesh indices for the coarse k-mesh real ( dp ) :: chemical_potential = 0.0_dp !! The value which determines the occupation factors (Units: eV) logical :: TR_symmetry = . true . !! If TR symmetry is present TR_symmetry = .true. character ( 256 ) :: use_exclude_bands = \"unassigned\" !! Three options to select the bands used in various utilities: !! !! - `use_exclude_bands='none'`: we don't exclude any band and therefore we use all bands from the DFT calculation !!   (Error if nnkp file is present) !    NOTE: Haritz 17/07/2025: Should we raise this error? !! !! - `use_exclude_bands='wannier'`: we exclude the bands indicated by Wannier90 in nnkp file !!   (Error if nnkp file is NOT present) !! !! - `use_exclude_bands='custom'`: use the subset of bands (`include_bands_initial:include_bands_final`) !!   from the bands considered by the DFT calculation and exclude the rest of bands !!   (Error if include_bands_initial, include_bands_final not present) integer :: include_bands_initial = 0 , include_bands_final = 0 !! The initial and final band indices for `use_exclude_bands='custom'` !----------------------------------------------------------------------------! ! &intw2W namelist variables !----------------------------------------------------------------------------! logical :: intw2W_fullzone = . false . !! If True, the code wil assume that a full zone DFT calculation !! has been performed and that wavefunctions for every k-point !! are available. This is mostly for testing and directly comparing !! the results of intw2W90 and pw2wannier character ( 256 ) :: intw2W_method = 'CONVOLUTION' !! Two options to select which method use to compute matrix elements: !! !! - `intw2W_method = 'CONVOLUTION'` !! - `intw2W_method = 'FFT'` logical :: compute_mmn = . true . !! If True, the code produces the $prefix.mmn and $prefix.eig files logical :: compute_amn = . true . !! If True, the code produces the $prefix.amn file !----------------------------------------------------------------------------! ! &ph namelist variables !----------------------------------------------------------------------------! character ( 256 ) :: qlist = 'qlist.txt' !! Name of the file containing the irreducible q-points list (relative to outdir) character ( 256 ) :: fc_mat = '--.fc' !! Name of the force constants matrix (relative to outdir) character ( 256 ) :: read_for_dynmat = 'dynq' !! Two options to choose: !! !! - `read_for_dynmat = 'fc'`: to read force constants from fc_mat file !! - `read_for_dynmat = 'dynq'`: to read .dyn files from the phonon calculations logical :: apply_asr = . true . !! Whether apply Acoustic Sum Rule or not integer :: nq1 = - 1 , nq2 = - 1 , nq3 = - 1 !! Monkhorst-Pack mesh indices for the coarse q-mesh integer :: nqirr = - 1 !! Number of irreducible q-points !----------------------------------------------------------------------------! ! &DOS namelist variables for Wannier interpolatied DOS plot !----------------------------------------------------------------------------! integer :: nk1_dos = 20 , nk2_dos = 20 , nk3_dos = 20 !! Interpolation k-grid for DOS plot integer :: ne_dos = 100 !! Number of energy points in DOS plot real ( dp ) :: eini_dos = - 1 0.0_dp , efin_dos = 1 0.0_dp !! Energy range for electron DOS plot (Units: eV) real ( dp ) :: esmear_dos = 0.05_dp !! Smearing width for electron DOS plot (Units: eV) real ( dp ) :: ktsmear = 0.01_dp !! Smearing (kT) for Fermi level electron DOS calculation (Units: eV) !----------------------------------------------------------------------------! ! &DOS_ph namelist variables for intepolated phonon DOS plot ! and also used for the Eliashberg function plot !----------------------------------------------------------------------------! integer :: nq1_dosph = 20 , nq2_dosph = 20 , nq3_dosph = 20 !! Interpolation q-grid for phonon DOS plot integer :: nomega = 100 !! Number of energy points in DOS plot real ( dp ) :: omega_ini = 0.0_dp , omega_fin = 0.005_dp !! Energy range for phonon DOS plot (Units: Ry) real ( dp ) :: osmear_q = 0.000075 !! Smearing width for phonon DOS plot (Units: Ry) real ( dp ) :: omega_cut = - 1.0_dp !! Phonon frequency cut-off for removing w -> 0 peak in a2F (Units: Ry) !----------------------------------------------------------------------------! ! &elphon namelist variables for ep elements calculation !----------------------------------------------------------------------------! character ( 256 ) :: ep_mat_file = \"ep_mat.dat\" !! Name of the electron-phonon matrix elements file character ( 256 ) :: ep_bands = 'intw' !! Two options to select the subset of bands for computing the electron-phonon !! matrix elements: !! !! - `ep_bands = 'intw'`: compute matrix elements for all bands considered by INTW (See [[use_exclude_bands]] variable) !! - `ep_bands = 'custom'`: compute matrix elements for the custom subset of bands (ep_bands_initial:ep_bands_final) !!   from the bands considered by INTW (See [[use_exclude_bands]] variable) integer :: ep_bands_initial = 0 !! The initial and final band indices for `ep_bands = 'custom'` integer :: ep_bands_final = 0 !! The initial and final band indices for `ep_bands = 'custom'` ! For ep elements interpolation utilities: character ( 256 ) :: ep_interp_method = 'unassigned' !! Two options to choose the interpolation method: !! !! - `ep_interp_method = 'wannier'` !! - `ep_interp_method = 'dV_interpolate'` character ( 256 ) :: ep_interp_bands = 'intw_bands' !! Two options to select the subset of bands to interpolate electron-phonon matrix elements: !! !! - `ep_interp_bands = 'intw_bands'`: interpolate matrix elements for all bands considered by INTW (See use_exclude_bands variable) !! - `ep_interp_bands = 'ef_crossing'`: interpolate matrix elements for the substet of bands that cross the Fermi level (nfs_sheets_initial:nfs_sheets_final) !!   from the bands considered by INTW (See use_exclude_bands variable) integer :: nfs_sheets_initial = 0 !! The initial band index for `ep_interp_bands = 'ef_crossing'` integer :: nfs_sheets_final = 0 !! The final band index for `ep_interp_bands = 'ef_crossing'` character ( len = 256 ) :: nscf_code = 'unassigned' !! The DFT code used for running the nscf calculation (only needed if !! `ep_interp_method = 'dV_interpolate'` is chosen): !! !! - `nscf_code = 'QE'` !! - `nscf_code = 'SIESTA'` character ( len = 256 ) :: command_pw = 'unassigned' !! pw.x executable, with optional running options !! that go ahead of the executable like 'mpirun -np N', 'nice', etc. character ( len = 256 ) :: command_pw2intw = 'unassigned' !! pw2intw.x executable, with optional running options !! that go ahead of the executable like 'mpirun -np N', 'nice', etc. character ( len = 256 ) :: file_pw = 'unassigned' !! The input file for pw.x. character ( len = 256 ) :: command_siesta2intw = 'unassigned' !! siesta2intw.x executable, with optional running options !! that go ahead of the executable like 'mpirun -np N', 'nice', etc. character ( len = 256 ) :: file_siesta2intw = 'unassigned' !! The input file for siesta2intw.x. !----------------------------------------------------------------------------! ! K_PATH card variables !----------------------------------------------------------------------------! logical :: exist_kpath ! Whether K_PATH card for plotting electron bands exists or not integer :: nkpath !! Number of total k-points in the path integer :: nkspecial !! Number of special k-points in the path real ( dp ) , allocatable :: kspecial (:,:) !! List of special k-points in crystal coordinates !----------------------------------------------------------------------------! ! Q_PATH card variables !----------------------------------------------------------------------------! logical :: exist_qpath ! Whether Q_PATH card for plotting phonons bands exists or not integer :: nqpath !! Number of total q-points in the path integer :: nqspecial !! Number of special q-points in the path real ( dp ) , allocatable :: qspecial (:,:) !! List of special q-points in crystal coordinates !----------------------------------------------------------------------------! ! Define namelists !----------------------------------------------------------------------------! NAMELIST / input / outdir , prefix , nk1 , nk2 , nk3 , & TR_symmetry , chemical_potential , & use_exclude_bands , include_bands_initial , include_bands_final NAMELIST / intw2W / intw2W_fullzone , intw2W_method , & compute_mmn , compute_amn NAMELIST / ph / qlist , read_for_dynmat , fc_mat , ep_mat_file , & nq1 , nq2 , nq3 , nqirr , apply_asr NAMELIST / DOS / nk1_dos , nk2_dos , nk3_dos , ne_dos , & eini_dos , efin_dos , esmear_dos , ktsmear NAMELIST / DOS_ph / nq1_dosph , nq2_dosph , nq3_dosph , nomega , & omega_ini , omega_fin , osmear_q , omega_cut NAMELIST / elphon / ep_bands , ep_bands_initial , ep_bands_final , & ep_interp_method , ep_interp_bands , & nfs_sheets_initial , nfs_sheets_final , nscf_code , & command_pw , command_pw2intw , file_pw , & command_siesta2intw , file_siesta2intw ! ---------------------------------------------------------------------- !  END namelist ! ---------------------------------------------------------------------- contains subroutine read_input ( read_status ) !! This subroutine reads all namelists from standard input, !! and checks their validity and consistency. use intw_useful_constants , only : eps_10 implicit none integer :: ios , strlen logical :: read_status read_status = . false . write ( * , 20 ) '| - Reading standard input file...                  |' write ( * , 20 ) '|         namelist             ios                  |' write ( * , 20 ) '|         --------             ----                 |' read ( 5 , input , iostat = ios ) write ( * , 22 ) '|           &input             ' , ios , '                   |' read ( 5 , intw2W , iostat = ios ) write ( * , 22 ) '|           &intw2W            ' , ios , '                   |' read ( 5 , ph , iostat = ios ) write ( * , 22 ) '|           &ph                ' , ios , '                   |' read ( 5 , DOS , iostat = ios ) write ( * , 22 ) '|           &DOS               ' , ios , '                   |' read ( 5 , DOS_ph , iostat = ios ) write ( * , 22 ) '|           &DOS_ph            ' , ios , '                   |' read ( 5 , elphon , iostat = ios ) write ( * , 22 ) '|           &elphon            ' , ios , '                   |' write ( * , 20 ) '=====================================================' !  Test the various read parameters if ( outdir == 'unassigned' ) then read_status = . true . write ( * , * ) 'MISSING outdir!' end if if ( prefix == 'unassigned' ) then read_status = . true . write ( * , * ) 'MISSING prefix!' end if if ( nk1 == 0 ) then read_status = . true . write ( * , * ) 'MISSING nk1!' end if if ( nk2 == 0 ) then read_status = . true . write ( * , * ) 'MISSING nk2!' end if if ( nk3 == 0 ) then read_status = . true . write ( * , * ) 'MISSING nk3!' end if if ( trim ( use_exclude_bands ) == 'unassigned' ) then read_status = . true . write ( * , * ) 'MISSING use_exclude_bands' else if ( trim ( use_exclude_bands ) /= 'none' & . and . trim ( use_exclude_bands ) /= 'custom' & . and . trim ( use_exclude_bands ) /= 'wannier' ) then read_status = . true . write ( * , * ) 'Error: Wrong value for use_exclude_bands!' end if if ( trim ( use_exclude_bands ) == 'custom' . and . & ( include_bands_final * include_bands_initial . le . 0 . or . & include_bands_final . lt . include_bands_initial ) ) then read_status = . true . write ( * , * ) 'Error: Invalid use_exclude_bands custom selection!' end if if ( trim ( ep_bands ) /= 'intw' & . and . trim ( ep_bands ) /= 'custom' ) then read_status = . true . write ( * , * ) 'Error: Wrong value for ep_bands!' end if if ( trim ( ep_bands ) == 'custom' & . and . & ( ep_bands_initial * ep_bands_final <= 0 & . or . ep_bands_final < ep_bands_initial ) ) then read_status = . true . write ( * , * ) 'Error: Invalid ep_bands custom selection!' end if if ( trim ( ep_interp_bands ) /= 'intw_bands' & . and . trim ( ep_interp_bands ) /= 'ef_crossing' ) then read_status = . true . write ( * , * ) 'Error: Wrong value for ep_interp_bands!' end if if ( trim ( ep_interp_bands ) == 'ef_crossing' & . and . & ( nfs_sheets_initial * nfs_sheets_final < 0 & . or . nfs_sheets_final < nfs_sheets_initial ) ) then read_status = . true . write ( * , * ) 'Error: Invalid ep_interp_bands custom selection!' end if if ( trim ( ep_interp_method ) /= 'unassigned' ) then if ( trim ( ep_interp_method ) /= 'wannier' & . and . trim ( ep_interp_method ) /= 'dV_interpolate' ) then read_status = . true . write ( * , * ) 'Error: Wrong value for ep_interp_method!' endif end if if ( trim ( ep_interp_method ) == 'dV_interpolate' ) then ! if ( trim ( nscf_code ) == 'unassigned' ) then read_status = . true . write ( * , * ) 'Error: dV_interpolate method chosen, but nscf_code not specified!' else if ( trim ( nscf_code ) == 'QE' ) then if ( trim ( command_pw ) == 'unassigned' ) then read_status = . true . write ( * , * ) 'Error: dV_interpolate method chosen with QE, but command_pw not specified!' endif if ( trim ( command_pw2intw ) == 'unassigned' ) then read_status = . true . write ( * , * ) 'Error: dV_interpolate method chosen with QE, but command_pw2intw not specified!' endif if ( trim ( file_pw ) == 'unassigned' ) then read_status = . true . write ( * , * ) 'Error: dV_interpolate method chosen with QE, but file_pw not specified!' endif else if ( trim ( nscf_code ) == 'SIESTA' ) then if ( trim ( command_siesta2intw ) == 'unassigned' ) then read_status = . true . write ( * , * ) 'Error: dV_interpolate method chosen with SIESTA, but command_siesta2intw not specified!' endif if ( trim ( file_siesta2intw ) == 'unassigned' ) then read_status = . true . write ( * , * ) 'Error: dV_interpolate method chosen with SIESTA, but file_siesta2intw not specified!' endif else read_status = . true . write ( * , * ) 'Error: dV_interpolate method chosen with unknown nscf_code!' endif ! end if if ( trim ( read_for_dynmat ) /= 'dynq' & . and . trim ( read_for_dynmat ) /= 'fc' ) then read_status = . true . write ( * , * ) 'Error: Wrong value for read_for_dynmat!' end if if ( read_status ) then write ( * , * ) \"The input should be of the form:\" write ( * , * ) \"&input\" write ( * , * ) \"             outdir                = 'directory'\" write ( * , * ) \"             prefix                = 'prefix'\" write ( * , * ) \"             nk1                   = integer\" write ( * , * ) \"             nk2                   = integer\" write ( * , * ) \"             nk3                   = integer\" write ( * , * ) \"             TR_symmetry           = T or F\" write ( * , * ) \"             chemical_potential    = real\" write ( * , * ) \"             use_exclude_bands     = 'none', 'wannier' or 'custom'\" write ( * , * ) \"             include_bands_initial = integer\" write ( * , * ) \"             include_bands_final   = integer\" write ( * , * ) \"/\" write ( * , * ) \"&intw2W\" write ( * , * ) \"             intw2W_fullzone = T or F\" write ( * , * ) \"             intw2W_method   = CONVOLUTION or FFT\" write ( * , * ) \"             compute_amn     = T or F\" write ( * , * ) \"             compute_mmn     = T or F\" write ( * , * ) \"/\" write ( * , * ) \"&ph\" write ( * , * ) \"             qlist           = 'file'\" write ( * , * ) \"             read_for_dynmat = 'fc' or 'dynq' (D)\" write ( * , * ) \"             fc_mat          = 'file'\" write ( * , * ) \"             nq1             = integer\" write ( * , * ) \"             nq2             = integer\" write ( * , * ) \"             nq3             = integer\" write ( * , * ) \"             nqirr           = integer\" write ( * , * ) \"             apply_asr       = T(D) or F\" write ( * , * ) \"/\" write ( * , * ) \"&DOS\" write ( * , * ) \"             nk1_dos    = integer\" write ( * , * ) \"             nk2_dos    = integer\" write ( * , * ) \"             nk3_dos    = integer\" write ( * , * ) \"             ne_dos     = integer\" write ( * , * ) \"             eini_dos   = real\" write ( * , * ) \"             efin_dos   = real\" write ( * , * ) \"             esmear_dos = real\" write ( * , * ) \"             kTsmear    = real\" write ( * , * ) \"/\" write ( * , * ) \"&DOS_ph\" write ( * , * ) \"             nq1_dosph = integer\" write ( * , * ) \"             nq2_dosph = integer\" write ( * , * ) \"             nq3_dosph = integer\" write ( * , * ) \"             nomega    = integer\" write ( * , * ) \"             omega_ini = real\" write ( * , * ) \"             omega_fin = real\" write ( * , * ) \"             osmear_q  = real\" write ( * , * ) \"/\" write ( * , * ) \"&elphon\" write ( * , * ) \"             ep_mat_file         = 'file'\" write ( * , * ) \"             ep_bands            = 'intw' or 'custom'\" write ( * , * ) \"             ep_bands_initial    = integer\" write ( * , * ) \"             ep_bands_final      = integer\" write ( * , * ) \"             ep_interp_method    = 'wannier' or 'dV_interpolate'\" write ( * , * ) \"             ep_interp_bands     = 'intw_bands' or 'ef_crossing' \" write ( * , * ) \"             nfs_sheets_initial  = integer\" write ( * , * ) \"             nfs_sheets_final    = integer\" write ( * , * ) \"             nscf_code           = 'QE' or 'SIESTA'\" write ( * , * ) \"             command_pw          = 'string'\" write ( * , * ) \"             command_pw2intw     = 'string'\" write ( * , * ) \"             file_pw             = 'file'\" write ( * , * ) \"             command_siesta2intw = 'string'\" write ( * , * ) \"             file_siesta2intw    = 'file'\" write ( * , * ) \"/\" end if strlen = len_trim ( outdir ) if ( outdir ( strlen : strlen + 1 ) . ne . \"/\" ) outdir ( strlen + 1 : strlen + 2 ) = \"/\" return 20 format ( A ) 22 format ( A , I2 , A ) end subroutine read_input subroutine read_cards () ! Namelists have already been read from unit 5. ! Continue parsing unit until finding cards. !! This subroutine reads K_PATH and Q_PATH cards from standard input if present. !! !! IMPORTANT: some cards may be missing, but the present !! ones must be ordered as described below. !! !! ```{.txt} !! K_PATH !!     label(1) k_x(1) k_y(1) k_z(1) !!     label(2) k_x(2) k_y(2) k_z(2) !!     ... !!     label(nkspecial) k_x(nkspecial) k_y(nkspecial) k_z(nkspecial) !! Q_PATH !!     nqpath nqspecial !!     label(1) q_x(1) q_y(1) q_z(1) !!     label(2) q_x(2) q_y(2) q_z(2) !!     ... !!     label(nqspecial) q_x(nqspecial) q_y(nqspecial) q_z(nqspecial) !! ``` !! !! where `nkpath` indicate the desired total number of k-points along the path, !! and `nkspecial` specifies the number of intermediate special points, !! which are given below in crystal coordinates. !! !! MBR 03/05/2024 implicit none character ( 80 ) :: cardname character ( 1 ) :: klabel , qlabel integer :: i exist_kpath = . false . exist_qpath = . false . write ( * , 20 ) '| - Reading standard input file...                  |' write ( * , 20 ) '|   card:                                           |' ! parse until K_PATH, Q_PATH do ! read ( 5 , * , end = 100 ) cardname ! if ( trim ( cardname ) == 'K_PATH' ) then ! write ( * , 20 ) '|             K_PATH                                |' exist_kpath = . true . read ( 5 , * ) nkpath , nkspecial ! if ( nkspecial . lt . 2 ) then write ( * , 20 ) 'More than 2 k-points are needed to set up the path. Stopping.' stop end if ! allocate ( kspecial ( 3 , nkspecial )) do i = 1 , nkspecial read ( 5 , * ) klabel , kspecial (:, i ) end do ! else if ( trim ( cardname ) == 'Q_PATH' ) then ! write ( * , 20 ) '|             Q_PATH                                |' exist_qpath = . true . read ( 5 , * ) nqpath , nqspecial ! if ( nqspecial . lt . 2 ) then write ( * , 20 ) 'More than 2 q-points are needed to set up the path. Stopping.' stop end if ! allocate ( qspecial ( 3 , nqspecial )) do i = 1 , nqspecial read ( 5 , * ) qlabel , qspecial (:, i ) end do ! end if ! end do 100 write ( * , 20 ) '|   EOF reached                                     |' if ( . not . exist_kpath . and . . not . exist_qpath ) then write ( * , 20 ) '|   no cards found                                  |' end if write ( * , 20 ) '=====================================================' 20 format ( A ) end subroutine read_cards END MODULE intw_input_parameters","tags":"","url":"sourcefile/input_parameters.f90.html"},{"title":"triFS.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module triFS_input_parameters !! display: public !! !! This module contains the definitions of input parameters for [[triFS]] utility. !! !! ### Details !! !! #### Input parameters !! !! ```{.txt} !! &tri_FS !!     n1           = integer !!     n2           = integer !!     n3           = integer !!     volume_nodes = T or F (Default: T) !!     volnodfac    = real (Default: 1.0) !!     hr_file      = 'file' !!     ef           = real (Default: 0.0 eV) !!     verbose      = T or F (Default: F) !!     plot_BZ      = T or F (Default: T) !!     dos          = T or F (Default: T) !!     eps_dupv     = real (Default: 1.0E-06) !! / !! &FS_opt !!     collapse          = T or F (Default: T) !!     collapse_criteria = real (Default: 0.2) !!     relax             = T or F (Default: T) !!     relax_iter        = integer (Default: 1000) !!     newton_raphson    = 0: not applied, 1: only in the end, 2: beginning and end (Default: 2) !!     newton_iter       = integer (Default: 10) !!     relax_vinface     = T or F (Default: F) !!     eps_vinface       = real (Default: 1.0E-5) !! / !! ``` !! !! Variables without default values must be explicitly set in the input !! file; otherwise, an error will be raised. !! use kinds , only : dp implicit none public :: tri_FS , n1 , n2 , n3 , volume_nodes , volnodfac , hr_file , ef , verbose , plot_BZ , dos , eps_dupv public :: FS_opt , collapse , collapse_criteria , relax , relax_iter , newton_raphson , newton_iter , relax_vinface , eps_vinface private ! tri_FS integer :: n1 = - 1 , n2 = - 1 , n3 = - 1 !! BZ sampling for creating tetrahedra logical :: volume_nodes = . true . !! .true. if nodes are to be added inside the IBZ volume as Steiner points real ( kind = dp ) :: volnodfac = 1.0_dp !! Factor with which multiply n1, n2, n3 to add points within IBZ volume character ( len = 256 ) :: hr_file = 'unassigned' !! Wannier90 $seedname.hr file real ( kind = dp ) :: ef = 0.0_dp !! Fermi level (Units: eV) logical :: verbose = . false . !! Verbose output logical :: plot_BZ = . true . !! Plot BZ edges logical :: dos = . true . !! Compute Fermi level DOS real ( kind = dp ) :: eps_dupv = 1.0E-06_dp !! Threshold parameter to detect duplicated vertices ! FS_opt logical :: collapse = . true . !! Collapse edges of triangulated mesh real ( kind = dp ) :: collapse_criteria = 0.2_dp !! Shortest edge to longest edge ratio to proceed with collapse logical :: relax = . true . !! Tangentially relax edges of triangulated mesh integer :: relax_iter = 1000 !! Number of tangential relax iterations integer :: newton_raphson = 2 !! Newthon-Raphson relax edges of triangulated mesh: !! !! - `0`: not applied !! - `1`: applied only at the end !! - `2`: applied at beginning and end integer :: newton_iter = 10 !! Number of Newthon-Raphson relax iterations logical :: relax_vinface = . false . !! Relax vertices on faces. May give erros in some examples. real ( kind = dp ) :: eps_vinface = 1.0E-5_dp !! Threshold to detect vertices on BZ faces ! Input namelists NAMELIST / tri_FS / n1 , n2 , n3 , volume_nodes , volnodfac , hr_file , ef , verbose , plot_BZ , dos , eps_dupv NAMELIST / FS_opt / collapse , collapse_criteria , relax , relax_iter , newton_raphson , newton_iter , relax_vinface , eps_vinface end module triFS_input_parameters ! program triFS !! display: none !! !! Triangulate Fermi surface. !! !! ### Details !! !! #### Input parameters !! !! ```{.txt} !! &input !!     outdir = 'directory' !!     prefix = 'prefix' !!     TR_symmetry = T or F !! / !! &tri_FS !!     n1           = integer !!     n2           = integer !!     n3           = integer !!     volume_nodes = T or F !!     volnodfac    = real !!     hr_file      = 'file' !!     ef           = real !!     verbose      = T or F !!     plot_BZ      = T or F !!     dos          = T or F !!     eps_dupv     = real !! / !! &FS_opt !!     collapse          = T or F !!     collapse_criteria = real !!     relax             = T or F !!     relax_iter        = integer !!     newton_raphson    = 0: not applied, 1: only in the end, 2: beginning and end !!     newton_iter       = integer !!     relax_vinface     = T or F !!     eps_vinface       = real !! / !! ``` !! !! `triFS.x` utility uses special `tri_FS` and `FS_opt` namelists, !! see [[triFS_input_parameters]] module for the description of each parameter in those namelists. !! See [[intw_input_parameters]] module for the description of each parameter in the `input` namelist. !! use kinds , only : dp use triFS_input_parameters use triFS_geometry , only : wigner_seitz_cell , plot_poly , polyhedra_off , tetrasym , plot_tetra_off , compact_tetra , & tetraIBZ_2_vert_faces_edges , irr_faces , triangulate_faces , add_nodes_IBZ_volume use triFS_isosurface , only : vert_veloc_rot , vert_veloc , vert_index_rot , vert_coord_rot , ntri_rot , nvert_rot , & vert_index , vert_coord , nvert , ntri , & read_tetrahedra , create_isosurface_IBZ , write_full_isosurface , DOS_isosurface , & write_IBZ_isosurface use triFS_mesh_opt , only : mesh_optimization use intw_version , only : print_intw_version use intw_utility , only : find_free_unit , get_timing , print_threads , print_date_time use intw_input_parameters , only : input , outdir , prefix , TR_sym => TR_symmetry use intw_reading , only : read_parameters_data_file , alat , at , bg , volume0 , nsym , s , lmag implicit none ! Tetrahedra variables integer , parameter :: ntetmax = 400 integer :: n_BZ_tetra_irr , n_BZ_tetra_all , tetra_equiv ( ntetmax ), tetra_symlink ( ntetmax , 1 : 2 ) real ( kind = dp ), dimension ( 1 : 3 , 1 : 4 , ntetmax ) :: BZ_tetra_irr , BZ_tetra_all integer :: nvert_IBZ , nfaces_IBZ , nedges_IBZ , nfaces_irr real ( kind = dp ), allocatable :: vert_IBZ (:,:) integer , allocatable :: faces_IBZ_as_vert (:,:), edges_IBZ (:,:) integer , allocatable :: faces_Gsymlink (:,:,:,:,:), faces_indx (:), faces_inv_indx (:) ! Wannier and isosurface variables integer :: hr_unit , num_wann , irpt , nrpts , iwann , jwann integer , dimension (:), allocatable :: ndegen integer , dimension (:,:), allocatable :: irvec complex ( kind = dp ), dimension (:,:,:), allocatable :: ham_r integer :: i , j character ( len = 25 ) :: tag_in integer :: ios1 , ios2 , ios3 real ( dp ) :: time1 , time2 20 format ( A ) 30 format ( A , F8 . 2 , 6 X , A ) ! ! !================================================================================ ! Begining !================================================================================ ! call get_timing ( time1 ) ! write ( * , 20 ) '=====================================================' write ( * , 20 ) '|                   program triFS                   |' write ( * , 20 ) '|         ---------------------------------         |' call print_intw_version () call print_threads () call print_date_time ( \"Start of execution\" ) write ( * , 20 ) '=====================================================' ! ! !================================================================================ ! Read the necessary information from standard input file !================================================================================ ! 22 format ( A , I2 , A ) ! write ( * , 20 ) \"| - Reading standard input file...                  |\" write ( * , 20 ) \"|         namelist             ios                  |\" write ( * , 20 ) \"|         --------             ----                 |\" ! ! Read input file READ ( 5 , nml = input , iostat = ios1 ) write ( * , 22 ) \"|           &input             \" , ios1 , \"                   |\" ! READ ( 5 , nml = tri_FS , iostat = ios2 ) write ( * , 22 ) \"|           &triFS             \" , ios2 , \"                   |\" ! READ ( 5 , nml = FS_opt , iostat = ios3 ) write ( * , 22 ) \"|           &FS_opt            \" , ios3 , \"                   |\" ! ! Check input if ( ios1 /= 0 ) then write ( * , * ) \"PLEASE CHECK INPUT NAMELIST  &input  as it is not OK!\" stop else if ( ios2 /= 0 ) then write ( * , * ) \"PLEASE CHECK INPUT NAMELIST  &triFS  as it is not OK!\" stop else if ( ios3 /= 0 ) then write ( * , * ) \"PLEASE CHECK INPUT NAMELIST  &FS_opt  as it is not OK!\" stop end if ! ! Check input parameters if ( outdir == 'unassigned' ) stop 'MISSING outdir!' ! if ( prefix == 'unassigned' ) stop 'MISSING prefix!' ! if ( hr_file == 'unassigned' ) stop 'MISSING hr_file!' ! if ( n1 == - 1 . or . n2 == - 1 . or . n3 == - 1 ) stop 'MISSING n1, n2, n3!' ! if ( newton_raphson /= 0 . and . newton_raphson /= 1 . and . newton_raphson /= 2 ) stop 'INVALID newton_raphson!' ! write ( * , 20 ) \"=====================================================\" ! ! !================================================================================ ! Read the parameters from the SCF calculation !================================================================================ ! write ( * , 20 ) \"| - Reading calculation parameters...               |\" ! call read_parameters_data_file () ! ! Check TR symmetry for magnetic calculations if ( lmag . and . TR_sym ) then write ( * , * ) \"WARNING: Magnetic symmetry operations with TR not implemented.\" write ( * , * ) \"         Set TR_symmetry = .false. in input.\" stop \"Stopping...\" endif ! ! !================================================================================ ! Read _hr file !================================================================================ ! write ( * , 20 ) \"| - Reading Wannier H(R)...                         |\" ! hr_unit = find_free_unit () open ( unit = hr_unit , file = hr_file , status = \"unknown\" , action = \"read\" ) read ( unit = hr_unit , fmt =* ) read ( unit = hr_unit , fmt =* ) num_wann read ( unit = hr_unit , fmt =* ) nrpts allocate ( ndegen ( nrpts ), irvec ( 1 : 3 , nrpts ), ham_r ( num_wann , num_wann , nrpts )) read ( unit = hr_unit , fmt = '(15I5)' ) ( ndegen ( i ), i = 1 , nrpts ) do irpt = 1 , nrpts do i = 1 , num_wann do j = 1 , num_wann ! JL: This is the accuracy on output hr file of wannier90, it seems too low... read ( unit = hr_unit , fmt = '(5I5,2F12.6)' ) irvec (:, irpt ), jwann , iwann , ham_r ( j , i , irpt ) !read(unit=hr_unit, fmt='(5I5,2ES18.10)') irvec(:,irpt), jwann, iwann, ham_r(j,i,irpt) end do end do end do close ( unit = hr_unit ) ! write ( * , 20 ) \"=====================================================\" ! ! !================================================================================ ! Create BZ, tetrahedralize with symmetric tetra, and find IBZ !================================================================================ ! ! Create BZ ! write ( * , 20 ) \"| - Creating WS BZ...                               |\" ! call wigner_seitz_cell ( transpose ( bg ), verbose ) ! ! Write BZ border lines in plotting format if needed if ( plot_BZ ) call plot_poly () ! ! Write BZ in OFF format (reads polyhedra.dat) ! JL this should be improved to write directly in OFF format... call polyhedra_off () ! ! Find tetrahedra forming the irreducible BZ volume ! write ( * , 20 ) \"| - Finding IBZ...                                  |\" ! call tetrasym ( bg , nsym , s , TR_sym , ntetmax , n_BZ_tetra_all , BZ_tetra_all , n_BZ_tetra_irr , BZ_tetra_irr , tetra_equiv , tetra_symlink ) ! if ( verbose ) then ! Write tetrahedized full BZ tag_in = \"tetra_BZ.off\" call plot_tetra_off ( tag_in , n_BZ_tetra_all , BZ_tetra_all , plot_BZ ) end if ! ! Compact tetrahedra on IBZ call compact_tetra ( bg , nsym , s , TR_sym , ntetmax , n_BZ_tetra_irr , BZ_tetra_irr , n_BZ_tetra_all , BZ_tetra_all , tetra_equiv , tetra_symlink ) ! ! Write compact tetrahedralized irreducible BZ tag_in = \"IBZ.off\" call plot_tetra_off ( tag_in , n_BZ_tetra_irr , BZ_tetra_irr , . false .) ! write ( * , 20 ) \"|   ...done                                         |\" write ( * , 20 ) \"=====================================================\" ! ! !================================================================================ ! Detect irreducible faces within IBZ with S+G symmetries !================================================================================ ! write ( * , 20 ) \"| - Detecting equivalent faces of IBZ...            |\" ! allocate ( vert_IBZ ( 1 : 3 , 4 * n_BZ_tetra_irr ), faces_IBZ_as_vert ( 1 : 3 , 4 * n_BZ_tetra_irr ), edges_IBZ ( 1 : 2 , 6 * n_BZ_tetra_irr )) call tetraIBZ_2_vert_faces_edges ( n_BZ_tetra_irr , BZ_tetra_irr , verbose , nvert_IBZ , nfaces_IBZ , nedges_IBZ , vert_IBZ , faces_IBZ_as_vert , edges_IBZ ) ! allocate ( faces_Gsymlink ( 4 * n_BZ_tetra_irr , 2 , - 1 : 1 , - 1 : 1 , - 1 : 1 ), faces_indx ( 4 * n_BZ_tetra_irr ), faces_inv_indx ( 4 * n_BZ_tetra_irr )) call irr_faces ( n_BZ_tetra_irr , nsym , s , TR_sym , bg , verbose , vert_IBZ , nfaces_IBZ , faces_IBZ_as_vert , nfaces_irr , faces_Gsymlink , faces_indx , faces_inv_indx ) ! write ( * , 20 ) \"|   ...done                                         |\" write ( * , 20 ) \"=====================================================\" ! ! !================================================================================ ! Split edges and perform triangulation of irr faces !================================================================================ ! write ( * , 20 ) \"| - Triangulating faces of IBZ...                   |\" ! ! This uses Triangle executable call triangulate_faces ( n_BZ_tetra_irr , nfaces_IBZ , faces_Gsymlink , nsym , s , faces_indx , faces_inv_indx , n1 , n2 , n3 , bg , & faces_IBZ_as_vert , vert_IBZ , verbose ) ! ! Remove unnecessary files CALL EXECUTE_COMMAND_LINE ( \"rm face_split_edges.*\" ) ! write ( * , 20 ) \"|   ...done                                         |\" write ( * , 20 ) \"=====================================================\" ! ! !================================================================================ ! Add extra n1, n2, n3 nodes within IBZ volume !================================================================================ ! if ( volume_nodes ) then ! write ( * , 20 ) \"| - Adding n1, n2, n3 nodes to IBZ volume...        |\" ! call add_nodes_IBZ_volume ( n1 , n2 , n3 , volnodfac , eps_vinface , bg , n_BZ_tetra_irr , BZ_tetra_irr , verbose ) ! write ( * , 20 ) \"|   ...done                                         |\" write ( * , 20 ) \"=====================================================\" ! end if ! ! !================================================================================ ! Pass triangulated IBZ border and extra nodes to TetGen and tetrahedralize !================================================================================ ! write ( * , 20 ) \"| - Creating tetrahedra in IBZ volume...            |\" ! ! Call TetGen ! -Y  doesn't let adding points on surface ! -i uses adds extra nodes from .node file ! -v verbose output if ( verbose ) write ( * , 20 ) \"|   Running tetgen with command:                    |\" if ( volume_nodes ) then if ( verbose ) write ( * , 20 ) \"|  tetgen -Ykv -i Triangulated_IBZ.off > tetgen.out |\" CALL EXECUTE_COMMAND_LINE ( \"tetgen -Ykv -i Triangulated_IBZ.off > tetgen.out\" ) else if ( verbose ) write ( * , 20 ) \"|   tetgen -Ykv Triangulated_IBZ.off > tetgen.out   |\" CALL EXECUTE_COMMAND_LINE ( \"tetgen -Ykv Triangulated_IBZ.off\" ) end if ! ! Re-name files CALL EXECUTE_COMMAND_LINE ( \"rm Triangulated_IBZ.1.smesh\" ) CALL EXECUTE_COMMAND_LINE ( \"mv Triangulated_IBZ.1.vtk Tetrahedralized_IBZ.vtk\" ) CALL EXECUTE_COMMAND_LINE ( \"mv Triangulated_IBZ.1.node Tetrahedralized_IBZ.node\" ) CALL EXECUTE_COMMAND_LINE ( \"mv Triangulated_IBZ.1.face Tetrahedralized_IBZ.face\" ) CALL EXECUTE_COMMAND_LINE ( \"mv Triangulated_IBZ.1.ele Tetrahedralized_IBZ.ele\" ) CALL EXECUTE_COMMAND_LINE ( \"mv Triangulated_IBZ.1.edge Tetrahedralized_IBZ.edge\" ) ! write ( * , 20 ) \"|   ...done                                         |\" write ( * , 20 ) \"=====================================================\" ! ! !================================================================================ ! Read tetrahedra output and obtain isosurface !================================================================================ ! write ( * , 20 ) '| - Creating FS on IBZ...                           |' write ( * , 20 ) \"|         ---------------------------------         |\" ! ! Read small tetrahedra from output files. Output variables defined on isosurface module call read_tetrahedra () ! write ( * , 20 ) \"|         ---------------------------------         |\" ! ! Create isosurface on IBZ call create_isosurface_IBZ ( ef , num_wann , nrpts , ndegen , irvec , ham_r , alat , at , bg , nsym , s , TR_sym , verbose , eps_dupv ) ! ! Write triangulated mesh in OFF format write ( * , 20 ) \"|         ---------------------------------         |\" tag_in = \"initial_IBZ_FS_tri\" call write_IBZ_isosurface ( tag_in , num_wann , . false .) ! write ( * , 20 ) \"|         ---------------------------------         |\" write ( * , 20 ) \"|   ...done                                         |\" write ( * , 20 ) \"=====================================================\" ! ! !================================================================================ ! Mesh optimization !================================================================================ ! write ( * , 20 ) \"| - Optimizing FS...                                |\" ! if ( collapse . or . relax . or . ( newton_raphson > 0 )) then ! call mesh_optimization ( collapse , relax , newton_raphson , collapse_criteria , relax_iter , newton_iter , relax_vinface , & eps_vinface , eps_dupv , verbose , ef , nrpts , irvec , ndegen , ham_r , alat , at , bg , nsym , s , TR_sym , & num_wann , nfaces_IBZ , faces_IBZ_as_vert , vert_IBZ , ntri , nvert , vert_coord , vert_index , vert_veloc ) ! write ( * , 20 ) \"|         ---------------------------------         |\" write ( * , 20 ) '|   ...done                                         |' ! else ! write ( * , 20 ) \"|   ...nothing to do                                |\" ! endif ! write ( * , 20 ) \"=====================================================\" ! ! !================================================================================ ! Rotate isosurface to full BZ and write to file !================================================================================ ! write ( * , 20 ) \"| - Writing final triangulated FS...                |\" ! write ( * , 20 ) \"|         ---------------------------------         |\" ! ! write isosurface on IBZ tag_in = \"IBZ_FS_tri\" call write_IBZ_isosurface ( tag_in , num_wann , . true ., prefix ) ! write ( * , 20 ) \"|         ---------------------------------         |\" ! ! write isosurface on full BZ tag_in = \"FS_tri\" call write_full_isosurface ( bg , nsym , s , TR_sym , num_wann , verbose , eps_dupv , tag_in , prefix ) ! write ( * , 20 ) \"|         ---------------------------------         |\" write ( * , 20 ) \"|   ...done                                         |\" write ( * , 20 ) \"=====================================================\" ! ! !================================================================================ ! Compute DOS at isosurface !================================================================================ ! if ( dos ) then ! write ( * , 20 ) \"| - Computing DOS at FS...                          |\" ! call DOS_isosurface ( alat , alat ** 3 / volume0 , num_wann , nvert , ntri , vert_coord , vert_index , vert_veloc , nvert_rot , ntri_rot , & vert_coord_rot , vert_index_rot , vert_veloc_rot ) ! write ( * , 20 ) \"|   ...done                                         |\" write ( * , 20 ) \"=====================================================\" end if ! ! ! !================================================================================ ! Finish !================================================================================ ! call get_timing ( time2 ) ! write ( * , 20 ) '|                      ALL DONE                     |' write ( * , 30 ) '|     Total time: ' , time2 - time1 , ' seconds            |' call print_date_time ( 'End of execution  ' ) write ( * , 20 ) '=====================================================' end program triFS","tags":"","url":"sourcefile/trifs.f90.html"},{"title":"intw2W90.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! program intw2W90 !! display: none !! !! Interface for Wannier90. !! !! ### Details !! !! The purpose of this utility is to perform the same tasks as the !! program \"pw2wannier90\" which is part of the QE distribution, but !! utilizing a minimum set of (QE generated) Bloch functions, using !! symmetry. !! !! The code reads the seedname.nnkp file generated by wannier90 and !! computes and writes overlap matrices (seedname.mmn), energy !! eigenvalues (seedname.eig) and initial projections (seedname.amn). !! !! #### Input parameters !! !! ```{.txt} !! &input !!     outdir                = 'directory' !!     prefix                = 'prefix' !!     nk1                   = integer !!     nk2                   = integer !!     nk3                   = integer !!     TR_symmetry           = T or F !!     use_exclude_bands     = 'none', 'wannier' or 'custom' !!     include_bands_initial = integer !!     include_bands_final   = integer !! / !! &intw2W !!     intw2W_fullzone = T or F !!     intw2W_method   = 'CONVOLUTION' or 'FFT' !!     compute_amn     = T or F !!     compute_mmn     = T or F !! / !! ``` !! !! See [[intw_input_parameters]] module for the description of each parameter. !! #ifdef _OPENMP use omp_lib , only : omp_set_max_active_levels #endif use kinds , only : dp use intw_version , only : print_intw_version use intw_intw2wannier , only : nnkp_exclude_bands , read_nnkp_file , output_nnkp_file , nnkp_n_proj , & intw2w90_check_mesh , generate_mmn_using_allwfc , & generate_amn_using_allwfc , deallocate_nnkp use intw_symmetries , only : full_mesh , IBZ , QE_folder_nosym , QE_folder_sym , & symlink , find_size_of_irreducible_k_set , & allocate_symmetry_related_k , & find_inverse_symmetry_matrices_indices , & allocate_and_build_spin_symmetry_matrices , & set_symmetry_relations , deallocate_symmetry_related_k , & deallocate_spin_symmetry_matrices use intw_fft , only : allocate_fft , deallocate_fft , generate_nl use intw_input_parameters , only : outdir , prefix , intw2W_fullzone , intw2W_method , & nk1 , nk2 , nk3 , compute_mmn , compute_amn , & read_input use intw_reading , only : kpoints_QE , lspin , nkpoints_QE , nsym , & read_parameters_data_file , get_gvec , & read_kpoints_data_file , deallocate_reading_variables , & num_wann_intw , num_exclude_bands_intw , & set_num_bands USE intw_allwfcs , only : allocate_and_get_all_irreducible_wfc use intw_utility , only : get_timing , print_threads , print_date_time , generate_kmesh !================================================================================ ! Declare the variables !================================================================================ implicit none integer :: kmesh_nkirr , nkmesh logical :: read_status , have_nnkp character ( 256 ) :: nnkp_file real ( dp ), allocatable :: kmesh (:,:) real ( dp ) :: time1 , time2 20 format ( A ) 30 format ( A , F8 . 2 , 6 X , A ) ! ! !================================================================================ ! Beginning !================================================================================ ! call get_timing ( time1 ) ! write ( * , 20 ) '=====================================================' write ( * , 20 ) '|                  program intw2W90                 |' write ( * , 20 ) '|         ---------------------------------         |' call print_intw_version () #ifdef _OPENMP call omp_set_max_active_levels ( 1 ) ! This utility usea a single active parallel level #endif call print_threads () call print_date_time ( \"Start of execution\" ) write ( * , 20 ) '=====================================================' ! ! !================================================================================ ! Read the necessary information from standard input !================================================================================ ! call read_input ( read_status ) ! if ( read_status ) stop ! if ( trim ( intw2W_method ) == 'CONVOLUTION' ) then write ( * , 20 ) '| - intw2W_method   = CONVOLUTION                   |' else if ( trim ( intw2W_method ) == 'FFT' ) then write ( * , 20 ) '| - intw2W_method   = FFT                           |' else write ( * , 20 ) '***********************************************' write ( * , 20 ) '* UNKNOWN COMPUTATION METHOD:' write ( * , 20 ) '* Only \"CONVOLUTION\" and \"FFT\" available' write ( * , 20 ) '***********************************************' stop end if write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Check that $prefix.nnkp is present !================================================================================ ! nnkp_file = trim ( outdir ) // trim ( prefix ) // \".nnkp\" ! inquire ( file = nnkp_file , exist = have_nnkp ) ! if (. not . have_nnkp ) then write ( * , 20 ) '**********************************************************' write ( * , 20 ) '* Could not find the file ' // trim ( nnkp_file ) write ( * , 20 ) '* Did you run W90 -pp $seed to get the parameter file?   ' write ( * , 20 ) '**********************************************************' stop end if write ( * , 20 ) '| - .nnkp file found                                |' write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Read the parameters from the SCF calculation !================================================================================ ! call read_parameters_data_file () ! ! !================================================================================ ! Set the number of wave functions !================================================================================ ! call set_num_bands () ! ! !================================================================================ ! Print spin information !================================================================================ ! if ( lspin ) then write ( * , 20 ) '| - Spin-polarized calculation nspin = 2            |' else write ( * , 20 ) '| - Paramagnetic calculation nspin = 1              |' endif ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Set symmetry arrays !================================================================================ ! write ( * , 20 ) '| - Setting symmetry arrays...                      |' ! ! Compute the indices of the inverse rotation matrices call find_inverse_symmetry_matrices_indices () ! ! Set up spin_symmetry_matrices, needed to rotate wave functions and indueced potential for non-colinear calculations call allocate_and_build_spin_symmetry_matrices ( nsym ) ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Read the .nnkp file !================================================================================ ! write ( * , 20 ) '| - Reading nnkp file...                            |' ! call read_nnkp_file ( nnkp_file ) ! if ( nnkp_exclude_bands /= num_exclude_bands_intw ) then write ( * , 20 ) '**********************************************************' write ( * , 20 ) '* Mismatch in number of excluded bands                    ' write ( * , 20 ) '**********************************************************' stop else if ( nnkp_n_proj /= num_wann_intw ) then write ( * , 20 ) '**********************************************************' write ( * , 20 ) '* Mismatch in number of projections/wannier functions     ' write ( * , 20 ) '**********************************************************' stop end if ! ! just as a test; can be removed later call output_nnkp_file () ! ! !================================================================================ ! Set up the gvec array and all FFT variables !================================================================================ ! write ( * , 20 ) '| - Reading G vectors...                            |' ! call get_gvec () ! ! Allocate useful variables call allocate_fft () ! ! Generate some important indices for FFT call generate_nl () ! ! !================================================================================ ! Read the kpoints from the calculation !================================================================================ ! write ( * , 20 ) '| - Reading k-points...                             |' ! allocate ( kpoints_QE ( 3 , nkpoints_QE )) ! call read_kpoints_data_file ( kpoints_QE ) ! ! !================================================================================ ! Build the wave function's k-mesh !================================================================================ ! write ( * , 20 ) '| - Building k-mesh...                              |' ! nkmesh = nk1 * nk2 * nk3 allocate ( kmesh ( 3 , nkmesh )) call generate_kmesh ( kmesh , nk1 , nk2 , nk3 ) ! ! Find the size of the irreducible set of k-points (IBZ) call find_size_of_irreducible_k_set ( nk1 , nk2 , nk3 , kmesh_nkirr ) ! ! !================================================================================ ! Check that kmesh and nnkp_kpoints are consistent !================================================================================ ! call intw2W90_check_mesh ( nkmesh , kmesh ) ! write ( * , 20 ) '| - The mesh in the Wannier90 input.win file        |' write ( * , 20 ) '|   and the intw mesh are equal.                    |' write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Set symmetry relations between irreducible k-points and full k-mesh !================================================================================ ! ! Allocate arrays call allocate_symmetry_related_k ( nk1 , nk2 , nk3 ) ! ! Fill the symmetry arrays call set_symmetry_relations ( nk1 , nk2 , nk3 , nkpoints_QE , kpoints_QE , & QE_folder_nosym , QE_folder_sym , symlink , & full_mesh , IBZ ) ! ! !================================================================================ ! Check that the number of kpoints corresponds to either a full mesh or the IBZ !================================================================================ ! if ( full_mesh . and . IBZ ) then write ( * , 20 ) '| - The kpoints present in the QE folders           |' write ( * , 20 ) '|   are consistent with a full 1BZ and a            |' write ( * , 20 ) '|   IBZ has also been found.                        |' write ( * , 20 ) '|         ---------------------------------         |' else if ( IBZ ) then write ( * , 20 ) '| - The kpoints present in the QE folders           |' write ( * , 20 ) '|   are consistent with an IBZ.                     |' write ( * , 20 ) '|         ---------------------------------         |' else write ( * , * ) '**********************************************************' write ( * , * ) '* The kpoints present in the QE folders are not consistent' write ( * , * ) '* with the parameters of the input file!                 ' write ( * , * ) '**********************************************************' write ( * , * ) '* debug information:                                *' write ( * , * ) '*        nkpoints_QE = ' , nkpoints_QE write ( * , * ) '*        nkmesh      = ' , nkmesh write ( * , * ) '*        kmesh_nkirr = ' , kmesh_nkirr stop end if ! ! !================================================================================ ! Check that the requested calculation is possible !================================================================================ ! if ( intw2W_fullzone ) then write ( * , 20 ) '| - intw2W_fullzone = .true.                        |' if ( full_mesh ) then write ( * , 20 ) '|   all k-points are explicitely calculated         |' write ( * , 20 ) '|   no symmetry is assumed.                         |' write ( * , 20 ) '|   (This is mostly for testing)                    |' write ( * , 20 ) '|         ---------------------------------         |' else write ( * , 20 ) '**********************************************************' write ( * , 20 ) '* A full mesh is not present in the QE folders!          ' write ( * , 20 ) '* The requested calculation is impossible.               ' write ( * , 20 ) '*                   program stops.                       ' write ( * , 20 ) '**********************************************************' stop end if else write ( * , 20 ) '| - intw2W_fullzone = .false.                       |' write ( * , 20 ) '|   Symmetries will be utilized.                    |' write ( * , 20 ) '|         ---------------------------------         |' end if ! ! !================================================================================ ! Read all wave functions !================================================================================ ! write ( * , 20 ) '| - Reading wave functions...                       |' ! call allocate_and_get_all_irreducible_wfc () ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Compute the mmn file !================================================================================ ! if ( compute_mmn ) then write ( * , 20 ) '| - Computing the file prefix.mmn and               |' write ( * , 20 ) '|   writing the file prefix.eig...                  |' write ( * , 20 ) '|  (this is labor intensive and may take some time) |' write ( * , 20 ) '|         ---------------------------------         |' call generate_mmn_using_allwfc ( intw2W_fullzone , intw2W_method ) end if ! ! !================================================================================ ! Compute the amn file !================================================================================ ! if ( compute_amn ) then write ( * , 20 ) '| - Computing the file prefix.amn...                |' write ( * , 20 ) '|  (this is labor intensive and may take some time) |' write ( * , 20 ) '|         ---------------------------------         |' call generate_amn_using_allwfc ( intw2W_fullzone , intw2W_method ) end if ! ! !================================================================================ ! Clean up !================================================================================ ! call deallocate_symmetry_related_k () call deallocate_nnkp () call deallocate_fft () call deallocate_reading_variables () call deallocate_spin_symmetry_matrices () deallocate ( kpoints_QE ) deallocate ( kmesh ) ! ! !================================================================================ ! Finish !================================================================================ ! call get_timing ( time2 ) ! write ( * , 20 ) '|                      ALL DONE                     |' write ( * , 30 ) '|     Total time: ' , time2 - time1 , ' seconds            |' call print_date_time ( 'End of execution  ' ) write ( * , 20 ) '=====================================================' end program intw2W90","tags":"","url":"sourcefile/intw2w90.f90.html"},{"title":"interpolate.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! program interpolate !! display: none !! !! Interpolate electron band structure and DOS using Wannier interpolation. !! !! ### Details !! !! Uses nnkp and ham_r files to write an interpolated band structure and DOS. !! Projections on Wannier functions are also provided, so that \"fatband\" !! and PDOS plots can be made. !! !! MBR 2024 !! !! #### Input parameters !! !! ```{.txt} !! &input !!     outdir                = 'directory' !!     prefix                = 'prefix' !!     chemical_potential    = real !!     use_exclude_bands     = 'none', 'wannier' or 'custom' !!     include_bands_initial = integer !!     include_bands_final   = integer !! / !! &DOS !!     nk1_dos    = integer !!     nk2_dos    = integer !!     nk3_dos    = integer !!     ne_dos     = integer !!     eini_dos   = real !!     efin_dos   = real !!     esmear_dos = real !!     kTsmear    = real !! / !! K_PATH !!     nkpath nkspecial !!     label(1) kspecial_x(1) kspecial_y(1) kspecial_z(1) !!     label(2) kspecial_x(2) kspecial_y(2) kspecial_z(2) !!     ... !!     label(nkspecial) kspecial_x(nkspecial) kspecial_y(nkspecial) kspecial_z(nkspecial) !! ``` !! !! See [[intw_input_parameters]] module for the description of each parameter. !! #ifdef _OPENMP use omp_lib , only : omp_set_max_active_levels #endif use kinds , only : dp use intw_version , only : print_intw_version use intw_utility , only : get_timing , print_threads , print_date_time , find_free_unit , & generate_and_allocate_kpath , fermi_dirac use intw_w90_setup , only : interpolate_1k , interpolated_DOS , & allocate_and_read_ham_r use intw_input_parameters , only : outdir , prefix , read_input , & read_cards , exist_kpath , nkpath , nkspecial , kspecial , & nk1_dos , nk2_dos , nk3_dos , ne_dos , eini_dos , efin_dos , esmear_dos , ktsmear , & chemical_potential use intw_reading , only : read_parameters_data_file , set_num_bands , & num_wann_intw , & at , bg , tpiba , nspin implicit none character ( 256 ) :: bpath_file , dos_file logical :: read_status integer :: io_unit_b , io_unit_d , ik , ie , iw integer , allocatable :: kspecial_indices (:) real ( dp ) :: kpoint ( 3 ) real ( dp ) :: estep , ener , num_elec real ( dp ), allocatable :: eig_int (:), DOS (:), PDOS (:,:), weights (:) real ( dp ), allocatable :: kpath (:,:), dkpath (:) complex ( dp ), allocatable :: u_int (:,:) ! timing real ( dp ) :: time1 , time2 20 format ( A ) 30 format ( A , F8 . 2 , 6 X , A ) ! ! !================================================================================ ! Beginning !============================================================================20 ! call get_timing ( time1 ) ! write ( * , 20 ) '=====================================================' write ( * , 20 ) '|                program interpolate                |' write ( * , 20 ) '|         ---------------------------------         |' call print_intw_version () #ifdef _OPENMP call omp_set_max_active_levels ( 1 ) ! This utility usea a single active parallel level #endif call print_threads () call print_date_time ( \"Start of execution\" ) write ( * , 20 ) '=====================================================' ! ! !================================================================================ ! Read the input file !================================================================================ ! call read_input ( read_status ) ! if ( read_status ) stop ! ! K_PATH call read_cards () if (. not . exist_kpath ) then write ( * , * ) 'K_PATH not found. Bands/DOS cannot be interpolated. Stopping.' stop end if ! ! !================================================================================ ! Read the parameters from the SCF calculation !================================================================================ ! write ( * , 20 ) '| - Reading calculation parameters...               |' ! ! From this, I only need seednames, actually, ! until intw.in is modified to include postprocessing options call read_parameters_data_file () ! ! !================================================================================ ! Set the number of bands for the calculation !================================================================================ ! ! this will read num_wann_intw and num_bands_intw dimensions from .nnkp if available call set_num_bands () ! ! !================================================================================ ! Read u_mesh, ham_r file from w902intw !================================================================================ ! write ( * , 20 ) '| - Reading Wannier U matrix and H(R)...            |' ! call allocate_and_read_ham_r () ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Build kpoint path to plot bands. ! The nkpath number of points from the input might fluctuate. ! Use kspecial_indices option to print out the special k-points ! along the path (useful for plotting). !================================================================================ ! write ( * , 20 ) '| - Building k-path...                              |' ! call generate_and_allocate_kpath ( at , bg , tpiba , nkpath , nkspecial , kspecial , & kpath , dkpath , kspecial_indices ) ! ! write(*,*) nkpath ! do ik=1,nkpath !   write(*,'(3f12.6)') kpath(:,ik) ! end do ! ! !================================================================================ ! Interpolate bands over path !================================================================================ ! write ( * , 20 ) '| - Interpolating bands...                          |' ! allocate ( eig_int ( num_wann_intw )) allocate ( weights ( num_wann_intw )) allocate ( u_int ( num_wann_intw , num_wann_intw )) ! io_unit_b = find_free_unit () bpath_file = trim ( outdir ) // trim ( prefix ) // trim ( '.bnd_int' ) open ( unit = io_unit_b , file = bpath_file , status = 'unknown' ) write ( io_unit_b , '(A)' ) '# k-in-path    energy(eV)      weight(1:num_wann_intw)' ! do iw = 1 , num_wann_intw do ik = 1 , nkpath kpoint = kpath (:, ik ) call interpolate_1k ( kpoint , eig_int , u_int ) weights = ( abs ( u_int ( iw ,:))) ** 2 write ( io_unit_b , '(40e14.6)' ) dkpath ( ik ), eig_int ( iw ), weights end do write ( io_unit_b , * ) end do ! ! Write special point indices write ( io_unit_b , * ) '#' write ( io_unit_b , * ) '#Special k-points in the .bnd_int file are:' do ik = 1 , nkspecial write ( io_unit_b , '(a,3f10.4,a,i4,e14.6)' ) '#' , kspecial (:, ik ), ' --> ' , kspecial_indices ( ik ), dkpath ( kspecial_indices ( ik )) end do write ( io_unit_b , * ) '#' ! close ( io_unit_b ) ! write ( * , 20 ) '|   Band interpolation finished and written to:     |' write ( * , 20 ) \"|   \" // bpath_file ( 1 : max ( 47 , len ( trim ( bpath_file )))) // \" |\" ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! DOS over a fine grid ! Parameters of DOS plot from namelist /DOS/ !================================================================================ ! write ( * , 20 ) '| - Computing DOS...                                |' ! allocate ( DOS ( ne_dos ), PDOS ( ne_dos , num_wann_intw )) ! io_unit_d = find_free_unit () dos_file = trim ( outdir ) // trim ( prefix ) // trim ( '.dos_int' ) open ( unit = io_unit_d , file = dos_file , status = 'unknown' ) write ( io_unit_d , '(A)' ) '# E-E_Fermi(eV)      DOS          PDOS(1:num_wann_intw)' ! call interpolated_DOS ( nk1_dos , nk2_dos , nk3_dos , eini_dos , efin_dos , esmear_dos , ne_dos , DOS , PDOS ) ! estep = ( efin_dos - eini_dos ) / real ( ne_dos - 1 , dp ) num_elec = 0.0_dp do ie = 1 , ne_dos ener = eini_dos + ( ie - 1 ) * estep write ( io_unit_d , '(40e14.6)' ) ener - chemical_potential , DOS ( ie ), PDOS ( ie , 1 : num_wann_intw ) num_elec = num_elec + DOS ( ie ) * fermi_dirac ( ener - chemical_potential , ktsmear ) end do num_elec = num_elec * estep if ( nspin . eq . 1 ) num_elec = num_elec * 2.0_dp ! close ( io_unit_d ) ! write ( * , 20 ) '| - DOS sum test:                                   |' write ( * , '(A37,F10.6,5X,A1)' ) '|   DOS integral up to Fermi level = ' , num_elec , '|' ! write ( * , 20 ) '|   DOS computed and written to:                    |' write ( * , 20 ) '|   ' // dos_file ( 1 : max ( 47 , len ( trim ( dos_file )))) // ' |' ! write ( * , 20 ) '=====================================================' ! ! !================================================================================ ! Finish !================================================================================ ! call get_timing ( time2 ) ! write ( * , 20 ) '|                      ALL DONE                     |' write ( * , 30 ) '|     Total time: ' , time2 - time1 , ' seconds            |' call print_date_time ( 'End of execution  ' ) write ( * , 20 ) '=====================================================' end program interpolate","tags":"","url":"sourcefile/interpolate.f90.html"},{"title":"useful_constants.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_useful_constants !! display: none !! !! This module defines useful constants including mathematical values, !! physical constants, conversion factors, and Pauli matrices. !! use kinds , only : dp ! implicit none ! ! I/O variables public :: stdout , stdin ! ! Useful numbers public :: ZERO , ONE , TWO , sqrt2 , pi , tpi , fpi , sqrt_pi , & eps_2 , eps_5 , eps_6 , eps_7 , eps_8 , eps_10 , eps_14 , & cmplx_i , cmplx_1 , cmplx_0 ! ! Physical constants public :: bohr , boltzmann ! ! Energy conversion factors public :: eV_to_Ha , eV_to_Ry , Ha_to_eV , Ha_to_Ry , Ry_to_eV , Ry_to_Ha ! ! Mass conversion factors public :: pmass ! ! Pauli matrices public :: I2 , sig_x , sig_y , sig_z ! private ! save ! ! ! I/O variables integer , parameter :: stdout = 6 ! standard output unit integer , parameter :: stdin = 5 ! standard input unit ! ! Useful numbers real ( kind = dp ), parameter :: ZERO = 0.0_dp real ( kind = dp ), parameter :: ONE = 1.0_dp real ( kind = dp ), parameter :: TWO = 2.0_dp real ( kind = dp ), parameter :: sqrt2 = sqrt ( 2.0_dp ) real ( kind = dp ), parameter :: pi = dacos ( - 1.0_dp ) real ( kind = dp ), parameter :: tpi = 2.0_dp * pi real ( kind = dp ), parameter :: fpi = 4.0_dp * pi real ( kind = dp ), parameter :: sqrt_pi = sqrt ( pi ) real ( kind = dp ), parameter :: eps_2 = 1.0e-2_dp real ( kind = dp ), parameter :: eps_5 = 1.0e-5_dp real ( kind = dp ), parameter :: eps_6 = 1.0e-6_dp real ( kind = dp ), parameter :: eps_7 = 1.0e-7_dp real ( kind = dp ), parameter :: eps_8 = 1.0e-8_dp real ( kind = dp ), parameter :: eps_10 = 1.0e-10_dp real ( kind = dp ), parameter :: eps_14 = 1.0e-14_dp complex ( kind = dp ), parameter :: cmplx_i = ( 0.0_dp , 1.0_dp ) complex ( kind = dp ), parameter :: cmplx_1 = ( 1.0_dp , 0.0_dp ) complex ( kind = dp ), parameter :: cmplx_0 = ( 0.0_dp , 0.0_dp ) ! ! Physical constants real ( kind = dp ), parameter :: bohr = 0.52917720859_dp real ( kind = dp ), parameter :: boltzmann = 8.6173324 * 0.00001_dp ! ! Energy conversion factors real ( kind = dp ), parameter :: Ha_to_eV = 2 7.211383860484776_dp real ( kind = dp ), parameter :: eV_to_Ha = 1.0_dp / Ha_to_eV real ( kind = dp ), parameter :: Ha_to_Ry = 2.0_dp real ( kind = dp ), parameter :: Ry_to_Ha = 1.0_dp / Ha_to_Ry real ( kind = dp ), parameter :: Ry_to_eV = Ry_to_Ha * Ha_to_eV real ( kind = dp ), parameter :: eV_to_Ry = 1.0_dp / Ry_to_eV ! ! Mass conversion factors real ( kind = dp ), parameter :: pmass = 182 2.88848426_dp ! 1 Dalton in atomic units ! ! Pauli matrices complex ( kind = dp ), dimension ( 2 , 2 ), parameter :: I2 = transpose ( reshape (( / cmplx_1 , cmplx_0 , & cmplx_0 , cmplx_1 / ), ( / 2 , 2 / ))) complex ( kind = dp ), dimension ( 2 , 2 ), parameter :: sig_x = transpose ( reshape (( / cmplx_0 , cmplx_1 , & cmplx_1 , cmplx_0 / ), ( / 2 , 2 / ))) complex ( kind = dp ), dimension ( 2 , 2 ), parameter :: sig_y = transpose ( reshape (( / cmplx_0 , - cmplx_i , & cmplx_i , cmplx_0 / ), ( / 2 , 2 / ))) complex ( kind = dp ), dimension ( 2 , 2 ), parameter :: sig_z = transpose ( reshape (( / cmplx_1 , cmplx_0 , & cmplx_0 , - cmplx_1 / ), ( / 2 , 2 / ))) end module intw_useful_constants","tags":"","url":"sourcefile/useful_constants.f90.html"},{"title":"version.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_version !! display: none !! !! This module handles the version information of INTW. !! ! subroutines public :: print_intw_version #ifdef VERSION_STRING character ( 25 ), parameter , private :: version = VERSION_STRING ! VERSION_STRING is passed as a pre-processing variable. ! This variable will be set by CMake from the version number specified in ! cmake project() (for example, v1.0.0), or, if possible, using 'git describe' ! (for example, v1.0.0-502-gff5fbda: commit ff5fbda, 502 commits ahead from parent tag v0.0.0). #endif contains subroutine print_intw_version () implicit none #ifdef VERSION_STRING write ( * , '(\"|     INTW version: \",A25,\"       |\")' ) version #else write ( * , '(\"|     INTW version: \",A25,\"       |\")' ) \"Unknown\" #endif end subroutine print_intw_version end module intw_version","tags":"","url":"sourcefile/version.f90.html"},{"title":"isosurface.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module triFS_isosurface !! display: none !! !! This module contains all the variables and subroutines for reading !! Wannier hamiltonian and creating symmetric isosurface for [[triFS]] utility. !! use kinds , only : dp implicit none ! Variables to be read from Tetrahedralization integer , public :: nnode , ntetra , nibz_nodes , nibz_faces ! Total number of tetrahedral nodes and faces (both small and big) real ( dp ), allocatable , public :: ncoord (:,:) ! Coordinates of small tetrahedra nodes integer , allocatable , public :: index_tetra (:,:) ! Indices of small tetrahedra real ( dp ), allocatable , public :: vibz_nodes (:,:) ! Coordinates of big tetrahedra nodes integer , allocatable , public :: ibz_faces (:,:) ! face indices of big tetrahedra real ( dp ), allocatable , public :: vec_face (:,:,:) ! edge vectors of big tetrahedra ! Variables of isosurface on IBZ integer , public :: nbnd integer , allocatable , public :: nvert (:), ntri (:) ! Output triangles and vertices of isosurface on IBZ real ( dp ), allocatable , public :: vert_coord (:,:,:) ! Output triangle vertex coordinates real ( dp ), allocatable , public :: vert_veloc (:,:,:) ! Electron velocity at vertex integer , allocatable , public :: vert_index (:,:,:) ! Indices of vertices on output triangles ! Variables of full rotated isosurface integer , allocatable , public :: nvert_rot (:), ntri_rot (:) real ( dp ), allocatable , public :: vert_coord_rot (:,:,:) real ( dp ), allocatable , public :: vert_veloc_rot (:,:,:) integer , allocatable , public :: vert_index_rot (:,:,:) public :: read_tetrahedra , preserve_orientation , tetra_cut , calculate_energy_sym , calculate_energy , velocity_sym , & velocity , calculate_star_TR , tetranodes_by_SplusG , create_isosurface_IBZ , velocity_on_IBZ , & rotate_IBZ_mesh , write_full_isosurface , write_IBZ_isosurface , DOS_isosurface , vertices_area , & set_isosurface private contains subroutine read_tetrahedra () use intw_utility , only : find_free_unit implicit none integer :: inode , itetra , dmns , dummy1 , dummy2 integer :: io_unit , i , j write ( * , '(\"| - Reading tetrahedra...                           |\")' ) io_unit = find_free_unit () open ( unit = io_unit , action = \"read\" , file = \"Tetrahedralized_IBZ.node\" , status = \"unknown\" ) read ( unit = io_unit , fmt =* ) nnode , dmns , dummy1 , dummy2 allocate ( ncoord ( 3 , nnode )) do i = 1 , nnode read ( unit = io_unit , fmt =* ) inode , ( ncoord ( j , i ), j = 1 , 3 ) end do close ( unit = io_unit ) io_unit = find_free_unit () open ( unit = io_unit , action = \"read\" , file = \"Tetrahedralized_IBZ.ele\" , status = \"unknown\" ) read ( unit = io_unit , fmt =* ) ntetra , dummy1 , dummy2 allocate ( index_tetra ( 4 , ntetra )) do i = 1 , ntetra read ( unit = io_unit , fmt =* ) itetra , ( index_tetra ( j , i ), j = 1 , 4 ) end do close ( unit = io_unit ) !! JL - optional for plotting !! Write Tetrahedrized IBZ in off format io_unit = find_free_unit () open ( unit = io_unit , action = \"write\" , file = \"Tetrahedralized_IBZ.off\" , status = \"unknown\" ) write ( unit = io_unit , fmt = \"(a)\" ) \"OFF\" write ( unit = io_unit , fmt = \"(3I6)\" ) nnode , 4 * ntetra , 0 write ( unit = io_unit , fmt =* ) ! Vertices of tetrahedra do i = 1 , nnode write ( unit = io_unit , fmt = \"(3f12.6)\" ) ( ncoord ( j , i ), j = 1 , 3 ) end do ! Triangular faces of tetrahedra do i = 1 , ntetra write ( unit = io_unit , fmt = \"(4I6)\" ) 3 , index_tetra ( 1 , i ), index_tetra ( 3 , i ), index_tetra ( 2 , i ) write ( unit = io_unit , fmt = \"(4I6)\" ) 3 , index_tetra ( 1 , i ), index_tetra ( 4 , i ), index_tetra ( 2 , i ) write ( unit = io_unit , fmt = \"(4I6)\" ) 3 , index_tetra ( 1 , i ), index_tetra ( 3 , i ), index_tetra ( 4 , i ) write ( unit = io_unit , fmt = \"(4I6)\" ) 3 , index_tetra ( 2 , i ), index_tetra ( 3 , i ), index_tetra ( 4 , i ) end do close ( unit = io_unit ) !! JL - optional for plotting io_unit = find_free_unit () open ( unit = io_unit , file = \"IBZ.off\" , action = \"read\" , status = \"unknown\" ) ! Read number of irreducible tetrahedra faces read ( unit = io_unit , fmt =* ) read ( unit = io_unit , fmt = '(3I6)' ) nibz_nodes , nibz_faces , dummy1 read ( unit = io_unit , fmt =* ) ! Read vectors defining the face and compute normal (the normal will be the third vector of the face) allocate ( vibz_nodes ( 3 , nibz_nodes ), ibz_faces ( 3 , nibz_faces )) do i = 1 , nibz_nodes read ( unit = io_unit , fmt = '(3f12.6)' ) ( vibz_nodes ( j , i ), j = 1 , 3 ) end do do i = 1 , nibz_faces read ( unit = io_unit , fmt = '(4I6)' ) dummy1 , ( ibz_faces ( j , i ), j = 1 , 3 ) end do allocate ( vec_face ( 3 , 3 , nibz_faces )) do i = 1 , nibz_faces vec_face ( 1 : 3 , 1 , i ) = vibz_nodes ( 1 : 3 , ibz_faces ( 2 , i ) + 1 ) - vibz_nodes ( 1 : 3 , ibz_faces ( 1 , i ) + 1 ) vec_face ( 1 : 3 , 2 , i ) = vibz_nodes ( 1 : 3 , ibz_faces ( 3 , i ) + 1 ) - vibz_nodes ( 1 : 3 , ibz_faces ( 1 , i ) + 1 ) vec_face ( 1 : 3 , 3 , i ) = vibz_nodes ( 1 : 3 , ibz_faces ( 1 , i ) + 1 ) end do deallocate ( vibz_nodes ) close ( unit = io_unit ) end subroutine read_tetrahedra subroutine preserve_orientation ( triangle , v ) !ensures trangle being in the same orientation as v use intw_matrix_vector , only : cross implicit none real ( dp ), intent ( inout ) :: triangle ( 3 , 3 ), v ( 3 ) real ( dp ) :: tv ( 3 , 3 ) tv = triangle if ( dot_product ( cross ( tv (:, 3 ) - tv (:, 1 ), tv ( 2 ,:) - tv (:, 1 )), v ) > 0.0_dp ) then triangle ( 1 : 3 , 1 ) = tv (:, 1 ) triangle ( 1 : 3 , 2 ) = tv (:, 2 ) triangle ( 1 : 3 , 3 ) = tv (:, 3 ) else triangle ( 1 : 3 , 1 ) = tv (:, 1 ) triangle ( 1 : 3 , 2 ) = tv (:, 3 ) triangle ( 1 : 3 , 3 ) = tv (:, 2 ) end if end subroutine preserve_orientation subroutine tetra_cut ( ef , t , e_ , nt , vt ) use intw_utility , only : hpsort_real use intw_matrix_vector , only : norma , cross implicit none real ( dp ), intent ( in ) :: ef , t ( 3 , 4 ), e_ ( 4 ) integer , intent ( out ) :: nt real ( dp ), intent ( out ) :: vt ( 3 , 3 , 2 ) !local real ( dp ) :: e ( 4 ), tv1 ( 3 ), tv2 ( 3 ), tv3 ( 3 ), tv4 ( 3 ), area1 , area2 , area3 , area4 integer :: ind ( 4 ), i integer , parameter :: n = 4 real ( dp ) :: vt_ ( 3 , 3 , 2 ), increasing_e ( 3 ) nt = 1 vt = - 10 0.0 e = e_ call hpsort_real ( n , e , ind ) increasing_e ( 1 : 3 ) = t ( 1 : 3 , ind ( 4 )) - t ( 1 : 3 , ind ( 1 )) if (( ef < e ( 1 )). or .( ef > e ( 4 ))) then nt = 0 return else if (( ef > e ( 1 )). and .( ef < e ( 2 ))) then nt = 1 vt ( 1 : 3 , 1 , 1 ) = t ( 1 : 3 , ind ( 1 )) + ( ef - e ( 1 )) / ( e ( 2 ) - e ( 1 )) * ( t ( 1 : 3 , ind ( 2 )) - ( t ( 1 : 3 , ind ( 1 )))) vt ( 1 : 3 , 2 , 1 ) = t ( 1 : 3 , ind ( 1 )) + ( ef - e ( 1 )) / ( e ( 3 ) - e ( 1 )) * ( t ( 1 : 3 , ind ( 3 )) - ( t ( 1 : 3 , ind ( 1 )))) vt ( 1 : 3 , 3 , 1 ) = t ( 1 : 3 , ind ( 1 )) + ( ef - e ( 1 )) / ( e ( 4 ) - e ( 1 )) * ( t ( 1 : 3 , ind ( 4 )) - ( t ( 1 : 3 , ind ( 1 )))) else if (( ef > e ( 1 )). and .( ef > e ( 2 )). and .( ef < e ( 3 ))) then nt = 2 tv1 ( 1 : 3 ) = t ( 1 : 3 , ind ( 1 )) + ( ef - e ( 1 )) / ( e ( 3 ) - e ( 1 )) * ( t ( 1 : 3 , ind ( 3 )) - ( t ( 1 : 3 , ind ( 1 )))) tv2 ( 1 : 3 ) = t ( 1 : 3 , ind ( 1 )) + ( ef - e ( 1 )) / ( e ( 4 ) - e ( 1 )) * ( t ( 1 : 3 , ind ( 4 )) - ( t ( 1 : 3 , ind ( 1 )))) tv3 ( 1 : 3 ) = t ( 1 : 3 , ind ( 2 )) + ( ef - e ( 2 )) / ( e ( 4 ) - e ( 2 )) * ( t ( 1 : 3 , ind ( 4 )) - ( t ( 1 : 3 , ind ( 2 )))) tv4 ( 1 : 3 ) = t ( 1 : 3 , ind ( 2 )) + ( ef - e ( 2 )) / ( e ( 3 ) - e ( 2 )) * ( t ( 1 : 3 , ind ( 3 )) - ( t ( 1 : 3 , ind ( 2 )))) area1 = norma ( cross ( tv2 ( 1 : 3 ) - tv1 ( 1 : 3 ), tv3 ( 1 : 3 ) - tv1 ( 1 : 3 ))) area2 = norma ( cross ( tv3 ( 1 : 3 ) - tv1 ( 1 : 3 ), tv4 ( 1 : 3 ) - tv1 ( 1 : 3 ))) area3 = norma ( cross ( tv2 ( 1 : 3 ) - tv4 ( 1 : 3 ), tv1 ( 1 : 3 ) - tv4 ( 1 : 3 ))) area4 = norma ( cross ( tv2 ( 1 : 3 ) - tv4 ( 1 : 3 ), tv3 ( 1 : 3 ) - tv4 ( 1 : 3 ))) if ( abs ( area1 - area2 ) <= abs ( area3 - area4 )) then vt ( 1 : 3 , 1 , 1 ) = tv1 ( 1 : 3 ) vt ( 1 : 3 , 2 , 1 ) = tv3 ( 1 : 3 ) vt ( 1 : 3 , 3 , 1 ) = tv2 ( 1 : 3 ) vt ( 1 : 3 , 1 , 2 ) = tv1 ( 1 : 3 ) vt ( 1 : 3 , 2 , 2 ) = tv4 ( 1 : 3 ) vt ( 1 : 3 , 3 , 2 ) = tv3 ( 1 : 3 ) else vt ( 1 : 3 , 1 , 1 ) = tv1 ( 1 : 3 ) vt ( 1 : 3 , 2 , 1 ) = tv4 ( 1 : 3 ) vt ( 1 : 3 , 3 , 1 ) = tv2 ( 1 : 3 ) vt ( 1 : 3 , 1 , 2 ) = tv4 ( 1 : 3 ) vt ( 1 : 3 , 2 , 2 ) = tv3 ( 1 : 3 ) vt ( 1 : 3 , 3 , 2 ) = tv2 ( 1 : 3 ) endif else if (( ef > e ( 1 )). and .( ef > e ( 2 )). and .( ef > e ( 3 )). and .( ef < e ( 4 ))) then nt = 1 vt ( 1 : 3 , 1 , 1 ) = t ( 1 : 3 , ind ( 4 )) + ( ef - e ( 4 )) / ( e ( 2 ) - e ( 4 )) * ( t ( 1 : 3 , ind ( 2 )) - ( t ( 1 : 3 , ind ( 4 )))) vt ( 1 : 3 , 2 , 1 ) = t ( 1 : 3 , ind ( 4 )) + ( ef - e ( 4 )) / ( e ( 3 ) - e ( 4 )) * ( t ( 1 : 3 , ind ( 3 )) - ( t ( 1 : 3 , ind ( 4 )))) vt ( 1 : 3 , 3 , 1 ) = t ( 1 : 3 , ind ( 4 )) + ( ef - e ( 4 )) / ( e ( 1 ) - e ( 4 )) * ( t ( 1 : 3 , ind ( 1 )) - ( t ( 1 : 3 , ind ( 4 )))) else write ( * , * ) \"error in tetra_cut. Case not treated:\" , ef , e end if vt_ = vt do i = 1 , nt ! here we order the vertives accoring to the orientation. ! if nt = 0 nothing is done below call preserve_orientation ( vt (:,:, i ), increasing_e ) enddo end subroutine tetra_cut subroutine calculate_energy_sym ( nsym , s , TR_sym , n_bnd , nrpts , ndegen , irvec , ham_r , kvec_int , eig_mean ) implicit none integer , intent ( in ) :: nsym , n_bnd , nrpts , ndegen ( nrpts ), irvec ( 3 , nrpts ) integer , intent ( in ) :: s ( 3 , 3 , nsym ) logical , intent ( in ) :: TR_sym complex ( dp ), intent ( in ) :: ham_r ( n_bnd , n_bnd , nrpts ) real ( dp ), intent ( in ) :: kvec_int ( 3 ) real ( dp ), intent ( out ) :: eig_mean ( n_bnd ) real ( dp ) :: eig_int ( n_bnd ) integer :: istar , nstar , symop ( 96 , 2 ) real ( dp ) :: vstar ( 3 , 96 ) call calculate_star_TR ( nsym , s , TR_sym , mod ( kvec_int (:), 1.0_dp ), vstar , nstar , symop ) eig_mean = 0.0_dp do istar = 1 , nstar call calculate_energy ( n_bnd , nrpts , ndegen , irvec , ham_r , vstar ( 1 : 3 , istar ), eig_int ) eig_mean = eig_mean + eig_int enddo eig_mean = eig_mean / nstar end subroutine calculate_energy_sym subroutine calculate_energy ( n_bnd , nrpts , ndegen , irvec , ham_r , kvec_int , eig_int ) use intw_useful_constants , only : tpi , cmplx_i , cmplx_0 implicit none external :: ZHPEVX integer , intent ( in ) :: n_bnd , nrpts , ndegen ( nrpts ), irvec ( 3 , nrpts ) complex ( dp ), intent ( in ) :: ham_r ( n_bnd , n_bnd , nrpts ) real ( dp ), intent ( in ) :: kvec_int ( 3 ) real ( dp ), intent ( out ) :: eig_int ( n_bnd ) complex ( dp ) :: ham_kprm ( n_bnd , n_bnd ), u_dagger ( n_bnd , n_bnd ), ham_pack ( n_bnd * ( n_bnd + 1 ) / 2 ), fac real ( dp ) :: rdotk integer :: loop_rpt , nfound complex ( dp ) :: cwork ( 2 * n_bnd ) real ( dp ) :: rwork ( 7 * n_bnd ) integer :: iwork ( 5 * n_bnd ), ifail ( n_bnd ), info integer :: i , j ham_kprm = cmplx_0 do loop_rpt = 1 , nrpts rdotk = tpi * dot_product ( kvec_int , irvec (:, loop_rpt )) fac = exp ( cmplx_i * rdotk ) / real ( ndegen ( loop_rpt ), dp ) ham_kprm = ham_kprm + fac * ham_r (:,:, loop_rpt ) end do ! Diagonalise H_k (->basis of eigenstates) do j = 1 , n_bnd do i = 1 , j ham_pack ( i + (( j - 1 ) * j ) / 2 ) = ham_kprm ( i , j ) enddo enddo ! Diagonalizing routine from lapack. call ZHPEVX ( 'V' , 'A' , 'U' , n_bnd , ham_pack , & 0.0_dp , 0.0_dp , 0 , 0 , - 1.0_dp , & nfound , eig_int , & u_dagger , & n_bnd , cwork , rwork , iwork , ifail , info ) end subroutine calculate_energy subroutine velocity_sym ( nrpts , irvec , ndegen , alat , ag , bg , nsym , s , TR_sym , n_bnd , ibnd , ham_r , v_mean , kvec_int ) use intw_matrix_vector , only : ainv implicit none integer , intent ( in ) :: nrpts , irvec ( 3 , nrpts ), ndegen ( nrpts ) real ( dp ), intent ( in ) :: alat , ag ( 3 , 3 ), bg ( 3 , 3 ) integer , intent ( in ) :: nsym , s ( 3 , 3 , nsym ) logical , intent ( in ) :: TR_sym integer , intent ( in ) :: n_bnd , ibnd complex ( dp ), intent ( in ) :: ham_r ( n_bnd , n_bnd , nrpts ) real ( dp ), intent ( in ) :: kvec_int ( 3 ) real ( dp ), intent ( out ) :: v_mean ( 3 ) real ( dp ), parameter :: evau = 2 7.21138602_dp ! evau = 27.2113845 integer :: istar , nstar , symmop ( 96 , 2 ) ! symmop(48) real ( dp ) :: v ( 3 ), so ( 3 , 3 ), kstar ( 3 , 96 ) ! kstar(3,48) !call calculate_star_r (mod(kvec_int(:), 1.0_dp), kstar, nstar, symmop) call calculate_star_TR ( nsym , s , TR_sym , mod ( kvec_int (:), 1.0_dp ), kstar , nstar , symmop ) v_mean = 0.d0 do istar = 1 , nstar call velocity ( nrpts , irvec , ndegen , alat , ag , bg , n_bnd , ibnd , ham_r , v , kstar (:, istar )) !v = matmul(transpose(at), v) !v = matmul(ainv(bg), v) !v = matmul(ag, v) v = matmul ( transpose ( ag ), v ) if ( symmop ( istar , 1 ). gt . 0 ) then so = real ( s (:,:, symmop ( istar , 1 )), dp ) v = matmul ( ainv ( so ), v ) else so = real ( s (:,:, symmop ( istar , 2 )), dp ) v = - matmul ( ainv ( so ), v ) end if v = matmul ( bg , v ) v_mean = v_mean + v enddo v_mean = v_mean / nstar end subroutine velocity_sym subroutine velocity ( nrpts , irvec , ndegen , alat , ag , bg , n_bnd , ibnd , ham_r , v , k ) use intw_useful_constants , only : tpi , cmplx_i , cmplx_0 use intw_matrix_vector , only : ainv implicit none external :: ZHPEVX integer , intent ( in ) :: n_bnd , ibnd , nrpts , irvec ( 3 , nrpts ), ndegen ( nrpts ) real ( dp ), intent ( in ) :: alat , ag ( 3 , 3 ), bg ( 3 , 3 ) complex ( dp ), intent ( in ) :: ham_r ( n_bnd , n_bnd , nrpts ) real ( dp ), intent ( in ) :: k ( 3 ) real ( dp ), intent ( out ) :: v ( 3 ) real ( dp ) :: eig ( n_bnd ) integer :: i , j , loop_rpt , nfound complex ( dp ) :: ham_kprm_x ( n_bnd , n_bnd ), ham_kprm_y ( n_bnd , n_bnd ), & ham_kprm_z ( n_bnd , n_bnd ), ham_kprm ( n_bnd , n_bnd ), fac complex ( dp ) :: u_dagger ( n_bnd , n_bnd ), ham_pack ( n_bnd * ( n_bnd + 1 ) / 2 ) real ( dp ) :: rdotk , rcart ( 3 ), kcart ( 3 ) complex ( dp ) :: cwork ( 2 * n_bnd ) real ( dp ) :: rwork ( 7 * n_bnd ) integer :: iwork ( 5 * n_bnd ), ifail ( n_bnd ), info real ( dp ), parameter :: evau = 2 7.21138602_dp ! evau = 27.2113845_dp ham_kprm_x = cmplx_0 ham_kprm_y = cmplx_0 ham_kprm_z = cmplx_0 ham_kprm = cmplx_0 do loop_rpt = 1 , nrpts rdotk = tpi * dot_product ( k , irvec (:, loop_rpt )) !rcart(:) = matmul(transpose(ag), irvec(:,loop_rpt)) !rcart(:) = matmul(ainv(bg), irvec(:,loop_rpt)) rcart (:) = matmul ( ag , irvec (:, loop_rpt )) kcart (:) = matmul ( bg , k ) fac = exp ( cmplx_i * rdotk ) / real ( ndegen ( loop_rpt ), dp ) ham_kprm = ham_kprm + fac * ham_r (:,:, loop_rpt ) fac = cmplx_i * rcart ( 1 ) * exp ( cmplx_i * rdotk ) / real ( ndegen ( loop_rpt ), dp ) ham_kprm_x = ham_kprm_x + fac * ham_r (:,:, loop_rpt ) fac = cmplx_i * rcart ( 2 ) * exp ( cmplx_i * rdotk ) / real ( ndegen ( loop_rpt ), dp ) ham_kprm_y = ham_kprm_y + fac * ham_r (:,:, loop_rpt ) fac = cmplx_i * rcart ( 3 ) * exp ( cmplx_i * rdotk ) / real ( ndegen ( loop_rpt ), dp ) ham_kprm_z = ham_kprm_z + fac * ham_r (:,:, loop_rpt ) end do do j = 1 , n_bnd do i = 1 , j ham_pack ( i + (( j - 1 ) * j ) / 2 ) = ham_kprm ( i , j ) enddo enddo call ZHPEVX ( 'V' , 'A' , 'U' , n_bnd , ham_pack , & 0.0_dp , 0.0_dp , 0 , 0 , - 1.0_dp , & nfound , eig , & u_dagger , & n_bnd , cwork , rwork , iwork , ifail , info ) v = 0.0 do i = 1 , n_bnd do j = 1 , n_bnd v ( 1 ) = v ( 1 ) + real ( conjg ( u_dagger ( i , ibnd ) ) * ham_kprm_x ( i , j ) * ( u_dagger ( j , ibnd ))) v ( 2 ) = v ( 2 ) + real ( conjg ( u_dagger ( i , ibnd ) ) * ham_kprm_y ( i , j ) * ( u_dagger ( j , ibnd ))) v ( 3 ) = v ( 3 ) + real ( conjg ( u_dagger ( i , ibnd ) ) * ham_kprm_z ( i , j ) * ( u_dagger ( j , ibnd ))) enddo enddo v = v * alat / evau end subroutine velocity subroutine calculate_star_TR ( nsym , s , TR_symmetry , v , vstar , nstar , symop ) implicit none integer , intent ( in ) :: nsym integer , intent ( in ) :: s ( 3 , 3 , nsym ) logical , intent ( in ) :: TR_symmetry real ( dp ), intent ( in ) :: v ( 3 ) real ( dp ), intent ( out ) :: vstar ( 3 , 96 ) integer , intent ( out ) :: nstar , symop ( 96 , 2 ) integer :: isym , i real ( dp ) :: vrot ( 3 ) symop = 0 nstar = 1 vstar ( 1 : 3 , nstar ) = v ( 1 : 3 ) symop ( 1 , 1 ) = 1 sym_loop : do isym = 1 , nsym vrot (:) = matmul ( dble ( s (:,:, isym )), v (:)) do i = 1 , nstar if ( sum ( abs ( vrot (:) - vstar ( 1 : 3 , i ))) < 1 0E-5 ) then cycle sym_loop end if enddo nstar = nstar + 1 vstar ( 1 : 3 , nstar ) = vrot ( 1 : 3 ) symop ( nstar , 1 ) = isym enddo sym_loop if ( TR_symmetry ) then TR_sym_loop : do isym = 1 , nsym vrot (:) = matmul ( dble ( s (:,:, isym )), - v (:)) ! -k do i = 1 , nstar if ( sum ( abs ( vrot (:) - vstar ( 1 : 3 , i ))) < 1 0E-5 ) then cycle TR_sym_loop end if enddo nstar = nstar + 1 vstar ( 1 : 3 , nstar ) = vrot ( 1 : 3 ) symop ( nstar , 2 ) = isym enddo TR_sym_loop end if end subroutine calculate_star_TR subroutine tetranodes_by_SplusG ( icoord , jcoord , bg , nsym , s , TR_sym , epsvert , related ) use intw_matrix_vector , only : ainv , norma implicit none ! I/O real ( dp ), intent ( in ) :: icoord ( 3 ), jcoord ( 3 ) real ( dp ), intent ( in ) :: bg ( 3 , 3 ) integer , intent ( in ) :: nsym , s ( 3 , 3 , nsym ) logical , intent ( in ) :: TR_sym real ( dp ), intent ( in ) :: epsvert logical , intent ( out ) :: related ! Local integer :: isym , ig , jg , kg real ( dp ) :: rot_inode ( 3 ), inode_crys ( 3 ) ! initalize related = . false . ! inode coord in crystal coords inode_crys = matmul ( ainv ( bg ), icoord (:)) do isym = 1 , nsym do ig = - 1 , 1 do jg = - 1 , 1 do kg = - 1 , 1 ! if ( ig . eq . 0 . and . jg . eq . 0 . and . kg . eq . 0 ) cycle ! rot_inode ( 1 : 3 ) = matmul ( bg , & matmul ( dble ( s (:,:, isym )), inode_crys ) & + real (( / ig , jg , kg / ), dp )) ! ! check with jnode if ( norma ( rot_inode (:) - jcoord (:)) . lt . epsvert ) then print * , \"\" print * , isym , ig , jg , kg , \"symmetry\" related = . true . return end if ! TR symmetry if ( TR_sym ) then ! rot_inode ( 1 : 3 ) = matmul ( bg , & - matmul ( dble ( s (:,:, isym )), inode_crys ) & + real (( / ig , jg , kg / ), dp )) ! ! check with jnode if ( norma ( rot_inode (:) - jcoord (:)) . lt . epsvert ) then related = . true . return end if ! end if ! TR_sym ! end do ! kg end do ! jg end do ! ig end do ! isym end subroutine tetranodes_by_SplusG subroutine create_isosurface_IBZ ( eiso , n_bnd , nrpts , ndegen , irvec , ham_r , alat , ag , bg , nsym , s , TR_sym , verbose , epsvert ) use intw_matrix_vector , only : ainv , norma implicit none ! I/O real ( dp ), intent ( in ) :: eiso ! Eenrgy of isosurface integer , intent ( in ) :: n_bnd ! Numer of bands on hr integer , intent ( in ) :: nrpts , ndegen ( nrpts ) ! Number of R vectors and their degeneracies on hr integer , intent ( in ) :: irvec ( 3 , nrpts ) ! R vectors complex ( dp ), intent ( in ) :: ham_r ( n_bnd , n_bnd , nrpts ) ! Hamiltonian in Wannier representation real ( dp ), intent ( in ) :: alat , ag ( 3 , 3 ), bg ( 3 , 3 ) ! Crystal and reciprocal lattice vectors on columns integer , intent ( in ) :: nsym ! Number of symmetry operations integer , intent ( in ) :: s ( 3 , 3 , nsym ) ! Symmetry-operation matrices logical , intent ( in ) :: TR_sym ! Time-reversal symmetry or not logical , intent ( in ) :: verbose ! .true. if info files are to be written real ( dp ), intent ( in ) :: epsvert ! Parameter to detect duplicated vertices ! Local integer , allocatable :: n_vert (:), n_tri (:) real ( dp ), allocatable :: v_coord (:,:,:), v_veloc (:,:,:) integer , allocatable :: v_index (:,:,:) ! integer :: itet , inod , ibnd , itri , j , iv , ivert , rdcd_vert , mid_nvert , tot_nvert , tot_ntri , ntr real ( dp ) :: tetracoord ( 3 , 4 ), vcoord ( 3 , 30000 , n_bnd ), etetra ( ntetra , 4 , n_bnd ), eig_int ( n_bnd ) real ( dp ) :: kvec_int ( 3 ), et ( 4 ), vtr ( 3 , 3 , 2 ) integer :: vindex ( 3 , 10000 , n_bnd ) ! integer :: jtet, jnod ! logical :: SplusG_node ! logical, allocatable :: node_done(:,:) write ( * , '(\"| - Creating isosurface at \",F14.8,\" eV...     |\")' ) eiso ! Calculate energies !allocate(node_done(4,ntetra)) !node_done(:,:) = .false. do itet = 1 , ntetra inod_loop : do inod = 1 , 4 ! !if(node_done(inod,itet)) cycle ! tetracoord (:, inod ) = ncoord (:, index_tetra ( inod , itet ) + 1 ) kvec_int (:) = matmul ( ainv ( bg ), tetracoord (:, inod )) ! Tetra node in crystal coordinates ! call calculate_energy_sym ( nsym , s , TR_sym , n_bnd , nrpts , ndegen , irvec , ham_r , kvec_int , eig_int ) !call calculate_energy(n_bnd, nrpts, ndegen, irvec, ham_r, kvec_int, eig_int) etetra ( itet , inod , 1 : n_bnd ) = eig_int ( 1 : n_bnd ) ! !! Check if this node has S+G related node !if (ANY(abs(matmul(ainv(bg), tetracoord(:,inod))-1.0_dp).lt.epsvert)) then !only check vertices at border of BZ !  do jtet = 1, ntetra !    do jnod = 1, 4 !      ! !      if (ALL(abs(matmul(ainv(bg), ncoord(:,index_tetra(jnod, jtet)+1))-1.0_dp).gt.epsvert)) cycle !      if(inod.eq.jnod .and. itet.eq.jtet) cycle !      if(node_done(jnod, jtet)) cycle !      ! !      call tetranodes_by_SplusG(tetracoord(:,inod), ncoord(:,index_tetra(jnod,jtet)+1), bg, nsym, s, TR_sym, epsvert, SplusG_node) !      if(SplusG_node) then ! {jnod,jtet} is pair of {inod,itet} !        print*, itet, inod, jtet, jnod, \"related!\" !        etetra(jtet, jnod,1:n_bnd) = etetra(itet,inod,1:n_bnd) !        node_done(jnod,jtet) = .true. !        !cycle inod_loop !      end if !    end do !  end do !  ! !end if ! end do inod_loop end do !deallocate(node_done) ! Create isosurface allocate ( n_vert ( n_bnd ), n_tri ( n_bnd )) n_vert = 0 n_tri = 0 mid_nvert = 0 do ibnd = 1 , n_bnd do itet = 1 , ntetra et ( 1 : 4 ) = etetra ( itet , 1 : 4 , ibnd ) do inod = 1 , 4 tetracoord (:, inod ) = ncoord (:, index_tetra ( inod , itet ) + 1 ) end do ntr = 0 vtr = 0 call tetra_cut ( eiso , tetracoord , et , ntr , vtr ) do itri = 1 , ntr n_tri ( ibnd ) = n_tri ( ibnd ) + 1 do iv = 1 , 3 n_vert ( ibnd ) = n_vert ( ibnd ) + 1 vcoord ( 1 : 3 , n_vert ( ibnd ), ibnd ) = vtr ( 1 : 3 , iv , itri ) vindex ( iv , n_tri ( ibnd ), ibnd ) = n_vert ( ibnd ) + mid_nvert end do end do end do mid_nvert = mid_nvert + n_vert ( ibnd ) end do if ( verbose ) then write ( * , '(\"|   Number of triangules and vertices:              |\")' ) do ibnd = 1 , n_bnd write ( * , '(\"|     band \",I4,\": \",I6,I6,\"                       |\")' ) ibnd , n_tri ( ibnd ), n_vert ( ibnd ) end do endif ! Total number of triangles and vertices tot_ntri = 0 tot_nvert = 0 do ibnd = 1 , n_bnd tot_ntri = tot_ntri + n_tri ( ibnd ) tot_nvert = tot_nvert + n_vert ( ibnd ) end do if ( verbose ) write ( * , '(\"|         ---------------------------------         |\")' ) ! Clean list write ( * , '(\"| - Cleaning list of triangles and vertices...      |\")' ) ! allocate ( v_index ( 3 , tot_ntri , n_bnd )) allocate ( v_coord ( 3 , tot_nvert , n_bnd )) v_coord (:,:,:) = 0.0_dp v_index (:,:,:) = 0 rdcd_vert = 0 ivert = 0 mid_nvert = 0 do ibnd = 1 , n_bnd if ( n_tri ( ibnd ). eq . 0 ) cycle v_coord (:, 1 , ibnd ) = vcoord (:, 1 , ibnd ) ivert = 0 rdcd_vert = 0 do itri = 1 , n_tri ( ibnd ) v_loop : do iv = 1 , 3 ivert = ivert + 1 do j = 1 , rdcd_vert if ( norma ( vcoord (:, ivert , ibnd ) - v_coord (:, j , ibnd )). lt . epsvert ) then v_index ( iv , itri , ibnd ) = j cycle v_loop end if end do ! rdcd_vert = rdcd_vert + 1 v_index ( iv , itri , ibnd ) = rdcd_vert v_coord (:, rdcd_vert , ibnd ) = vcoord (:, ivert , ibnd ) ! end do v_loop end do ! itri n_vert ( ibnd ) = rdcd_vert end do ! ibnd if ( verbose ) then write ( * , '(\"|   Number of triangles and vertices:               |\")' ) do ibnd = 1 , n_bnd if ( n_tri ( ibnd ). eq . 0 ) cycle write ( * , '(\"|     band \",I4,\": \",I6,I6,\"                       |\")' ) ibnd , n_tri ( ibnd ), n_vert ( ibnd ) end do endif ! Compute velocity on IBZ allocate ( v_veloc ( 3 , tot_nvert , n_bnd )) call velocity_on_IBZ ( n_bnd , n_vert , v_coord , nrpts , irvec , ndegen , alat , ag , bg , nsym , s , TR_sym , ham_r , v_veloc ) ! Save isosurface on module variables call set_isosurface ( n_bnd , n_vert , n_tri , v_coord , v_index , v_veloc ) end subroutine create_isosurface_IBZ subroutine velocity_on_IBZ ( n_bnd , n_vert , v_coord , nrpts , irvec , ndegen , alat , ag , bg , nsym , s , TR_sym , ham_r , v_veloc ) use intw_matrix_vector , only : ainv implicit none ! I/O integer , intent ( in ) :: n_bnd , n_vert ( n_bnd ) real ( dp ), intent ( in ) :: v_coord (:,:,:) integer , intent ( in ) :: nrpts , irvec ( nrpts ), ndegen ( nrpts ) real ( dp ), intent ( in ) :: alat , ag ( 3 , 3 ), bg ( 3 , 3 ) integer , intent ( in ) :: nsym , s ( 3 , 3 , nsym ) logical , intent ( in ) :: TR_sym complex ( dp ), intent ( in ) :: ham_r ( n_bnd , n_bnd , nrpts ) real ( dp ), intent ( out ) :: v_veloc (:,:,:) ! Local integer :: ibnd , iv real ( dp ) :: vcoord_crys ( 3 ), v_k ( 3 ) v_veloc = 0.0_dp do ibnd = 1 , n_bnd ! if ( n_vert ( ibnd ). eq . 0 ) cycle ! do iv = 1 , n_vert ( ibnd ) v_k = 0.0_dp vcoord_crys (:) = matmul ( ainv ( bg ), v_coord (:, iv , ibnd )) call velocity_sym ( nrpts , irvec , ndegen , alat , ag , bg , nsym , s , TR_sym , n_bnd , ibnd , ham_r , v_k , vcoord_crys ) v_veloc (:, iv , ibnd ) = v_k (:) end do ! iv end do ! ibnd end subroutine velocity_on_IBZ subroutine rotate_IBZ_mesh ( bg , nsym , s , n_vert , n_tri , v_coord , v_veloc , v_index , nstar , symop , epsvert , n_vert_rot , n_tri_rot , v_coord_rot , v_veloc_rot , v_index_rot ) use intw_matrix_vector , only : ainv , norma implicit none ! I/O variables real ( dp ), intent ( in ) :: bg ( 3 , 3 ) integer , intent ( in ) :: nsym , s ( 3 , 3 , nsym ) integer , intent ( in ) :: n_vert , n_tri real ( dp ), intent ( in ) :: v_coord ( 3 , n_vert ) real ( dp ), intent ( in ) :: v_veloc ( 3 , n_vert ) integer , intent ( in ) :: v_index ( 3 , n_tri ) integer , intent ( in ) :: nstar integer , intent ( in ) :: symop ( 92 , 2 ) real ( dp ), intent ( in ) :: epsvert ! Parameter to detect duplicated vertices integer , intent ( out ) :: n_vert_rot , n_tri_rot real ( dp ), intent ( out ) :: v_coord_rot (:,:) real ( dp ), intent ( out ) :: v_veloc_rot (:,:) integer , intent ( out ) :: v_index_rot (:,:) ! Local variables integer :: iv , ivert , i , j , it , istar , i_sym , nvert_aux real ( dp ) :: v ( 3 ), bgi ( 3 , 3 ) real ( dp ) :: vcoord_aux ( 3 , nstar * n_vert ), veloc_aux ( 3 , nstar * n_vert ) integer :: vindex_aux ( 3 , nstar * n_tri ) ! real(dp) :: s_cart(3,3,96) bgi = ainv ( bg ) !! transform symmetry operations to cartesian coords !do istar = 1, nstar !  if(symop(istar,1).ne.0) then !    i_sym = symop(istar,1) !    do i = 1, 3 !      s_cart(:,i,i_sym) = matmul(bg, s(:,i,i_sym)) !    end do !  end if !end do nvert_aux = 0 n_tri_rot = 0 do istar = 1 , nstar if ( symop ( istar , 1 ) /= 0 ) then i_sym = symop ( istar , 1 ) do iv = 1 , n_vert nvert_aux = nvert_aux + 1 v ( 1 : 3 ) = matmul ( bgi , v_coord ( 1 : 3 , iv )) !vcoord_aux(1:3,nvert_aux) = matmul(real(s(:,:,i_sym), dp), v) vcoord_aux ( 1 : 3 , nvert_aux ) = matmul ( s (:,:, i_sym ), v ) !! Transformation in cartesian coords !vcoord_aux(1:3,nvert_aux) = matmul(s_cart(:,:,i_sym), v_coord(1:3,iv)) ! v ( 1 : 3 ) = matmul ( bgi , v_veloc ( 1 : 3 , iv )) !veloc_aux(:,nvert_aux) = matmul(real(s(:,:,i_sym), dp), v) veloc_aux (:, nvert_aux ) = matmul ( s (:,:, i_sym ), v ) end do do it = 1 , n_tri n_tri_rot = n_tri_rot + 1 vindex_aux ( 1 : 3 , n_tri_rot ) = v_index ( 1 : 3 , it ) + ( istar - 1 ) * n_vert end do else if ( symop ( istar , 2 ) /= 0 ) then ! TR symmetry i_sym = symop ( istar , 2 ) do iv = 1 , n_vert nvert_aux = nvert_aux + 1 v ( 1 : 3 ) = matmul ( bgi , v_coord ( 1 : 3 , iv )) !vcoord_aux(1:3,nvert_aux) = -matmul(real(s(:,:,i_sym), dp), v) vcoord_aux ( 1 : 3 , nvert_aux ) = - matmul ( s (:,:, i_sym ), v ) !! Transformation in cartesian coords !vcoord_aux(1:3,nvert_aux) = -matmul(s_cart(:,:,i_sym), v_coord(1:3,iv)) ! v ( 1 : 3 ) = matmul ( bgi , v_veloc ( 1 : 3 , iv )) !veloc_aux(:,nvert_aux) = -matmul(real(s(:,:,i_sym), dp), v) veloc_aux (:, nvert_aux ) = - matmul ( s (:,:, i_sym ), v ) end do do it = 1 , n_tri n_tri_rot = n_tri_rot + 1 vindex_aux ( 1 : 3 , n_tri_rot ) = v_index ( 1 : 3 , it ) + ( istar - 1 ) * n_vert end do end if end do ! Clean list n_vert_rot = 0 ivert = 0 v_coord_rot (:, 1 ) = vcoord_aux (:, 1 ) do i = 1 , n_tri_rot v_loop : do iv = 1 , 3 do j = 1 , n_vert_rot if ( norma ( vcoord_aux (:, vindex_aux ( iv , i )) - v_coord_rot (:, j )) < epsvert ) then v_index_rot ( iv , i ) = j cycle v_loop end if end do n_vert_rot = n_vert_rot + 1 v_index_rot ( iv , i ) = n_vert_rot v_coord_rot (:, n_vert_rot ) = vcoord_aux (:, vindex_aux ( iv , i )) v_veloc_rot (:, n_vert_rot ) = veloc_aux (:, vindex_aux ( iv , i )) end do v_loop end do ! Transform back to cartesian coordinates do j = 1 , n_vert_rot v_coord_rot ( 1 : 3 , j ) = matmul ( bg , v_coord_rot ( 1 : 3 , j )) v_veloc_rot ( 1 : 3 , j ) = matmul ( bg , v_veloc_rot ( 1 : 3 , j )) end do end subroutine rotate_IBZ_mesh subroutine write_full_isosurface ( bg , nsym , s , TR_sym , n_bnd , verbose , epsvert , tag , prefix ) use intw_utility , only : find_free_unit , int2str use intw_matrix_vector , only : norma implicit none ! I/O real ( dp ), intent ( in ) :: bg ( 3 , 3 ) integer , intent ( in ) :: nsym integer , intent ( in ) :: s ( 3 , 3 , nsym ) logical , intent ( in ) :: TR_sym integer , intent ( in ) :: n_bnd logical , intent ( in ) :: verbose real ( dp ), intent ( in ) :: epsvert character ( len =* ), intent ( in ) :: tag character ( len =* ), optional , intent ( in ) :: prefix ! Local character ( len = 256 ) :: filename integer :: nstar , symop ( 96 , 2 ) real ( dp ) :: vstar ( 3 , 96 ) integer :: tot_ntri , mid_nvert , tot_nvert integer :: ibnd , iv , i , j , io_unit write ( * , '(\"| - Rotating IBZ...                                 |\")' ) ! Calculate star do iv = 1 , nnode call calculate_star_TR ( nsym , s , TR_sym , ncoord (:, iv ), vstar , nstar , symop ) if ( nstar . eq . nsym ) exit end do if ( verbose ) write ( * , '(\"|   nstar = \",I6,\"                   |\")' ) nstar ! Rotate mesh tot_ntri = sum ( ntri (:)) tot_nvert = sum ( nvert (:)) allocate ( vert_index_rot ( 3 , nstar * tot_ntri , n_bnd )) allocate ( vert_coord_rot ( 3 , nstar * tot_nvert , n_bnd )) allocate ( vert_veloc_rot ( 3 , nstar * tot_nvert , n_bnd )) allocate ( ntri_rot ( n_bnd ), nvert_rot ( n_bnd )) ntri_rot = 0 nvert_rot = 0 do ibnd = 1 , n_bnd if ( nvert ( ibnd ). eq . 0 ) cycle call rotate_IBZ_mesh ( bg , nsym , s , nvert ( ibnd ), ntri ( ibnd ), vert_coord (:,:, ibnd ), & vert_veloc (:,:, ibnd ), vert_index (:,:, ibnd ), nstar , symop , epsvert , & nvert_rot ( ibnd ), ntri_rot ( ibnd ), vert_coord_rot (:,:, ibnd ), & vert_veloc_rot (:,:, ibnd ), vert_index_rot (:,:, ibnd )) end do ! Total number of triangles and vertices tot_ntri = 0 tot_nvert = 0 do ibnd = 1 , n_bnd tot_ntri = tot_ntri + ntri_rot ( ibnd ) tot_nvert = tot_nvert + nvert_rot ( ibnd ) end do ! Write rotated mesh in OFF format write ( * , '(\"| - Writing full FS in OFF format...                |\")' ) if ( present ( prefix )) then filename = trim ( prefix ) // \".\" // trim ( tag ) // \".off\" else filename = trim ( tag ) // \".off\" endif write ( * , '(\"|   Filename: \",A,\" |\")' ) filename ( 1 : max ( 37 , len ( trim ( filename )))) ! ! Write full isosurface in OFF format io_unit = find_free_unit () open ( unit = io_unit , action = \"write\" , file = filename , status = \"unknown\" ) write ( unit = io_unit , fmt = \"(a)\" ) \"OFF\" write ( unit = io_unit , fmt = \"(3I10)\" ) tot_nvert , tot_ntri , 0 write ( unit = io_unit , fmt =* ) do ibnd = 1 , n_bnd do iv = 1 , nvert_rot ( ibnd ) write ( unit = io_unit , fmt = \"(4f18.10)\" ) ( vert_coord_rot ( j , iv , ibnd ), j = 1 , 3 ) end do end do mid_nvert = 0 do ibnd = 1 , n_bnd do i = 1 , ntri_rot ( ibnd ) write ( unit = io_unit , fmt = \"(4I6)\" ) 3 , ( mid_nvert + vert_index_rot ( j , i , ibnd ) - 1 , j = 1 , 3 ) end do mid_nvert = mid_nvert + nvert_rot ( ibnd ) end do close ( unit = io_unit ) write ( * , '(\"|   Total number of triangles and vertices:         |\")' ) write ( * , '(\"|     Triangles: \",I6,\"                             |\")' ) tot_ntri write ( * , '(\"|     Vertices:  \",I6,\"                             |\")' ) tot_nvert ! ! Write band-separated isosurface in OFF format do ibnd = 1 , n_bnd if ( nvert ( ibnd ). eq . 0 ) cycle io_unit = find_free_unit () if ( present ( prefix )) then filename = trim ( prefix ) // \".\" // trim ( int2str ( ibnd )) // \"_\" // trim ( tag ) // \".off\" else filename = trim ( int2str ( ibnd )) // \"_\" // trim ( tag ) // \".off\" endif open ( unit = io_unit , action = \"write\" , file = filename , status = \"unknown\" ) write ( unit = io_unit , fmt = \"(a)\" ) \"OFF\" write ( unit = io_unit , fmt = \"(3I10)\" ) nvert_rot ( ibnd ), ntri_rot ( ibnd ), 0 write ( unit = io_unit , fmt =* ) do iv = 1 , nvert_rot ( ibnd ) write ( unit = io_unit , fmt = \"(4f18.10)\" ) ( vert_coord_rot ( j , iv , ibnd ), j = 1 , 3 ) end do do i = 1 , ntri_rot ( ibnd ) write ( unit = io_unit , fmt = \"(4I6)\" ) 3 , ( vert_index_rot ( j , i , ibnd ) - 1 , j = 1 , 3 ) end do close ( unit = io_unit ) enddo ! ! Write files with Fermi velocity write ( * , '(\"| - Writing Fermi velocity files...                 |\")' ) do ibnd = 1 , n_bnd if ( nvert ( ibnd ). eq . 0 ) cycle io_unit = find_free_unit () if ( present ( prefix )) then filename = trim ( prefix ) // \".\" // trim ( int2str ( ibnd )) // \"_\" // trim ( tag ) // \"_v_k.dat\" else filename = trim ( int2str ( ibnd )) // \"_\" // trim ( tag ) // \"_v_k.dat\" endif open ( unit = io_unit , action = \"write\" , file = filename , status = \"unknown\" ) write ( unit = io_unit , fmt = \"(3I10)\" ) nvert_rot ( ibnd ) do iv = 1 , nvert_rot ( ibnd ) write ( unit = io_unit , fmt = \"(I6,4F18.10)\" ) iv , ( vert_veloc_rot ( j , iv , ibnd ), j = 1 , 3 ), norma ( vert_veloc_rot (:, iv , ibnd )) end do close ( unit = io_unit ) end do end subroutine write_full_isosurface subroutine write_IBZ_isosurface ( tag , n_bnd , velocities , prefix ) use intw_utility , only : find_free_unit , int2str use intw_matrix_vector , only : norma implicit none ! I/O character ( len =* ), intent ( in ) :: tag integer , intent ( in ) :: n_bnd logical , intent ( in ) :: velocities character ( len =* ), optional , intent ( in ) :: prefix ! Local character ( len = 256 ) :: filename integer :: ibnd , io_unit , iv , itri , i , j integer :: tot_nvert , tot_ntri , mid_nvert write ( * , '(\"| - Writing IBZ FS in OFF format...                 |\")' ) if ( present ( prefix )) then filename = trim ( prefix ) // \".\" // trim ( tag ) // \".off\" else filename = trim ( tag ) // \".off\" endif write ( * , '(\"|   Filename: \",A,\" |\")' ) filename ( 1 : max ( 37 , len ( trim ( filename )))) ! ! Write IBZ isosurface in OFF format io_unit = find_free_unit () open ( unit = io_unit , action = \"write\" , file = filename , status = \"unknown\" ) write ( unit = io_unit , fmt = \"(a)\" ) \"OFF\" write ( unit = io_unit , fmt = \"(3I10)\" ) sum ( nvert ), sum ( ntri ), 0 write ( unit = io_unit , fmt =* ) mid_nvert = 0 do ibnd = 1 , n_bnd if ( nvert ( ibnd ). eq . 0 ) cycle do iv = 1 , nvert ( ibnd ) write ( unit = io_unit , fmt = \"(3F18.10)\" ) ( vert_coord ( j , iv , ibnd ), j = 1 , 3 ) end do end do do ibnd = 1 , n_bnd do itri = 1 , ntri ( ibnd ) write ( unit = io_unit , fmt = \"(4I6)\" ) 3 , ( mid_nvert + vert_index ( j , itri , ibnd ) - 1 , j = 1 , 3 ) end do mid_nvert = mid_nvert + nvert ( ibnd ) end do close ( unit = io_unit ) ! ! Write band-separated IBZ isosurface in OFF format tot_nvert = 0 tot_ntri = 0 do ibnd = 1 , n_bnd if ( nvert ( ibnd ). eq . 0 ) cycle io_unit = find_free_unit () if ( present ( prefix )) then filename = trim ( prefix ) // \".\" // trim ( int2str ( ibnd )) // \"_\" // trim ( tag ) // \".off\" else filename = trim ( int2str ( ibnd )) // \"_\" // trim ( tag ) // \".off\" endif open ( unit = io_unit , action = \"write\" , file = filename , status = \"unknown\" ) write ( unit = io_unit , fmt = \"(a)\" ) \"OFF\" write ( unit = io_unit , fmt = \"(3I10)\" ) nvert ( ibnd ), ntri ( ibnd ), 0 write ( unit = io_unit , fmt =* ) do iv = 1 , nvert ( ibnd ) write ( unit = io_unit , fmt = \"(4f18.10)\" ) ( vert_coord ( j , iv , ibnd ), j = 1 , 3 ) tot_nvert = tot_nvert + 1 end do do i = 1 , ntri ( ibnd ) write ( unit = io_unit , fmt = \"(4I6)\" ) 3 , ( vert_index ( j , i , ibnd ) - 1 , j = 1 , 3 ) tot_ntri = tot_ntri + 1 end do close ( unit = io_unit ) end do write ( * , '(\"|   Total number of triangles and vertices:         |\")' ) write ( * , '(\"|     Triangles: \",I6,\"                             |\")' ) tot_ntri write ( * , '(\"|     Vertices:  \",I6,\"                             |\")' ) tot_nvert ! ! Check tot_ntri and tot_nvert if ( tot_ntri /= sum ( ntri ) ) stop \"ERROR: Wrong tot_ntri\" if ( tot_nvert /= sum ( nvert ) ) stop \"ERROR: Wrong tot_nvert\" ! ! Write file with Fermi velocity if ( velocities ) then ! write ( * , '(\"| - Writing Fermi velocity files...                 |\")' ) ! do ibnd = 1 , n_bnd if ( nvert ( ibnd ). eq . 0 ) cycle io_unit = find_free_unit () if ( present ( prefix )) then filename = trim ( prefix ) // \".\" // trim ( int2str ( ibnd )) // \"_\" // trim ( tag ) // \"_v_k.dat\" else filename = trim ( int2str ( ibnd )) // \"_\" // trim ( tag ) // \"_v_k.dat\" endif open ( unit = io_unit , action = \"write\" , file = filename , status = \"unknown\" ) write ( unit = io_unit , fmt = \"(3I10)\" ) nvert ( ibnd ) do iv = 1 , nvert ( ibnd ) write ( unit = io_unit , fmt = \"(I6,4F18.10)\" ) iv , ( vert_veloc ( j , iv , ibnd ), j = 1 , 3 ), norma ( vert_veloc (:, iv , ibnd )) end do close ( unit = io_unit ) end do ! endif end subroutine write_IBZ_isosurface subroutine DOS_isosurface ( alat , vbz , n_bnd , n_vert , n_tri , v_coord , v_index , v_veloc , n_vert_rot , n_tri_rot , v_coord_rot , v_index_rot , v_veloc_rot ) use intw_utility , only : find_free_unit , int2str use intw_useful_constants , only : pi use intw_matrix_vector , only : norma implicit none ! I/O real ( dp ), intent ( in ) :: alat , vbz integer , intent ( in ) :: n_bnd , n_vert (:), n_tri (:), v_index (:,:,:), n_vert_rot (:), n_tri_rot (:), v_index_rot (:,:,:) real ( dp ), intent ( in ) :: v_coord (:,:,:), v_veloc (:,:,:), v_coord_rot (:,:,:), v_veloc_rot (:,:,:) ! Local integer :: ibnd , iv , io_unit real ( dp ) :: ne real ( dp ), allocatable :: vert_area (:,:), ifs_area (:), rot_vert_area (:,:), fs_area (:) ! Allocate variables allocate ( vert_area ( maxval ( n_vert (:)), n_bnd ), ifs_area ( n_bnd )) allocate ( rot_vert_area ( maxval ( n_vert_rot (:)), n_bnd ), fs_area ( n_bnd )) io_unit = find_free_unit () open ( unit = io_unit , action = \"write\" , file = \"DOS.dat\" , status = \"unknown\" ) ! Loop over all FS sheets do ibnd = 1 , n_bnd ! if ( n_vert ( ibnd ). eq . 0 ) cycle ! ! Area of each vertex on IFS call vertices_area ( n_vert ( ibnd ), n_tri ( ibnd ), v_coord (:,:, ibnd ), v_index (:,:, ibnd ), vert_area (:, ibnd )) ! Area of IFS ifs_area = 0.0_dp do iv = 1 , n_vert ( ibnd ) ifs_area ( ibnd ) = ifs_area ( ibnd ) + vert_area ( iv , ibnd ) end do write ( io_unit , * ) \"Area of \" // trim ( int2str ( ibnd )) // \" IFS =\" , ifs_area ( ibnd ), \"(2*pi/alat)**2\" write ( io_unit , * ) \"              \" , ifs_area ( ibnd ) * ( 2.0_dp * pi / alat ) ** 2 , \"bohr**-2\" write ( io_unit , * ) ! Area of each vertex on full FS call vertices_area ( n_vert_rot ( ibnd ), n_tri_rot ( ibnd ), v_coord_rot (:,:, ibnd ), v_index_rot (:,:, ibnd ), rot_vert_area (:, ibnd )) ! Area of IFS fs_area = 0.0_dp do iv = 1 , n_vert_rot ( ibnd ) fs_area ( ibnd ) = fs_area ( ibnd ) + rot_vert_area ( iv , ibnd ) end do write ( io_unit , * ) \"Area of full \" // trim ( int2str ( ibnd )) // \" FS =\" , fs_area ( ibnd ), \"(2*pi/alat)**2\" write ( io_unit , * ) \"                  \" , fs_area ( ibnd ) * ( 2.0_dp * pi / alat ) ** 2 , \"bohr**-2\" write ( io_unit , * ) write ( io_unit , * ) \"full FS area / IFS area =\" , fs_area ( ibnd ) / ifs_area ( ibnd ) write ( io_unit , * ) end do ! ibnd !--------------- Compute Density of States at FS, N(e_F) ! write ( io_unit , * ) write ( io_unit , * ) \"Volume of BZ (bohr**-3) =\" , ( vbz * ( 2.0_dp * pi / alat ) ** 3 ) write ( io_unit , * ) \"\" do ibnd = 1 , n_bnd if ( n_vert_rot ( ibnd ). eq . 0 ) cycle ne = 0.0_dp do iv = 1 , n_vert_rot ( ibnd ) ne = ne + ( 1.0_dp / norma ( v_veloc_rot ( 1 : 3 , iv , ibnd ))) * ( rot_vert_area ( iv , ibnd ) * ( 2.0_dp * pi / alat ) ** 2 ) end do ne = 2.0_dp * ne / ( vbz * ( 2.0_dp * pi / alat ) ** 3 ) write ( io_unit , * ) \"Partial DOS at FS branch\" // trim ( int2str ( ibnd )) // \" = \" , ne , \"a.u.\" write ( io_unit , * ) \"                             \" , ne / 2 7.21138602_dp , \"1/e.V.\" write ( io_unit , * ) \"\" end do ne = 0.0_dp do ibnd = 1 , n_bnd if ( n_vert ( ibnd ). eq . 0 ) cycle do iv = 1 , n_vert ( ibnd ) ne = ne + ( 1.0_dp / norma ( v_veloc ( 1 : 3 , iv , ibnd ))) * ( vert_area ( iv , ibnd ) * ( 2.0_dp * pi / alat ) ** 2 ) end do end do ne = ne * sum ( fs_area (:)) / sum ( ifs_area (:)) ne = 2.0_dp * ne / ( vbz * ( 2.0_dp * pi / alat ) ** 3 ) write ( io_unit , * ) \"DOS at FS using irreducible mesh =\" , ne , \"a.u.\" write ( io_unit , * ) \"                                  \" , ne / 2 7.21138602_dp , \"1/e.V.\" write ( io_unit , * ) ne = 0.0_dp do ibnd = 1 , n_bnd if ( n_vert_rot ( ibnd ). eq . 0 ) cycle do iv = 1 , n_vert_rot ( ibnd ) ne = ne + ( 1.0_dp / norma ( v_veloc_rot ( 1 : 3 , iv , ibnd ))) * ( rot_vert_area ( iv , ibnd ) * ( 2.0_dp * pi / alat ) ** 2 ) end do end do ne = 2.0_dp * ne / ( vbz * ( 2.0_dp * pi / alat ) ** 3 ) write ( io_unit , * ) \"DOS at FS using full rotated mesh =\" , ne , \"a.u.\" write ( io_unit , * ) \"                                   \" , ne / 2 7.21138602_dp , \"1/e.V.\" close ( io_unit ) write ( * , '(\"|   DOS at FS: \",f16.8, \" a.u.                |\")' ) ne write ( * , '(\"|              \",f16.8, \" 1/eV                |\")' ) ne / 2 7.21138602_dp !--------------- Deallocate variables ! deallocate ( ifs_area , fs_area , vert_area , rot_vert_area ) end subroutine DOS_isosurface subroutine vertices_area ( n_vert , n_tri , v_coord , v_index , v_area ) use intw_matrix_vector , only : area_vec implicit none ! I/O variables integer , intent ( in ) :: n_vert , n_tri real ( dp ), intent ( in ) :: v_coord ( 3 , n_vert ) integer , intent ( in ) :: v_index ( 3 , n_tri ) real ( dp ), intent ( out ) :: v_area ( n_vert ) ! Local variables integer , parameter :: ntmax = 100 integer :: iv , jv , it , jt , ivertex integer , dimension ( n_vert ) :: num_of_nghb integer , dimension ( n_vert , ntmax ) :: tri_of_vertex real ( dp ), dimension ( 3 ) :: v1 , v2 , v3 real ( dp ) :: tri_area ! Find neighbour triangles of each vertex num_of_nghb (:) = 0 do it = 1 , n_tri do jv = 1 , 3 ivertex = v_index ( jv , it ) num_of_nghb ( ivertex ) = num_of_nghb ( ivertex ) + 1 if ( num_of_nghb ( ivertex ) . le . ntmax ) then tri_of_vertex ( ivertex , num_of_nghb ( ivertex )) = it else write ( * , * ) \"Error\" , ivertex ; stop end if end do end do ! Compute area of each vertex v_area = 0.0_dp do iv = 1 , n_vert do jt = 1 , num_of_nghb ( iv ) it = tri_of_vertex ( iv , jt ) v1 (:) = v_coord (:, v_index ( 1 , it )) v2 (:) = v_coord (:, v_index ( 2 , it )) v3 (:) = v_coord (:, v_index ( 3 , it )) tri_area = area_vec ( v2 - v1 , v3 - v1 ) v_area ( iv ) = v_area ( iv ) + tri_area / 3.0_dp end do end do end subroutine vertices_area subroutine set_isosurface ( n_bnd , n_vert , n_tri , v_coord , v_index , v_veloc ) implicit none integer , intent ( in ) :: n_bnd , n_vert (:), n_tri (:) real ( dp ), dimension (:,:,:), intent ( in ) :: v_coord integer , dimension (:,:,:), intent ( in ) :: v_index real ( dp ), dimension (:,:,:), intent ( in ), optional :: v_veloc integer :: ibnd if ( size ( n_vert , dim = 1 ) /= size ( n_tri , dim = 1 )) stop \"ERROR(set_isosurfce): n_vert and n_tri have different dimensions\" if ( size ( v_coord , dim = 3 ) /= size ( n_vert , dim = 1 )) stop \"ERROR(set_isosurfce): v_coord and n_vert have different dimensions\" if ( size ( v_index , dim = 3 ) /= size ( n_tri , dim = 1 )) stop \"ERROR(set_isosurfce): v_index and n_tri have different dimensions\" if ( size ( v_coord , dim = 1 ) /= 3 ) stop \"ERROR(set_isosurfce): v_coord has wrong dimensions\" if ( size ( v_index , dim = 1 ) /= 3 ) stop \"ERROR(set_isosurfce): v_index has wrong dimensions\" if ( present ( v_veloc )) then if ( size ( v_veloc , dim = 3 ) /= size ( n_vert , dim = 1 )) stop \"ERROR(set_isosurfce): v_veloc and n_vert have different dimensions\" if ( size ( v_veloc , dim = 1 ) /= 3 ) stop \"ERROR(set_isosurfce): v_veloc has wrong dimensions\" endif if ( allocated ( nvert )) deallocate ( nvert ) if ( allocated ( ntri )) deallocate ( ntri ) if ( allocated ( vert_coord )) deallocate ( vert_coord ) if ( allocated ( vert_coord )) deallocate ( vert_coord ) if ( present ( v_veloc )) then if ( allocated ( vert_veloc )) deallocate ( vert_veloc ) endif nbnd = n_bnd allocate ( nvert ( n_bnd ), ntri ( n_bnd )) nvert = 0 ntri = 0 allocate ( vert_coord ( 3 , maxval ( n_vert ), n_bnd )) allocate ( vert_index ( 3 , maxval ( n_tri ), n_bnd )) vert_coord = 0.0_dp vert_index = 0 if ( present ( v_veloc )) then allocate ( vert_veloc ( 3 , maxval ( n_vert ), n_bnd )) vert_veloc = 0.0_dp endif do ibnd = 1 , size ( n_vert , dim = 1 ) if ( n_vert ( ibnd ) == 0 ) cycle nvert ( ibnd ) = n_vert ( ibnd ) ntri ( ibnd ) = n_tri ( ibnd ) vert_coord ( 1 : 3 , 1 : n_vert ( ibnd ), ibnd ) = v_coord ( 1 : 3 , 1 : n_vert ( ibnd ), ibnd ) vert_index ( 1 : 3 , 1 : n_tri ( ibnd ), ibnd ) = v_index ( 1 : 3 , 1 : n_tri ( ibnd ), ibnd ) if ( present ( v_veloc )) vert_veloc ( 1 : 3 , 1 : n_vert ( ibnd ), ibnd ) = v_veloc ( 1 : 3 , 1 : n_vert ( ibnd ), ibnd ) enddo end subroutine set_isosurface end module triFS_isosurface","tags":"","url":"sourcefile/isosurface.f90.html"},{"title":"symmetries.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_symmetries !! display: none !! !! This module handles the space group symmetry operations. !! !! ### Details !! !! The subroutines in this module handle the space group symmetries and !! their effect on wave functions and matrix elements. They also allow the !! identification of an irreducible set of k-vectors in the 1BZ, forming the !! IBZ. !! !! It is advantageous to perform symmetry operations in crystal coordinates; !! indeed, in these coordinates, the zone is simply a cube and MP meshes are !! nice and regular. However, the crystal coordinate system introduces minor !! complications in the application of point group symmetry. A full !! description is given in algorithms.pdf. !! use kinds , only : dp implicit none ! ! variables public :: QE_folder_sym , QE_folder_nosym , symlink , full_mesh , IBZ , & inverse_indices , identity_matrix_index , symtable , & rtau_index , rtau , rtau_cryst , & spin_symmetry_matrices ! ! subroutines public :: allocate_symmetry_related_k , deallocate_symmetry_related_k , & set_symmetry_relations , find_size_of_irreducible_k_set , & find_the_irreducible_k_set , find_the_irreducible_k_set_and_equiv , & find_inverse_symmetry_matrices_indices , rot_atoms , & allocate_and_build_spin_symmetry_matrices , deallocate_spin_symmetry_matrices , & compute_rotation_axis , rotaxis_crystal , & rotate_wfc , apply_TR_to_wfc , & find_entire_nice_BZ , & calculate_star_r , calculate_star , & echo_symmetry_1BZ , multable ! ! functions public :: eqvect private ! save ! integer , allocatable :: QE_folder_nosym (:) ! integer , allocatable :: QE_folder_sym (:) ! Index of the symmetry operation (rotation, TR) that links a ! k-point with its equivalent point in the irreducible set integer , allocatable :: symlink (:,:) ! logical variables defining what is present in the QE folders logical :: full_mesh , IBZ ! Index of the inverse symmetry operations integer , allocatable :: inverse_indices (:) ! Index of the identity symmetry within all symmetry operations integer :: identity_matrix_index ! Multiplication table of the symmetry group integer , allocatable :: symtable (:,:) ! 2x2 matrices to rotate spinors complex ( kind = dp ), allocatable :: spin_symmetry_matrices (:,:,:) ! Identy of atoms under symmetry operations integer , allocatable :: rtau_index (:,:) real ( kind = dp ), allocatable :: rtau (:,:,:) real ( kind = dp ), allocatable :: rtau_cryst (:,:,:) contains subroutine allocate_symmetry_related_k ( nk1 , nk2 , nk3 ) !------------------------------------------------------------------ ! nk1, nk2, nk3 are the MP coefficient of the mesh !------------------------------------------------------------------ implicit none !I/O variables integer , intent ( in ) :: nk1 , nk2 , nk3 !local variables integer :: nkmesh nkmesh = nk1 * nk2 * nk3 ! allocate ( QE_folder_nosym ( nkmesh )) ! allocate ( QE_folder_sym ( nkmesh )) ! allocate ( symlink ( nkmesh , 2 )) end subroutine allocate_symmetry_related_k subroutine deallocate_symmetry_related_k () !------------------------------------------------------------------ ! This subroutine deallocates the arrays equiv and symlink. !------------------------------------------------------------------ implicit none if ( allocated ( QE_folder_nosym )) deallocate ( QE_folder_nosym ) ! if ( allocated ( QE_folder_sym )) deallocate ( QE_folder_sym ) ! if ( allocated ( symlink )) deallocate ( symlink ) end subroutine deallocate_symmetry_related_k subroutine set_symmetry_relations ( nk_1 , nk_2 , nk_3 , nk_irr , k_irr , & equiv_nosym_ , equiv_sym_ , symlink_ , & full_mesh_ , IBZ_ ) !--------------------------------------------------------------------------! ! Given an irreducible k-point set k_irr(1:nk_irr), this subroutine tests if ! it is consistent with the full (nk_1, nk_2, nk_3) MP mesh, and finds the ! connection to the full MP BZ. ! ! If k_irr(1:nk_irr) contains the full MP BZ, this subroutine will also ! tabulate the relationship between the k-points in the k_irr(1:nk_irr) set ! and the canonical 1BZ k-points. This will be useful for testing. ! ! Define kpt to be a k-point in the 1BZ of the MP mesh, and ikpt to be its index. ! Let kpt_irr be a symmetry equivalent k-point to kpt, and ikpt_irr be its index in k_irr(1:nk_irr). ! ! INPUT: ! ! - nk_1, nk_2, nk_3 : The MP mesh. ! ! - nk_irr : The size of the irreducible k-point set. ! ! - k_irr(3,nk_irr) : The irreducible k-point set in crystal coordinates. ! ! OUTPUT: ! ! - equiv_sym(nk_1*nk_2*nk_3) : The index of \"kpt_irr\" in the k-point set !                               which is symmetry equivalent to \"kpt\". ! ! - symlink(nk_1*nk_2*nk_3,2) : What symmetry operation must be performed !                               on \"kpt_irr\" to obtain \"kpt\". ! ! In equations: !         ikpt_irr = equiv_sym(ikpt) !         R        = symlink(ikpt) ! !         =========>  R*k_irr(ikpt_irr) = kmesh(ikpt) + G ! ! In the case that a full mesh is present, ! the following arrays will also be filled: ! ! - equiv_nosym(nk_1*nk_2*nk_3) : The index of \"kpt_irr\" in the k-point set !                                 which is translation equivalent to \"kpt\". ! ! In equations: !         ikpt_irr = equiv_nosym(ikpt) ! !         =========>  k_irr(ikpt_irr) = kmesh(ikpt) + G ! ! Additionally, the following variables will be set to check consistency: ! ! - IBZ : .true. if the full MP mesh is recovered form the k-point set. ! ! - full_mesh : .true. if the k-point set contains the full MP mesh. !-------------------------------------------------------------------------- use intw_useful_constants , only : eps_8 use intw_utility , only : find_k_1BZ_and_G , triple_to_joint_index_g use intw_reading , only : nsym , s , TR , lmag implicit none !input integer , intent ( in ) :: nk_1 , nk_2 , nk_3 integer , intent ( in ) :: nk_irr real ( kind = dp ), intent ( in ) :: k_irr ( 3 , nk_irr ) !output integer , intent ( out ) :: equiv_nosym_ ( nk_1 * nk_2 * nk_3 ) integer , intent ( out ) :: equiv_sym_ ( nk_1 * nk_2 * nk_3 ) integer , intent ( out ) :: symlink_ ( nk_1 * nk_2 * nk_3 , 2 ) logical , intent ( out ) :: full_mesh_ , IBZ_ !local variables real ( kind = dp ) :: kpt ( 3 ), rotated_kpt ( 3 ), kpt_in_1BZ ( 3 ), kpt_on_mesh ( 3 ) logical :: kpoint_is_found_sym ( nk_1 * nk_2 * nk_3 ), kpoint_is_found_nosym ( nk_1 * nk_2 * nk_3 ) logical :: possible_full_mesh integer :: G ( 3 ) integer :: ikpt_irr , ikpt , i , j , k , isym ! ! initialize arrays to a negative number: if there is a bug ! in the code, it will thus look for inexistent folders. It ! is better to crash than to produce wrong results! ! equiv_nosym_ = - 4 equiv_sym_ = - 4 symlink_ = - 4 full_mesh_ = . false . IBZ_ = . false . ! ! Check if k_irr can possibly contain the full MP mesh ! if ( nk_irr == nk_1 * nk_2 * nk_3 ) then possible_full_mesh = . true . else possible_full_mesh = . false . endif ! ! Loop on all k-points in k_irr ! kpoint_is_found_sym (:) = . false . kpoint_is_found_nosym (:) = . false . ! do ikpt_irr = 1 , nk_irr ! ! coordinates of this k-point, which need not lie in the 1BZ ! kpt = k_irr (:, ikpt_irr ) ! ! extract the triple coordinates, the kpt in the 1BZ and ! the G vector ! call find_k_1BZ_and_G ( kpt , nk_1 , nk_2 , nk_3 , i , j , k , kpt_in_1BZ , G ) ! ! test that this triple index indeed produces the k-point. ! This tests that the k-point is indeed on a mesh consistent ! with the input file. ! kpt_on_mesh ( 1 ) = dble ( i - 1 ) / dble ( nk_1 ) kpt_on_mesh ( 2 ) = dble ( j - 1 ) / dble ( nk_2 ) kpt_on_mesh ( 3 ) = dble ( k - 1 ) / dble ( nk_3 ) ! if ( any ( abs ( kpt_in_1BZ - kpt_on_mesh ) > eps_8 ) ) then ! write ( * , * ) 'consistency FAILURE' write ( * , '(A,3F8.4)' ) '        kpt = ' , kpt write ( * , '(A,3F8.4)' ) ' kpt_in_1BZ = ' , kpt_in_1BZ write ( * , '(A,3F8.4)' ) 'kpt_on_mesh = ' , kpt_on_mesh write ( * , '(A,3I4)' ) '   i, j , k = ' , i , j , k ! stop ! endif ! ! if there is the possibility of a full mesh being present, ! find the correspondence ! if ( possible_full_mesh ) then ! call triple_to_joint_index_g ( nk_1 , nk_2 , nk_3 , ikpt , i , j , k ) ! kpoint_is_found_nosym ( ikpt ) = . true . equiv_nosym_ ( ikpt ) = ikpt_irr ! endif !possible_full_mesh ! ! loop on all symmetry operations without TR ! do isym = 1 , nsym ! if ( lmag . and . TR ( isym )) cycle ! This symmetry operation needs TR, do not use it yet ! ! rotate the k-point. ! rotated_kpt = matmul ( dble ( s (:,:, isym )), kpt ) ! !  There is an added layer of complexity introduced by the fact !  that we are using crystal coordinates. The convention for the !  action of the crystal coordinate point group matrices is: ! !  R_mu * k&#94;{cart}  => sum_{j} s(R&#94;{-1}_mu)_{ij} k&#94;{cryst}_j ! !  Thus, it is actually the index of the INVERSE which must be used. !  This may seem like a trivial change, but it affects the phase !  factor which must be introduced when a wavefunction is rotated, !  in the case of a non-symmorphic group. !  Find the corresponding k-point in the canonical 1BZ. ! ! extract the triple coordinates, the kpt in the 1BZ and ! the G vector ! call find_k_1BZ_and_G ( rotated_kpt , nk_1 , nk_2 , nk_3 , i , j , k , kpt_in_1BZ , G ) ! ! Tabulate this point as found, but only if allowed to do so! ! ! find its joint coordinate ! call triple_to_joint_index_g ( nk_1 , nk_2 , nk_3 , ikpt , i , j , k ) ! ! if this point hasn't been found before, well, it's found now! ! if (. not . kpoint_is_found_sym ( ikpt )) then ! kpoint_is_found_sym ( ikpt ) = . true . equiv_sym_ ( ikpt ) = ikpt_irr !ASIER 09/03/20222 !we are taking the inverse of the inverse twice all over the code. !symlink(ikpt,1) = inverse_index(isym) symlink_ ( ikpt , 1 ) = isym symlink_ ( ikpt , 2 ) = 0 ! endif ! not found ! enddo ! isym ! ! repeat with TR symmetry, if allowed (or required!) ! do isym = 1 , nsym ! if (. not . TR ( isym )) cycle ! ! rotate the k-point + TR ! rotated_kpt = - matmul ( dble ( s (:,:, isym )), kpt ) ! call find_k_1BZ_and_G ( rotated_kpt , nk_1 , nk_2 , nk_3 , i , j , k , kpt_in_1BZ , G ) ! ! find its joint coordinate ! call triple_to_joint_index_g ( nk_1 , nk_2 , nk_3 , ikpt , i , j , k ) ! if (. not . kpoint_is_found_sym ( ikpt )) then ! kpoint_is_found_sym ( ikpt ) = . true . equiv_sym_ ( ikpt ) = ikpt_irr ! symlink(ikpt,1) = inverse_indices(isym) symlink_ ( ikpt , 1 ) = isym symlink_ ( ikpt , 2 ) = 1 ! endif ! not found ! enddo ! isym ! enddo ! ikpt_irr ! ! test if all the kmesh points were found ! IBZ_ = all ( kpoint_is_found_sym ) full_mesh_ = all ( kpoint_is_found_nosym ) ! if ( (. not . IBZ_ ) . and . (. not . full_mesh_ ) ) write ( * , * ) \"WARNING in set_symmetry_relations: At least one k-point does not map properly\" end subroutine set_symmetry_relations subroutine find_size_of_irreducible_k_set ( nk_1 , nk_2 , nk_3 , nk_irr ) !------------------------------------------------------------------ ! This subroutine finds the size of the irreducible k-point set for ! the canonical 1BZ (nk_1, nk_2, nk_3) MP mesh. !------------------------------------------------------------------ use intw_useful_constants , only : eps_8 use intw_utility , only : find_k_1BZ_and_G , triple_to_joint_index_g use intw_reading , only : nsym , s , TR , lmag implicit none !input integer , intent ( in ) :: nk_1 , nk_2 , nk_3 ! The input k division !output integer , intent ( out ) :: nk_irr ! N. of irreducible k-points found for the nk_1 nk_2 nk_3 MP mesh. !local variables real ( kind = dp ) :: k_rot ( 3 ), k_1BZ ( 3 ), k_irr ( 3 ) integer :: i , j , k ! triple indices integer :: is , js , ks ! triple indices  obtained by symmetry integer :: G ( 3 ) integer :: isym integer :: ikpt , ikpts ! joint index, joint index obtained by symmetry logical :: found ( nk_1 * nk_2 * nk_3 ) ! ! Initialize output ! nk_irr = 0 ! ! loop on the whole mesh, in the appropriate order (very important!) ! found = . false . do i = 1 , nk_1 do j = 1 , nk_2 do k = 1 , nk_3 ! ! find scalar index of point (i,j,k) call triple_to_joint_index_g ( nk_1 , nk_2 , nk_3 , ikpt , i , j , k ) ! ! operate on this point only if it has not already been found! if (. not . found ( ikpt )) then ! ! it's found now. This point is part of the IBZ. found ( ikpt ) = . true . ! nk_irr = nk_irr + 1 ! k_irr ( 1 ) = dble ( i - 1 ) / nk_1 k_irr ( 2 ) = dble ( j - 1 ) / nk_2 k_irr ( 3 ) = dble ( k - 1 ) / nk_3 ! ! loop on all symmetry operations do isym = 1 , nsym ! if ( lmag . and . TR ( isym )) cycle ! This symmetry operation needs TR, do not use it yet ! ! perform matrix product ! CAREFUL! since the matrix is in crystal coordinates, ! and it acts in reciprocal space, the convention is : !          k_rot(i) = sum_j s(i,j)*k(j) ! k_rot (:) = matmul ( dble ( s (:,:, isym )), k_irr (:)) ! ! find what point in the 1BZ this corresponds to call find_k_1BZ_and_G ( k_rot , nk_1 , nk_2 , nk_3 , is , js , ks , k_1BZ , G ) ! ! check that k_1BZ+G = k_rot. If not, k_rot isn't on the mesh, ! and the algorithm in \"find_k_1BZ_and_G\" cannot be trusted. if ( all ( abs ( k_rot - ( k_1BZ + dble ( G ))) < eps_8 ) ) then ! ! what is the scalar index call triple_to_joint_index_g ( nk_1 , nk_2 , nk_3 , ikpts , is , js , ks ) ! if (. not . found ( ikpts )) found ( ikpts ) = . true . ! endif ! dk ! enddo ! isym ! ! repeat with TR symmetry, if allowed (or required!) ! do isym = 1 , nsym ! if (. not . TR ( isym )) cycle ! k_rot = - matmul ( dble ( s (:,:, isym )), k_irr (:)) ! ! find what point in the 1BZ this corresponds to call find_k_1BZ_and_G ( k_rot , nk_1 , nk_2 , nk_3 , is , js , ks , k_1BZ , G ) ! ! we check again the value of dk, so if k_1BZ+G = k_rot if ( all ( abs ( k_rot - ( k_1BZ + dble ( G ))) < eps_8 ) ) then ! ! what is the scalar index call triple_to_joint_index_g ( nk_1 , nk_2 , nk_3 , ikpts , is , js , ks ) ! if (. not . found ( ikpts )) found ( ikpts ) = . true . ! endif ! dk ! enddo ! isym ! endif ! found(ikpt) ! enddo ! k enddo ! j enddo ! i end subroutine find_size_of_irreducible_k_set subroutine find_the_irreducible_k_set ( nk_1 , nk_2 , nk_3 , nk_irr , kpoints_irr , weight_irr ) !------------------------------------------------------------------ ! This subroutine finds the irreducible k-point set for the canonical ! 1BZ (nk_1, nk_2, nk_3) MP mesh. !------------------------------------------------------------------ use intw_useful_constants , only : eps_8 use intw_utility , only : find_k_1BZ_and_G , triple_to_joint_index_g use intw_reading , only : nsym , s , TR , lmag implicit none !input integer , intent ( in ) :: nk_1 , nk_2 , nk_3 ! The input k division !output integer , intent ( out ) :: nk_irr ! N. of irreducible k-points found for the nk_1 nk_2 nk_3 MP mesh. real ( kind = dp ), intent ( out ) :: kpoints_irr ( 3 , nk_1 * nk_2 * nk_3 ) ! The irreducible k-point set in crystal coordinates. ! The size of the array is nk_1*nk_2*nk_3 instead of nk_irr; ! it is supposed that we still do not know the value of nk_irr real ( kind = dp ), optional , intent ( out ) :: weight_irr ( nk_1 * nk_2 * nk_3 ) ! The weight of of each irreducible k-point for BZ integrations. ! The size of the array is nk_1*nk_2*nk_3 instead of nk_irr; ! it is supposed that we still do not know the value of nk_irr !local variables real ( kind = dp ) :: k_rot ( 3 ), k_1BZ ( 3 ) integer :: i , j , k ! triple indices integer :: is , js , ks ! triple indices obtained by symmetry integer :: ikpt , ikpts ! joint index, joint index obtained by symmetry integer :: isym integer :: nstarr integer :: G ( 3 ) logical :: found ( nk_1 * nk_2 * nk_3 ) ! ! Initialize output nk_irr = 0 kpoints_irr = 0.0_dp if ( present ( weight_irr )) weight_irr = 0.0_dp ! ! loop on the whole mesh, in the appropriate order (very important!) found = . false . do i = 1 , nk_1 do j = 1 , nk_2 do k = 1 , nk_3 ! ! find scalar index of point (i,j,k) call triple_to_joint_index_g ( nk_1 , nk_2 , nk_3 , ikpt , i , j , k ) ! ! operate on this point only if it has not already been found! if (. not . found ( ikpt )) then ! nk_irr = nk_irr + 1 ! kpoints_irr ( 1 , nk_irr ) = dble ( i - 1 ) / nk_1 kpoints_irr ( 2 , nk_irr ) = dble ( j - 1 ) / nk_2 kpoints_irr ( 3 , nk_irr ) = dble ( k - 1 ) / nk_3 ! nstarr = 0 ! ! loop on all symmetry operations do isym = 1 , nsym ! if ( lmag . and . TR ( isym )) cycle ! This symmetry operation needs TR, do not use it yet ! ! perform matrix product ! CAREFUL! since the matrix is in crystal coordinates, ! and it acts in reciprocal space, the convention is : !          k_rot(i) = sum_j s(i,j)*k(j) ! k_rot = matmul ( dble ( s (:,:, isym )), kpoints_irr (:, nk_irr )) ! ! find what point in the 1BZ this corresponds to call find_k_1BZ_and_G ( k_rot , nk_1 , nk_2 , nk_3 , is , js , ks , k_1BZ , G ) ! ! check that k_1BZ+G = k_rot. If not, k_rot isn't on the mesh, ! and the algorithm in \"find_k_1BZ_and_G\" cannot be trusted. if ( all ( abs ( k_rot - ( k_1BZ + dble ( G ))) < eps_8 ) ) then ! ! what is the scalar index call triple_to_joint_index_g ( nk_1 , nk_2 , nk_3 , ikpts , is , js , ks ) ! if (. not . found ( ikpts )) then found ( ikpts ) = . true . nstarr = nstarr + 1 endif ! endif ! dk ! enddo ! isym ! ! repeat with TR symmetry, if allowed (or required!) ! do isym = 1 , nsym ! if (. not . TR ( isym )) cycle ! k_rot = - matmul ( dble ( s (:,:, isym )), kpoints_irr (:, nk_irr )) ! ! find what point in the 1BZ this corresponds to call find_k_1BZ_and_G ( k_rot , nk_1 , nk_2 , nk_3 , is , js , ks , k_1BZ , G ) ! ! we check again the value of dk, so if k_1BZ+G = k_rot if ( all ( abs ( k_rot - ( k_1BZ + dble ( G ))) < eps_8 ) ) then ! ! what is the scalar index call triple_to_joint_index_g ( nk_1 , nk_2 , nk_3 , ikpts , is , js , ks ) ! if (. not . found ( ikpts )) then found ( ikpts ) = . true . nstarr = nstarr + 1 endif ! endif ! dk ! enddo ! isym ! if ( present ( weight_irr )) weight_irr ( nk_irr ) = dble ( nstarr ) / ( nk_1 * nk_2 * nk_3 ) ! endif ! found(ikpt) ! enddo ! k enddo ! j enddo ! i end subroutine find_the_irreducible_k_set subroutine find_the_irreducible_k_set_and_equiv ( nkpts , k_set , nk_irr , k_irr , equiv_ , symlink_ ) !------------------------------------------------------------------ ! This subroutine finds the irreducible k-point set for a general k-point list !------------------------------------------------------------------ use intw_reading , only : nsym , s , TR , lmag use intw_useful_constants , only : eps_7 implicit none !input integer , intent ( in ) :: nkpts ! Size of the general k-point set real ( kind = dp ), intent ( in ) :: k_set ( 3 , nkpts ) ! General k-point set ! output integer :: nk_irr ! N. of irreducible k-points found for the general k-point set real ( kind = dp ) :: k_irr ( 3 , nkpts ) ! The irreducible k-point set in crystal coordinates. ! The size of the array is nkpts instead of nk_irr; ! it is supposed that we still do not know the value of nk_irr integer :: equiv_ ( nkpts ) ! which is the equivalent point integer , intent ( out ) :: symlink_ ( nkpts , 2 ) ! !local variables real ( kind = dp ) :: k_rot ( 3 ) integer :: ik , jk , isym logical :: found ( nkpts ) ! ! Initialize output variables ! nk_irr = 0 k_irr = 0.0_dp equiv_ = - 4 symlink_ = - 4 ! ! Loop on all k-points in k_irr ! found = . false . do ik = 1 , nkpts ! if ( found ( ik )) cycle ! nk_irr = nk_irr + 1 k_irr ( 1 : 3 , nk_irr ) = modulo ( k_set ( 1 : 3 , ik ), 1.0_dp ) ! ! loop on all symmetry operations without TR ! do isym = 1 , nsym ! if ( lmag . and . TR ( isym )) cycle ! This symmetry operation needs TR, do not use it yet ! ! rotate the k-point ! k_rot = matmul ( dble ( s (:,:, isym )), k_irr (:, nk_irr )) ! do jk = 1 , nkpts ! if ( found ( jk )) cycle ! if ( all ( abs ( modulo ( k_set (:, jk ), 1.0_dp ) - modulo ( k_rot (:), 1.0_dp )) < eps_7 ) ) then ! ! if this point hasn't been found before, well, it's found now! ! found ( jk ) = . true . ! equiv_ ( jk ) = nk_irr symlink_ ( jk , 1 ) = isym symlink_ ( jk , 2 ) = 0 ! endif ! enddo ! jk ! enddo ! isym ! ! ! repeat with TR symmetry, if allowed (or required!) ! do isym = 1 , nsym ! if (. not . TR ( isym )) cycle ! ! rotate the k-point + TR ! k_rot = - matmul ( dble ( s (:,:, isym )), k_irr (:, nk_irr )) ! do jk = 1 , nkpts ! if ( found ( jk )) cycle ! if ( all ( abs ( modulo ( k_set (:, jk ), 1.0_dp ) - modulo ( k_rot (:), 1.0_dp )) < eps_7 ) ) then ! ! if this point hasn't been found before, well, it's found now! ! found ( jk ) = . true . ! equiv_ ( jk ) = nk_irr symlink_ ( jk , 1 ) = isym symlink_ ( jk , 2 ) = 1 ! endif ! enddo ! jk ! enddo ! isym ! enddo ! ik ! if (. not . all ( found )) stop \"ERROR in find_the_irreducible_k_set_and_equiv: At least one k-point does not map properly\" end subroutine find_the_irreducible_k_set_and_equiv subroutine find_inverse_symmetry_matrices_indices () !------------------------------------------------------------------ ! For every point group operation isym, this subroutine finds ! the index of the inverse point group operation. ! ! This will be useful because, by convention, in crystal coordinates, ! !     R_alpha * k ===>   \\sum_j s(R&#94;{-1}_alpha)_{ij} k_j ! ! (This extra layer of complication is QE's fault, not mine) !------------------------------------------------------------------ use intw_useful_constants , only : ZERO , eps_5 use intw_reading , only : nsym , s , at , bg implicit none real ( kind = dp ) :: rot_cart ( 3 , 3 , nsym ), rot1 ( 3 , 3 ), rot2 ( 3 , 3 ), prod ( 3 , 3 ) real ( kind = dp ) :: norm integer :: isym , jsym , ns , i , j , l , mu , nu logical :: found ! Find the rotation matrices in cartesian coordinates ! allocate ( inverse_indices ( nsym )) rot_cart = zero ! do isym = 1 , nsym ! do mu = 1 , 3 do nu = 1 , 3 do i = 1 , 3 do j = 1 , 3 ! rot_cart ( mu , nu , isym ) = rot_cart ( mu , nu , isym ) + bg ( nu , i ) * s ( i , j , isym ) * at ( mu , j ) ! enddo !j enddo !i enddo !nu enddo !mu ! enddo !isym ! ! Find the inverse of every symmetry matrix ! inverse_indices = 0 ! do isym = 1 , nsym ! rot1 (:,:) = rot_cart (:,:, isym ) ! found = . false . ! do jsym = 1 , nsym ! rot2 (:,:) = rot_cart (:,:, jsym ) ! ! set the product to minus 1 ! prod = zero prod ( 1 , 1 ) = - 1.0_dp prod ( 2 , 2 ) = - 1.0_dp prod ( 3 , 3 ) = - 1.0_dp ! norm = zero ! do i = 1 , 3 do j = 1 , 3 do l = 1 , 3 ! prod ( i , j ) = prod ( i , j ) + rot1 ( i , l ) * rot2 ( l , j ) ! enddo !l ! norm = norm + prod ( i , j ) ** 2 ! enddo !j enddo !i ! norm = sqrt ( norm ) ! if ( norm < eps_5 ) then ! inverse_indices ( isym ) = jsym found = . true . exit ! endif ! enddo !jsym ! if (. not . found ) then ! write ( * , '(a,I3)' ) & 'ERROR: no inverse matrix found for operation isym = ' , isym stop ! endif ! enddo !isym ! do ns = 1 , nsym ! if ( s ( 1 , 1 , ns ) == 1 . and . s ( 1 , 2 , ns ) == 0 . and . s ( 1 , 3 , ns ) == 0 . and . & s ( 2 , 1 , ns ) == 0 . and . s ( 2 , 2 , ns ) == 1 . and . s ( 2 , 3 , ns ) == 0 . and . & s ( 3 , 1 , ns ) == 0 . and . s ( 3 , 2 , ns ) == 0 . and . s ( 3 , 3 , ns ) == 1 ) then ! identity_matrix_index = ns ! exit ! endif enddo !ns ! return end subroutine find_inverse_symmetry_matrices_indices subroutine rot_atoms ( nat , nsym , tau ) use intw_reading , only : nr1 , nr2 , nr3 , s , ftau , at , bg , tau_cryst implicit none integer , intent ( in ) :: nat , nsym real ( kind = dp ), intent ( in ) :: tau ( 3 , nat ) !out global !    integer, intent(out) :: rtau_index(nat,nsym) !    real(kind=dp), intent(out) :: rtau(3,nsym,nat) !    real(kind=dp), intent(out) :: rtau_cryst(3,nsym,nat) integer :: i , j , h integer :: isym integer :: nr ( 3 ) integer :: a_index , na integer :: ipol , jpol , kpol , lpol real ( kind = dp ), parameter :: epsat = 1E-3 real ( kind = dp ) :: s_cart ( 3 , 3 , nsym ) do isym = 1 , nsym do ipol = 1 , 3 do jpol = 1 , 3 s_cart ( ipol , jpol , isym ) = 0.d0 do kpol = 1 , 3 do lpol = 1 , 3 s_cart ( ipol , jpol , isym ) = s_cart ( ipol , jpol , isym ) + at ( ipol , kpol ) * & s ( lpol , kpol , isym ) * bg ( jpol , lpol ) enddo enddo enddo enddo enddo nr = ( / nr1 , nr2 , nr3 / ) rtau_index = - 11 do i = 1 , nat do isym = 1 , nsym do ipol = 1 , 3 rtau_cryst ( ipol , isym , i ) = s ( 1 , ipol , isym ) * tau_cryst ( 1 , i ) + & s ( 2 , ipol , isym ) * tau_cryst ( 2 , i ) + & s ( 3 , ipol , isym ) * tau_cryst ( 3 , i ) rtau_cryst ( ipol , isym , i ) = rtau_cryst ( ipol , isym , i ) - dble ( ftau ( ipol , isym )) end do enddo enddo do i = 1 , nat do isym = 1 , nsym do j = 1 , nat if ( eqvect ( rtau_cryst (:, isym , i ), tau_cryst (:, j ), ( / 0.d0 , 0.0d0 , 0.0d0 / ))) rtau_index ( i , isym ) = j enddo enddo enddo do isym = 1 , nsym do na = 1 , nat a_index = rtau_index ( na , isym ) do h = 1 , 3 rtau ( h , isym , na ) = s_cart ( 1 , h , isym ) * tau ( 1 , na ) + & s_cart ( 2 , h , isym ) * tau ( 2 , na ) + & s_cart ( 3 , h , isym ) * tau ( 3 , na ) rtau ( h , isym , na ) = rtau ( h , isym , na ) - tau ( h , a_index ) end do enddo enddo do i = 1 , nat do isym = 1 , nsym if ( rtau_index ( i , isym ). eq . 0 ) then write ( * , * ) 'ERROR in rot_at: At least one atom does not map properly under sym. op.' , isym , 'atom:' , i endif enddo enddo end subroutine rot_atoms subroutine allocate_and_build_spin_symmetry_matrices ( nsym ) !------------------------------------------------------------------ ! This subroutine builds, once and for all, all the 2x2 spin ! rotation matrices needed by the program and tabulates them in the ! array spin_symmetry_matrices. ! ! Some elementary testing is also implemented. !------------------------------------------------------------------ use intw_useful_constants , only : cmplx_0 , cmplx_1 , cmplx_i , i2 , sig_x , sig_y , sig_z , eps_5 use intw_reading , only : s , at , bg use intw_matrix_vector , only : det implicit none !I/O variables integer , intent ( in ) :: nsym !local variables integer :: isym integer :: sym ( 3 , 3 ) real ( kind = dp ) :: sym_cart ( 3 , 3 ) !symmetry matrix in crystal coordinates complex ( kind = dp ) :: S_u ( 2 , 2 ) !the 2x2 spin rotation matrix real ( kind = dp ) :: axis ( 3 ), angle !axis and angle of a given rotation matrix real ( kind = dp ) :: determinant , I3 ( 3 , 3 ) real ( kind = dp ) :: bgtrans ( 3 , 3 ) integer :: i , j , k , h I3 ( 1 ,:) = ( / 1.0_DP , 0.0_DP , 0.0_DP / ) I3 ( 2 ,:) = ( / 0.0_DP , 1.0_DP , 0.0_DP / ) I3 ( 3 ,:) = ( / 0.0_DP , 0.0_DP , 1.0_DP / ) ! allocate ( spin_symmetry_matrices ( 2 , 2 , nsym )) ! ! build the spin symmetry matrices for all symmetry operations ! bgtrans = transpose ( bg ) do isym = 1 , nsym ! sym = s (:,:, isym ) ! !ASIER rotaxis MUST be replaced by another procedure !diagonalizin the sym_cart matriz !       call rotaxis_crystal(sym,axis,angle) !call rotaxis(sym,axis,angle) determinant = det ( real ( sym , kind = dp )) !the inversion part does not affect the spin !we must remove this, otherwise the dimension of the !null space of sym-I is more than 1. if ( determinant < 0 ) sym = - sym sym_cart = 0.0_dp do i = 1 , 3 do j = 1 , 3 do k = 1 , 3 do h = 1 , 3 sym_cart ( i , j ) = sym_cart ( i , j ) + at ( i , k ) * sym ( h , k ) * bg ( j , h ) enddo enddo enddo enddo !Identitity element if ( sum ( abs ( sym_cart - I3 )) < eps_5 ) then axis = ( / 1.0_dp , 0.0_dp , 0.0_dp / ) angle = 0.0 S_u = I2 spin_symmetry_matrices (:,:, isym ) = S_u (:,:) else !Other elements ! call compute_rotation_axis ( sym_cart , axis , angle ) ! S_u (:,:) = cos ( angle / 2.d0 ) * I2 (:,:) - cmplx_i * sin ( angle / 2.d0 ) * ( axis ( 1 ) * sig_x (:,:) & + axis ( 2 ) * sig_y (:,:) & + axis ( 3 ) * sig_z (:,:) ) spin_symmetry_matrices (:,:, isym ) = S_u (:,:) end if ! enddo !isym ! return end subroutine allocate_and_build_spin_symmetry_matrices subroutine deallocate_spin_symmetry_matrices () !------------------------------------------------------------------ ! This subroutine deallocates the array spin_symmetry_matrices !------------------------------------------------------------------ deallocate ( spin_symmetry_matrices ) end subroutine deallocate_spin_symmetry_matrices subroutine compute_rotation_axis ( A , axis , angle ) !ASIER !This subrutine is new 15/03/2022 !determines the null space of (R-I) !which is the rotation axis use kinds , only : dp implicit none external :: dgesvd real ( kind = dp ), intent ( in ) :: a (:,:) real ( kind = dp ), intent ( out ) :: axis ( size ( a , 1 )) real ( kind = dp ), intent ( out ) :: angle !local variables real ( kind = dp ) :: u ( size ( a , 1 ), size ( a , 1 )) real ( kind = dp ) :: vt ( size ( a , 1 ), size ( a , 1 )) real ( kind = dp ) :: s ( size ( a , 1 )) real ( kind = dp ) :: ai ( size ( a , 1 ), size ( a , 1 )) !3X3 identity matrix real ( kind = dp ) :: i3 ( size ( a , 1 ), size ( a , 1 )) integer , parameter :: lwmax = 1000 integer :: info , lwork real ( kind = dp ), allocatable :: work (:) integer :: m = 3 integer :: n = 3 integer :: ind , k , i real ( kind = dp ) :: u1 ( 3 ), u2 ( 3 ), u3 ( 3 ), kosinu , sinu i3 ( 1 ,:) = ( / 1.0_DP , 0.0_DP , 0.0_DP / ) i3 ( 2 ,:) = ( / 0.0_DP , 1.0_DP , 0.0_DP / ) i3 ( 3 ,:) = ( / 0.0_DP , 0.0_DP , 1.0_DP / ) if ( n /= m ) then write ( * , * ) \"rotation matrix must be 3x3\" write ( * , * ) m , n stop end if AI = A - I3 lwork = - 1 allocate ( work ( 1 )) call dgesvd ( 'A' , 'A' , N , N , AI , N , S , U , N , VT , N , & WORK , LWORK , INFO ) lwork = nint ( work ( 1 )) deallocate ( work ) allocate ( work ( lwork )) call dgesvd ( 'A' , 'A' , N , N , AI , N , S , U , N , VT , N , & WORK , LWORK , INFO ) !Here we check the dimension of null space of R-I k = 0 do i = 1 , 3 if ( abs ( s ( i )) < 1.e-6 ) then ind = i k = k + 1 end if end do if ( k > 1 ) then write ( * , * ) \"something wrong in svd part of rotaxis\" write ( * , * ) \"the dimension of the kernel of r-i must be = 1 \" , k end if ! We construct an (oriented) frame as follows ! u1 is the rotation axis u1 = vt ( ind ,:) !/sqrt(sum(vt(ind,:)*vt(ind,:))) !Choose any vector of VT, we know it is orthogonal to u1 because VT is !an orthogonal matrix do i = 1 , 3 if ( i /= ind ) then u2 (:) = vt ( i ,:) end if end do !3th vector by cross product to ensure orientation. !u1xu2 u3 ( 1 ) = u1 ( 2 ) * u2 ( 3 ) - u1 ( 3 ) * u2 ( 2 ) u3 ( 2 ) = u1 ( 3 ) * u2 ( 1 ) - u1 ( 1 ) * u2 ( 3 ) u3 ( 3 ) = u1 ( 1 ) * u2 ( 2 ) - u1 ( 2 ) * u2 ( 1 ) ! If we apply the rotation to u2: R*u2 =   Cos[angle] * u2 +  Sin[angle] *u3 ! u2.R*u2 =  Cos[angle] ! u3.R*u2 =  Sin[angle] kosinu = sum ( u2 * matmul ( A , u2 )) sinu = sum ( u3 * matmul ( A , u2 )) axis = u1 angle = atan2 ( sinu , kosinu ) end subroutine compute_rotation_axis subroutine rotaxis_crystal ( sym , axis , angle ) !------------------------------------------------------------- ! ASIER: DO NOT USE THIS 15/03/2022 (BECAUSE WRONG) ! USE NEW COMPUTE_ROTATION_AXIS OR OLDER ROTAXIS !------------------------------------------------------------------ ! This subroutine finds the axis and the angle of rotation ! for a given point group operation sym. Note that \"sym\" is in ! crystal coordinates, and that it might be the composition of ! a rotation and the inversion. ! ! Define a point group operation in cartesian coorinates S&#94;{cart} ! such that ! !\t\tr'_{alpha} = \\sum_{beta=1}&#94;3 S&#94;{cart}_{alpha beta} r_{beta} ! ! In crystal coordinates, and following QE's conventions,  this ! leads to !            x'_{i}  = \\sum_{j=1}&#94;3  S&#94;{cryst}_{ji} x_{j} ! !\twhere !\t\t\tS&#94;{cryst}_{ji} = 1/2pi b_i * S&#94;{cart} * a_j !\twhich becomes !\t\t\tS&#94;{cryst} = A * [S&#94;{cart}&#94;T] * B ! !\t\t\twith A = [ - a_1 - ]     B = [  |   |   |  ] !\t\t\t         [ - a_2 - ]     B = [ b_1 b_2 b_3 ] !\t\t\t         [ - a_3 - ]     B = [  |   |   |  ] ! !\tS&#94;{cryst} is the matrix read from Quantum Espresso. ! !\t-\tThe angle is given by 1+2cos(angle) = Tr[S], which !\t\tis independent of the basis. ! !\t-\tThe angle is given by 1+2cos(angle) = Tr[S], which !\t\tis independent of the basis. !------------------------------------------------------------------ use intw_useful_constants , only : ZERO , ONE , pi , eps_8 use intw_reading , only : at , bg use intw_matrix_vector , only : det implicit none !I/O variables integer , intent ( in ) :: sym ( 3 , 3 ) !symmetry matrix in crystal coordinates real ( kind = dp ), intent ( out ) :: axis ( 3 ), angle !axis and angle of a given rotation matrix !local variables integer :: determinant , trace , mu , nu , i , j real ( kind = dp ) :: two_sin_angle integer :: Rot_cryst ( 3 , 3 ) ! rotation part of the operation, in crystal coordinates real ( kind = dp ) :: Rot_cart ( 3 , 3 ) ! rotation matrix, in cartesian coordinates real ( kind = dp ) :: x_tmp , norm_axis ( 3 ), sign_axis ( 3 ) logical :: vanish ( 3 ) ! First, find the determinant ! determinant = nint ( det ( real ( sym , kind = dp ))) ! ! Put the rotation part of the symmetry matrix in the Rotation array, ! multiplied by the appropriate coefficient to account for inversion ! if ( determinant == 1 ) then ! Rot_cryst (:,:) = sym (:,:) ! elseif ( determinant ==- 1 ) then ! Rot_cryst (:,:) = - sym (:,:) ! else ! write ( * , * ) '************************************************' write ( * , * ) '** ERROR: The determinant of the rotation     **' write ( * , * ) '**        matrix is not +/- 1.                **' write ( * , * ) '**        review code.                        **' write ( * , * ) '**          program stops.                    **' write ( * , * ) '************************************************' ! stop ! endif ! ! compute the rotation matrix in cartesian coordinates ! Rot_cart (:,:) = ZERO ! do mu = 1 , 3 do nu = 1 , 3 do i = 1 , 3 do j = 1 , 3 ! Rot_cart ( mu , nu ) = Rot_cart ( mu , nu ) + bg ( nu , i ) * Rot_cryst ( i , j ) * at ( mu , j ) ! enddo !j end do !i enddo !nu enddo !mu ! ! Extract the rotation angle from the trace of the matrix ! trace = Rot_cryst ( 1 , 1 ) + Rot_cryst ( 2 , 2 ) + Rot_cryst ( 3 , 3 ) ! ! there are only 5 possibilities in a crystal; ! tabulating insures there is no problem with picking the right quadrant. ! if ( trace ==- 1 ) then ! angle = pi two_sin_angle = ZERO ! elseif ( trace == 0 ) then ! angle = 2.0_dp * pi / 3.0_dp two_sin_angle = sqrt ( 3.0_dp ) ! elseif ( trace == 1 ) then ! angle = pi / 2.0_dp two_sin_angle = 2.0_dp ! elseif ( trace == 2 ) then ! angle = pi / 3.0_dp two_sin_angle = sqrt ( 3.0_dp ) ! elseif ( trace == 3 ) then ! angle = ZERO two_sin_angle = ZERO ! else ! write ( * , * ) '************************************************' write ( * , * ) '** ERROR: The trace of the rotation matrix    **' write ( * , * ) '**        is not in [-1,0,1,2,3]. review code.**' write ( * , * ) '**              program stops.                **' write ( * , * ) '************************************************' ! stop ! endif ! ! build the axis array ! if ( trace ==- 1 ) then ! ! This is the complicated case. Since angle = pi, ! the cartesian rotation matrix is symmetric. ! A bit of cleverness is required to extract the axis vector. ! ! First, find the norms of the coordinates ! x_tmp = Rot_cart ( 1 , 1 ) + ONE ! if ( x_tmp > eps_8 ) then ! norm_axis ( 1 ) = sqrt ( x_tmp ) / sqrt ( 2.0_dp ) vanish ( 1 ) = . false . ! else ! norm_axis ( 1 ) = ZERO vanish ( 1 ) = . true . ! endif ! x_tmp = Rot_cart ( 2 , 2 ) + ONE ! if ( x_tmp > eps_8 ) then ! norm_axis ( 2 ) = sqrt ( x_tmp ) / sqrt ( 2.0_dp ) vanish ( 2 ) = . false . ! else ! norm_axis ( 2 ) = ZERO vanish ( 2 ) = . true . ! endif ! x_tmp = Rot_cart ( 3 , 3 ) + ONE ! if ( x_tmp > eps_8 ) then ! norm_axis ( 3 ) = sqrt ( x_tmp ) / sqrt ( 2.0_dp ) vanish ( 3 ) = . false . ! else ! norm_axis ( 3 ) = ZERO vanish ( 3 ) = . true . ! endif ! ! if (. not . vanish ( 1 ) . and . . not . vanish ( 2 ) . and . . not . vanish ( 3 )) then ! ! if no component vanishes, arbitrarily set the sign of ! n3 to be positive. ! sign_axis ( 3 ) = ONE sign_axis ( 2 ) = Rot_cart ( 2 , 3 ) / ( 2.0_dp * norm_axis ( 2 ) * norm_axis ( 3 )) sign_axis ( 1 ) = Rot_cart ( 1 , 3 ) / ( 2.0_dp * norm_axis ( 1 ) * norm_axis ( 3 )) ! elseif (. not . vanish ( 1 ) . and . . not . vanish ( 2 ) . and . vanish ( 3 )) then ! ! if one component vanishes, arbitrarily set the sign of the largest index ! component to be positive. ! sign_axis ( 3 ) = ZERO sign_axis ( 2 ) = ONE sign_axis ( 1 ) = Rot_cart ( 1 , 2 ) / ( 2.0_dp * norm_axis ( 1 ) * norm_axis ( 2 )) ! elseif (. not . vanish ( 1 ) . and . vanish ( 2 ) . and . . not . vanish ( 3 )) then ! sign_axis ( 3 ) = ONE sign_axis ( 2 ) = ZERO sign_axis ( 1 ) = Rot_cart ( 1 , 3 ) / ( 2.0_dp * norm_axis ( 1 ) * norm_axis ( 3 )) ! elseif ( vanish ( 1 ) . and . . not . vanish ( 2 ) . and . . not . vanish ( 3 )) then ! sign_axis ( 3 ) = ONE sign_axis ( 1 ) = ZERO sign_axis ( 2 ) = Rot_cart ( 2 , 3 ) / ( 2.0_dp * norm_axis ( 2 ) * norm_axis ( 3 )) ! elseif ( vanish ( 1 ) . and . vanish ( 2 ) . and . . not . vanish ( 3 )) then ! ! if two components vanish, arbitrarily set the sign of the non ! vanishing component to be positive. ! sign_axis ( 1 ) = ZERO sign_axis ( 2 ) = ZERO sign_axis ( 3 ) = ONE ! elseif ( vanish ( 1 ) . and . . not . vanish ( 2 ) . and . vanish ( 3 )) then ! sign_axis ( 1 ) = ZERO sign_axis ( 2 ) = ONE sign_axis ( 3 ) = ZERO ! elseif (. not . vanish ( 1 ) . and . vanish ( 2 ) . and . vanish ( 3 )) then ! sign_axis ( 1 ) = ONE sign_axis ( 2 ) = ZERO sign_axis ( 3 ) = ZERO ! endif ! axis ( 1 ) = norm_axis ( 1 ) * sign_axis ( 1 ) axis ( 2 ) = norm_axis ( 2 ) * sign_axis ( 2 ) axis ( 3 ) = norm_axis ( 3 ) * sign_axis ( 3 ) ! elseif ( trace == 0 . or . trace == 1 . or . trace == 2 ) then ! ! For these cases, sin(alpha) is not zero ! we can extract the axis from the off diagonal elements ! of the rotation matrix. ! axis ( 1 ) = ( Rot_cart ( 3 , 2 ) - Rot_cart ( 2 , 3 ) ) / two_sin_angle axis ( 2 ) = ( Rot_cart ( 1 , 3 ) - Rot_cart ( 3 , 1 ) ) / two_sin_angle axis ( 3 ) = ( Rot_cart ( 2 , 1 ) - Rot_cart ( 1 , 2 ) ) / two_sin_angle ! elseif ( trace == 3 ) then ! ! This is the simplest case: it corresponds to ! the identity operation, and the direction of the axis ! is irrelevant. ! axis = ZERO ! endif ! return end subroutine rotaxis_crystal subroutine rotate_wfc ( wfc_k_irr , list_iG_irr , wfc_k , list_iG_k , i_sym , sym , ftau , G_sym ) !-------------------------------------------------------------------------------------------------------- ! This subroutine takes in the periodic part of a wavefunction psi_{nk} and ! returns the periodic part of psi_{n Rk}, where Rk is the rotated k-vector. ! ! The wavefunctions have the form !\t\t\tpsi_{nk}(r) = e&#94;{ikr}/sqrt{V} u_{nk}(r) !\t\t\tu_{nk}(r)   = \\sum_G e&#94;{iGr} u_{nk}(G). ! ! !  a crystal rotation-like symmetry can be expressed as !\t\tS = { R | f } !\twhere R is a rotation and f a fractional translation. ! ! Note that symmetry is implemented in a very confusing way in Quantum Espresso. ! On the one hand, section A.4 of the Quantum Espresso reference paper, ! \t\t\"Quantum Espresso: a modular and open-source software project for !  \t\t\tquantum simulations of materials\", !     suggests the convention: !           r' =  { R | f } r = R * ( r + f )  !! NOTE: this is NOT the usual textbook definition! ! ! HOWEVER: poking around in the code suggests that the convention actually !\t     used in the code is !           r' =  { R | f } r = R * r - f ! !\t(This only matters in non-symmorphic systems) ! In what follows, the second convention will be used. ! ! assumptions: !\t\t\t-  i_sym is the index of the symmetry operation !\t\t\t-  sym is a point group operation: !                        it is the INVERSE of the actual operation; this is the !                        appropriate operator to act on k, in crystal coordinates !\t\t\t-  k_irr is a k-point in the IBZ !\t\t\t-  sym * k_irr  = k + G_sym, with k in the 1BZ ! !\tapplying the point group operation yields ! !           u_{nk}(sym_l*G+G_sym) =  e&#94;{i R*G*tau} u_{nk_irr}(G) !-------------------------------------------------------------------------------------------------------- use intw_fft , only : find_iG use intw_useful_constants , only : tpi , cmplx_0 , cmplx_i , cmplx_1 use intw_utility , only : hpsort_integer use intw_reading , only : nGk_max , gvec , nspin , num_bands_intw implicit none !I/O variables integer , intent ( in ) :: i_sym ! index of the symmetry operation integer , intent ( in ) :: G_sym ( 3 ) ! G vector such that  R*k + G_sym = sym_l * k_irr integer , intent ( in ) :: sym ( 3 , 3 ) ! inverse point group operation the one acting on k (cryst.coord.) real ( kind = dp ), intent ( in ) :: ftau ( 3 ) ! fractional translation associated with point group operation integer , intent ( in ) :: list_iG_irr ( nGk_max ) ! G vector indices for k_irr complex ( kind = dp ), intent ( in ) :: wfc_k_irr ( nGk_max , num_bands_intw , nspin ) ! wfc at point k_irr in the IBZ integer , intent ( out ) :: list_iG_k ( nGk_max ) ! G vector indices for k, sorted complex ( kind = dp ), intent ( out ) :: wfc_k ( nGk_max , num_bands_intw , nspin ) ! rotated wfc at point k in the 1BZ !local variables complex ( kind = dp ) :: wfc_k_aux ( nGk_max , num_bands_intw , nspin ) integer :: p_i , i , iGk , iG_k integer :: Gk ( 3 ) ! a vector for k in the IBZ integer :: RGk ( 3 ) ! ( symmetry operation )* G_k integer :: G_k ( 3 ) ! a vector for Rk, the point in the 1BZ integer :: permutations ( nGk_max ) ! index permutation which orders list_G_k integer :: ibnd , ispin integer :: nG ! counter on the number of G vectors in the array complex ( kind = dp ) :: phases ( nGk_max ), spin_symmetry ( 2 , 2 ) phases (:) = cmplx_0 wfc_k (:,:,:) = cmplx_0 ! list_iG_k (:) = 0 nG = 0 permutations (:) = 0 ! ! loop on all Gk, the coefficients of the wave function at the IBZ k-point ! do i = 1 , nGk_max ! iGk = list_iG_irr ( i ) ! if ( iGk == 0 ) exit ! the index array is zero-padded at the end. nG = nG + 1 ! only increment if iGk /= 0! ! Gk = gvec (:, iGk ) ! RGk = matmul ( sym , Gk ) ! !ASIER: Gk and NOT RGk!!! ! - sign is well checked below. phases ( nG ) = exp ( - cmplx_I * tpi * dot_product ( Gk , ftau )) G_k (:) = RGk (:) + G_sym (:) call find_iG ( G_k , iG_k ) ! list_iG_k ( nG ) = iG_k ! enddo ! call hpsort_integer ( nG , list_iG_k , permutations ) ! do i = 1 , nG ! ! compute the wfc element ! p_i = permutations ( i ) ! do ibnd = 1 , num_bands_intw do ispin = 1 , nspin ! wfc_k ( i , ibnd , ispin ) = wfc_k_irr ( p_i , ibnd , ispin ) * phases ( p_i ) ! enddo !ispin enddo !ibnd ! enddo !i ! if ( nspin == 2 ) then ! wfc_k_aux = wfc_k spin_symmetry = spin_symmetry_matrices (:,:, inverse_indices ( i_sym )) ! do i = 1 , nG do ibnd = 1 , num_bands_intw ! ! JLB, MBR 29/06/2023 wfc_k ( i , ibnd ,:) = matmul ( spin_symmetry , wfc_k_aux ( i , ibnd ,:)) ! enddo !ibnd enddo !i ! endif ! If non-collinear end subroutine rotate_wfc subroutine apply_TR_to_wfc ( wfc , list_iG ) !----------------------------------------------------------------------------- ! This subroutine takes in a wavefunction wfc = u_{n-k} and ! returns, in the same array, wfc&#94;* = u_{n-k}&#94;*, which is equal to ! u_{nk} if time-reversal symmetry applies. ! ! Actually, -k is in the 1BZ, but k may not be. Define !                     k = k_I+G_TR ! !     The wavefunctions are represented as !             u_{-k}(r) = \\sum_{G} C_{-k}(G) e&#94;{iGr} ===> wfc(iG) = C_{-k}(G) ! !             u_{k }(r) = \\sum_{G} C_{k}(G) e&#94;{iGr} ! !             u_{k_I}(r) = \\sum_{G} C_{k_I}(G) e&#94;{iGr} ! !           ===>  C_{k_I} (G_TR-G) = C&#94;*_{-k}(G) !----------------------------------------------------------------------------- use intw_fft , only : find_iG use intw_useful_constants , only : cmplx_0 use intw_utility , only : hpsort_integer use intw_reading , only : nGk_max , gvec , nspin , num_bands_intw implicit none !I/O variables integer , intent ( inout ) :: list_iG ( nGk_max ) complex ( kind = dp ), intent ( inout ) :: wfc ( nGk_max , num_bands_intw , nspin ) !local variables integer :: iG , i_minus_G , i , p_i integer :: G ( 3 ), minus_G ( 3 ) integer :: nG ! counter on the number of G vectors in the array integer :: permutations ( nGk_max ) ! index permutation which orders list_G integer :: list_iG_tmp ( nGk_max ) complex ( kind = dp ) :: wfc_tmp ( nGk_max , num_bands_intw , nspin ) ! Initialize the different variables ! nG = 0 permutations = 0 list_iG_tmp = 0 wfc_tmp = cmplx_0 ! ! loop on all G ! do i = 1 , nGk_max ! iG = list_iG ( i ) ! ! We work with G that contribute in the wfc ! if ( iG == 0 ) exit ! the index array is zero-padded at the end. ! nG = nG + 1 G = gvec (:, iG ) ! minus_G = - G ! ! find the index of -G ! call find_iG ( minus_G , i_minus_G ) ! list_iG_tmp ( nG ) = i_minus_G ! ! conjugate the wavefunction ! wfc_tmp ( nG ,:,:) = conjg ( wfc ( i ,:,:)) ! enddo ! ! There is no guarantee that the indices in list_iG_k will be sorted in ascending ! order! This is not an absolute necessity, but it would be nice and consistent for ! the indices to be sorted. ! Sort the indices using a canned heap sort subroutine. ! call hpsort_integer ( nG , list_iG_tmp , permutations ) ! ! To understand how this works, consider an example: ! !            i      f(i)        iG(i)   permutation(i) !            --------------------------------------- !            1      0.1         4            2 !            2      0.2         1            4 !            3      0.3         3            3 !            4      0.4         2            1 ! !            j   sort(iG)(j)    sort(f)(j) !            ------------------------------------ !            1      1               0.2 !            2      2               0.4 !            3      3               0.3 !            4      4               0.1 ! !             ===> sort(f) (j)  =   f( permutation(j) ) ! ! ! list_iG_tmp is now properly sorted, and can be dumped in the input/output variable ! list_iG = list_iG_tmp ! ! finally, populate the conjugated wave function ! do i = 1 , nG ! p_i = permutations ( i ) ! ! compute the wfc element ! if ( nspin == 1 ) then ! wfc ( i ,:,:) = wfc_tmp ( p_i ,:,:) ! elseif ( nspin == 2 ) then ! wfc ( i ,:, 1 ) = - wfc_tmp ( p_i ,:, 2 ) wfc ( i ,:, 2 ) = wfc_tmp ( p_i ,:, 1 ) ! endif !nspin ! enddo !i end subroutine apply_TR_to_wfc subroutine find_entire_nice_BZ ( nk1 , nk2 , nk3 , nspt , ksvec ) !------------------------------------------------------------------ ! input: private nk1 nk2 nk3, output full BZ nk>nk1*nk2*nk3 for tria_diag by AE.&IGdG. ! NOTE Haritz 08/09/2025: This subroutine is not tested as it is not used anywhere !------------------------------------------------------------------ use intw_input_parameters , only : TR_symmetry use intw_useful_constants , only : eps_8 use intw_utility , only : find_k_1BZ_and_G , triple_to_joint_index_g use intw_reading , only : nsym , s , at , bg implicit none !input integer , intent ( in ) :: nk1 , nk2 , nk3 ! output real ( kind = dp ), intent ( out ) :: ksvec ( 3 , 2 * nk1 * nk2 * nk3 ) integer , intent ( out ) :: nspt !local variables real ( kind = dp ) :: k_rot ( 3 ), k_1BZ ( 3 ), dk ( 3 ) integer :: nkpt ! The total number of points integer :: i , j , k , ii , jj , kk ! triple indices integer :: is , js , ks ! triple indices  obtained by symmetry integer :: G ( 3 ) integer :: ns integer :: ikpt , ikpts ! joint index, joint index obtained by symmetry logical :: found ( nk1 * nk2 * nk3 ) real ( kind = dp ) :: k_aux ( 3 , 48 ) real ( kind = dp ), parameter :: eps = 1 d - 6 integer :: nsp , iss , nk_irr real ( kind = dp ) :: kpoints_irr ( 3 , nk1 * nk2 * nk3 ), dist1 , dist2 nkpt = nk1 * nk2 * nk3 ! Find which symmetry operation is the identity ! most likely always the first element, but let's be sure found = . false . nk_irr = 0 ! loop on the whole mesh, in the appropriate order do i = 1 , nk1 do j = 1 , nk2 do k = 1 , nk3 ! find scalar index of point (i,j,k) call triple_to_joint_index_g ( nk1 , nk2 , nk3 , ikpt , i , j , k ) ! operate on this point only if it has not already been found! if (. not . found ( ikpt )) then ! it's found now. This point is part of the IBZ. found ( ikpt ) = . true . nk_irr = nk_irr + 1 kpoints_irr ( 1 , nk_irr ) = dble ( i - 1 ) / nk1 kpoints_irr ( 2 , nk_irr ) = dble ( j - 1 ) / nk2 kpoints_irr ( 3 , nk_irr ) = dble ( k - 1 ) / nk3 ! loop on all symmetry operations do ns = 1 , nsym !perform matrix product ! CAREFUL! since the matrix is in crystal coordinates, ! and it acts in reciprocal space, the convention is : !          k_rot(i) = sum_j s(i,j)*k(j) k_rot = matmul ( dble ( s (:,:, ns )), kpoints_irr (:, nk_irr )) ! find what point in the 1BZ this corresponds to call find_k_1BZ_and_G ( k_rot , nk1 , nk2 , nk3 , is , js , ks , k_1BZ , G ) ! check that k_1BZ+G = k_rot. If not, k_rot isn't on the mesh, ! and the algorithm in \"find_k_1BZ_and_G\" cannot be trusted. dk = k_rot - ( k_1BZ + dble ( G )) if ( sqrt ( dot_product ( dk , dk )) < eps_8 ) then ! what is the scalar index call triple_to_joint_index_g ( nk1 , nk2 , nk3 , ikpts , is , js , ks ) if (. not . found ( ikpts )) found ( ikpts ) = . true . end if ! dk ! Repeat, with Time-Reversal symmetry if present if ( TR_symmetry ) then k_rot = - k_rot ! find what point in the 1BZ this corresponds to call find_k_1BZ_and_G ( k_rot , nk1 , nk2 , nk3 , is , js , ks , k_1BZ , G ) dk = k_rot - ( k_1BZ + dble ( G )) if ( sqrt ( dot_product ( dk , dk )) < eps_8 ) then ! what is the scalar index call triple_to_joint_index_g ( nk1 , nk2 , nk3 , ikpts , is , js , ks ) if (. not . found ( ikpts )) found ( ikpts ) = . true . end if ! dk end if !TR_symmetry end do ! ns end if ! found(ikpt) end do ! k end do ! j end do ! i do ikpt = 1 , nk_irr k_rot (:) = matmul ( bg , kpoints_irr (:, ikpt )) dist1 = sum ( k_rot (:) ** 2 ) do ii =- 1 , 1 do jj =- 1 , 1 do kk =- 1 , 1 k_rot (:) = matmul ( bg , kpoints_irr (:, ikpt )) + matmul ( bg , dble (( / ii , jj , kk / ))) dist2 = sum ( k_rot (:) ** 2 ) if ( dist2 < dist1 ) then kpoints_irr (:, ikpt ) = matmul ( transpose ( at ), k_rot ) dist1 = dist2 endif enddo enddo enddo enddo nspt = 0 do ikpt = 1 , nk_irr nsp = 1 nspt = nspt + 1 k_aux (:, nsp ) = kpoints_irr (:, ikpt ) ksvec (:, nspt ) = k_aux (:, nsp ) s_l : do is = 1 , nsym k_rot = matmul ( dble ( s (:,:, is )), kpoints_irr (:, ikpt )) iss_l : do iss = 1 , nsp if ( sum ( abs ( k_aux (:, iss ) - k_rot (:))) < eps ) cycle s_l enddo iss_l nsp = nsp + 1 k_aux (:, nsp ) = k_rot (:) nspt = nspt + 1 ksvec (:, nspt ) = k_aux (:, nsp ) enddo s_l enddo ! do ikpt=1,nspt !   write(*,\"(3f12.6)\") ksvec(:,ikpt) ! enddo end subroutine find_entire_nice_BZ subroutine calculate_star_r ( v , vstar , nstar , symop ) use intw_reading , only : nsym , s implicit none real ( kind = dp ), intent ( in ) :: v ( 3 ) real ( kind = dp ), intent ( out ) :: vstar ( 3 , 48 ) integer , intent ( out ) :: nstar , symop ( 48 ) integer :: isym , i real ( kind = dp ) :: vrot ( 3 ) nstar = 1 vstar ( 1 : 3 , nstar ) = v ( 1 : 3 ) symop ( 1 ) = 1 do isym = 1 , nsym vrot (:) = matmul ( dble ( s (:,:, isym )), v (:)) do i = 1 , nstar if ( sum ( abs ( vrot (:) - vstar ( 1 : 3 , i ))) < 1 0E-5 ) then goto 1987 end if enddo nstar = nstar + 1 vstar ( 1 : 3 , nstar ) = vrot ( 1 : 3 ) symop ( nstar ) = isym 1987 continue enddo end subroutine calculate_star_r subroutine calculate_star ( v , vstar , nstar , symop ) use intw_reading , only : nsym , s implicit none integer , intent ( in ) :: v ( 3 ) integer , intent ( out ) :: vstar ( 3 , 48 ), symop ( 48 ) integer , intent ( out ) :: nstar integer :: isym , i integer :: vrot ( 3 ) nstar = 1 vstar ( 1 : 3 , nstar ) = v ( 1 : 3 ) symop ( 1 ) = 1 do isym = 1 , nsym vrot (:) = matmul ( s (:,:, isym ), v (:)) do i = 1 , nstar if ( sum ( abs ( vrot (:) - vstar ( 1 : 3 , i ))) < 1 0E-5 ) then goto 1984 end if enddo nstar = nstar + 1 vstar ( 1 : 3 , nstar ) = vrot ( 1 : 3 ) symop ( nstar ) = isym 1984 continue enddo end subroutine calculate_star subroutine echo_symmetry_1BZ ( nk_1 , nk_2 , nk_3 , nk_irr , equiv_ , symlink_ ) !-------------------------------------------------------------------------------- ! simple writing routine, for testing purposes !-------------------------------------------------------------------------------- use intw_useful_constants , only : stdout implicit none integer , intent ( in ) :: nk_1 , nk_2 , nk_3 , nk_irr integer , intent ( in ) :: equiv_ ( nk_1 * nk_2 * nk_3 ) integer , intent ( in ) :: symlink_ ( nk_1 * nk_2 * nk_3 , 2 ) integer :: i , nkr nkr = nk_1 * nk_2 * nk_3 write ( stdout , '(a)' ) '|         ---------------------------------         |' write ( stdout , '(a)' ) '| - Symmetry relations:                             |' write ( stdout , \"('|   nk_irr: ',i4,'                                    |')\" ) nk_irr write ( stdout , '(a)' ) '|    ik       equiv     symlink      TR             |' do i = 1 , nkr write ( stdout , \"('| ',i5,7x,i5,7x,i5,3x,i5,12x,' |')\" ) i , equiv_ ( i ), symlink_ ( i ,:) enddo write ( stdout , '(a)' ) '|         ---------------------------------         |' end subroutine echo_symmetry_1BZ logical function eqvect ( x , y , f ) !----------------------------------------------------------------------- ! use kinds , only : dp implicit none real ( kind = dp ), intent ( in ) :: x ( 3 ), y ( 3 ), f ( 3 ) ! input: input vector ! input: second input vector ! input: fractionary translation real ( kind = dp ), parameter :: accep = 1.0d-4 ! acceptance parameter ! eqvect = abs ( x ( 1 ) - y ( 1 ) - f ( 1 ) - nint ( x ( 1 ) - y ( 1 ) - f ( 1 )) ) . lt . accep . and . & abs ( x ( 2 ) - y ( 2 ) - f ( 2 ) - nint ( x ( 2 ) - y ( 2 ) - f ( 2 )) ) . lt . accep . and . & abs ( x ( 3 ) - y ( 3 ) - f ( 3 ) - nint ( x ( 3 ) - y ( 3 ) - f ( 3 )) ) . lt . accep return end function eqvect subroutine multable ( nsym , s , table ) !-------------------------------------------------------------------- !  sets up the multiplication table for a group represented by 3x3 !  integer matrices and checks that {s} is a group indeed: ! !  table(n,m) = index( s(n)*s(m) ) !-------------------------------------------------------------------- implicit none !I/O variables integer , intent ( in ) :: nsym , s ( 3 , 3 , nsym ) ! number of symmetry+symm matrices integer , intent ( out ) :: table ( nsym , nsym ) ! the multiplication table !local variables integer :: irot , jrot , krot , ipol , jpol , kpol , ss ( 3 , 3 ) ! counter on rotations ! counters on polarizations ! buffer multiplication matrix logical :: found , smn ! if true the table has been set used to check symmetries do irot = 1 , nsym do jrot = 1 , nsym ! do ipol = 1 , 3 do jpol = 1 , 3 ! ss ( ipol , jpol ) = 0 ! do kpol = 1 , 3 ! ss ( ipol , jpol ) = ss ( ipol , jpol ) + & s ( ipol , kpol , jrot ) * s ( kpol , jpol , irot ) ! enddo !kpol ! enddo !jpol enddo !ipol ! ! here checks that the input matrices really form a group ! and sets the multiplication table ! found = . false . ! do krot = 1 , nsym ! smn = . true . ! do ipol = 1 , 3 do jpol = 1 , 3 ! smn = smn . and . ( s ( ipol , jpol , krot ). eq . ss ( ipol , jpol )) ! enddo !jpol enddo !ipol ! if ( smn ) then ! if ( found ) write ( * , * ) 'something wrong in multable:1' ! found = . true . table ( jrot , irot ) = krot ! endif ! enddo !krot enddo !jrot ! if (. not . found ) write ( * , * ) 'something wrong in multable:2' ! enddo !irot ! return end subroutine multable !----------------------------------------------------------------------------! end module intw_symmetries !----------------------------------------------------------------------------!","tags":"","url":"sourcefile/symmetries.f90.html"},{"title":"geometry.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module triFS_geometry !! display: none !! !! This module contains all the necessary variables and subroutines !! related to triangles and tetrahedra for [[triFS]] utility. !! use kinds , only : dp public :: wigner_seitz_cell , plot_poly , polyhedra_off , plot_tetra_off , normal_of_tri , & tetrasym , rot_tetra , compact_tetra , overlap_tetra , overlap_tri , overlap_edge , overlap_face , & overlap_faces_int , equal_tetra , tetraIBZ_2_vert_faces_edges , irr_faces , sort_edges , & write_node_list_face , nodes_on_face_and_rotate_to_plane , triangulate_faces , add_nodes_IBZ_volume private contains subroutine wigner_seitz_cell ( vec , verb ) use intw_utility , only : find_free_unit use intw_matrix_vector , only : ainv , det , norma , cross implicit none logical , intent ( in ) :: verb ! write info file or not real ( dp ), dimension ( 3 , 3 ), intent ( in ) :: vec ! lattice vectors (#vec, comp) integer , parameter :: max_vert = 400 , & max_faces = 100 , & max_ver_inface = 100 !& !real(dp), parameter :: eps1 = 1.0d-09 real ( dp ), parameter :: eps1 = 1.0E-07_dp real ( dp ), dimension ( 4 , 26 ) :: eqplane !equation of plane: ax+by+cz=d; eqplane = (a, b, c, d) real ( dp ), dimension ( 3 , max_vert ) :: vertex !vertices of polihedra (with repetition) integer , dimension ( 3 , max_vert ) :: vert_index ! indices of the 3 planes producing each vertex integer , dimension ( max_faces ) :: dif_plane_list !list of different planes integer , dimension ( max_ver_inface , max_faces ) :: ind_verts_indifplane ! indexes of vertices in each plane before cleaning up integer , dimension ( max_ver_inface , max_faces ) :: ind_verts_indifplane_final ! indexes of vertices in each plane after cleaning up integer , dimension ( max_ver_inface ) :: num_verts_inplane !number of vertices in a plane before cleaning up integer , dimension ( max_ver_inface ) :: num_verts_inplane_final !number of vertices in a plane after cleaning up logical , dimension ( max_ver_inface , max_faces ) :: active ! related to ind_verts_indifplane integer :: num_poi , num_vert , nnplanes , nverplai , nverplai_final , num_plane real ( dp ) :: di , dj , dk , dist1 , dist2 integer :: i , j , k , ii , jj , l , iv , jv , kv , vrtIV , vrtJV , vrtKV real ( dp ) :: mat ( 3 , 3 ), dd ( 3 ), pvert ( 3 ), vector1 ( 3 ), vector2 ( 3 ), normalvector ( 3 ) logical :: isnew , isplane , equalIJ , equalIK , equalJK , areequal integer :: io_unit1 , info_unit ! ------------------------------------------------------ !   vec(i,j) is a 3x3 matrix with the lattice vectors !        i = vector number;  b_i,  i = 1,2,3 !        j = component; j = x,y,z ! ------------------------------------------------------- !-- Check !    print*, 'vec' !    do i = 1, 3 !     write(*, '(a,i1,a,3(1x,f14.8))') 'b', i, ':', ( vec(j,i), j = 1, 3 ) !    end do !-- End check ! --------------------------------------------------------------- !  Definition of the WS cell: !  -Find neighbour points from the origin; 26 points in total !  -Then construct equations of the planes that go through P_0 and are !   perpendicular to OP0, --> OP0·PP0 = 0; (P = x,y,z); P0 = (x0,y0,z0) !  -The plane perpendicular to OP0, passing at half distance between !   0 and P0 is: !      x0.x+y0.y+z0.z = 0.5(x0&#94;2+y0&#94;2+z0&#94;2) !       ax + by + cz = d !      eqplane = (a,b,c,d) ! ----------------------------------------------------------------- io_unit1 = find_free_unit () open ( unit = io_unit1 , file = 'polyhedra.dat' , status = 'unknown' ) if ( verb ) then info_unit = find_free_unit () open ( unit = info_unit , file = 'info_ws.dat' , status = 'unknown' ) end if num_poi = 0 do i = - 1 , 1 do j = - 1 , 1 do k = - 1 , 1 if ( i /= 0 . or . j /= 0 . or . k /= 0 ) then !disregard the origin !di = dble(i) !dj = dble(j) !dk = dble(k) di = i dj = j dk = k num_poi = num_poi + 1 eqplane ( 1 , num_poi ) = di * vec ( 1 , 1 ) + dj * vec ( 2 , 1 ) + dk * vec ( 3 , 1 ) eqplane ( 2 , num_poi ) = di * vec ( 1 , 2 ) + dj * vec ( 2 , 2 ) + dk * vec ( 3 , 2 ) eqplane ( 3 , num_poi ) = di * vec ( 1 , 3 ) + dj * vec ( 2 , 3 ) + dk * vec ( 3 , 3 ) !eqplane(4,num_poi) = 0.5*(norma(eqplane(1:3,num_poi)))**2.0d0 ! JL eqplane ( 4 , num_poi ) = 0.5_dp * ( norma ( eqplane ( 1 : 3 , num_poi ))) ** 2 endif enddo enddo enddo ! Vertices are the intersections of three planes. Check all possibilities ! Solve for X: A X = D ! If det(A) = 0, planes are parallel. There is no intersection. num_vert = 0 do i = 1 , num_poi - 2 mat ( 1 , 1 : 3 ) = eqplane ( 1 : 3 , i ) dd ( 1 ) = eqplane ( 4 , i ) do j = i + 1 , num_poi - 1 mat ( 2 , 1 : 3 ) = eqplane ( 1 : 3 , j ) dd ( 2 ) = eqplane ( 4 , j ) do k = j + 1 , num_poi mat ( 3 , 1 : 3 ) = eqplane ( 1 : 3 , k ) dd ( 3 ) = eqplane ( 4 , k ) ! if ( abs(det(mat)) >= 1.d-13 ) then ! JL if ( abs ( det ( mat )) >= 1.0E-07_dp ) then pvert = matmul ( ainv ( mat ), dd ) ! Check whether vertex is closer to Gamma than ! any other point. If so, it is a new vertex isnew = . true . l = 1 do if ( . not . ( l <= num_poi . and . isnew ) ) exit dist1 = norma ( pvert ) dist2 = norma ( pvert - eqplane ( 1 : 3 , l )) if (( dist1 - dist2 ) > eps1 ) isnew = . false . l = l + 1 end do if ( isnew ) then num_vert = num_vert + 1 vertex ( 1 : 3 , num_vert ) = pvert ( 1 : 3 ) vert_index ( 1 , num_vert ) = i vert_index ( 2 , num_vert ) = j vert_index ( 3 , num_vert ) = k ! --- Check: List of vertices closer to Gamma (with repetition) if ( verb ) then write ( info_unit , \"(i4,3f12.6,3i4)\" ) num_vert , vertex ( 1 : 3 , num_vert ), vert_index ( 1 : 3 , num_vert ) end if ! --- End check end if end if ! det /=0 end do ! k end do ! j end do ! i ! The number of different indexes that appear in vert_index(1:3,:) ! is the total number of planes a polyhedra is made of --nnplanes-- ! The 3 indexes of the first vertex are always new and different nnplanes = 0 do i = 1 , 3 nnplanes = nnplanes + 1 dif_plane_list ( nnplanes ) = vert_index ( i , 1 ) end do do i = 2 , num_vert do j = 1 , 3 isnew = . true . l = 1 do if ( . not . ( isnew . and . l <= nnplanes ) ) exit if ( dif_plane_list ( l ) == vert_index ( j , i ) ) isnew = . false . l = l + 1 end do ! open do if ( isnew ) then nnplanes = nnplanes + 1 dif_plane_list ( nnplanes ) = vert_index ( j , i ) end if end do !j end do !i if ( verb ) then write ( * , '(\"|     Found \",i6,\" possible vertices,               |\")' ) num_vert write ( * , '(\"|     between \",i6,\" different planes               |\")' ) nnplanes write ( info_unit , * ) write ( info_unit , '(a,i6,a,i3,a)' ) 'Found' , num_vert , ' possible vertices, between ' , & nnplanes , ' different planes' write ( info_unit , * ) ! --- Check: List of different planes do i = 1 , nnplanes write ( info_unit , * ) i , dif_plane_list ( i ) end do ! --- End check end if ! Vertices which have one of the three indexes in common belong to the same plane. ! But these vertices might be identical or collinear. ! Find first all vertices belonging to each plane. Then remove repetitions and collinear ! points. active = . false . num_plane = 0 do i = 1 , nnplanes isplane = . true . !Relate each vertex with the list of different planes nverplai = 0 do j = 1 , num_vert do jj = 1 , 3 if ( vert_index ( jj , j ) == dif_plane_list ( i ) ) then !vertex j belongs to plane i nverplai = nverplai + 1 ind_verts_indifplane ( nverplai , i ) = j active ( nverplai , i ) = . true . end if end do !jj end do ! j num_verts_inplane ( i ) = nverplai ! --- Check: Vertices in each plane if ( verb ) then write ( info_unit , * ) write ( info_unit , '(a,2i4)' ) 'Plane #' , i , num_verts_inplane ( i ) write ( info_unit , '(100i4)' ) ( ind_verts_indifplane ( ii , i ), ii = 1 , num_verts_inplane ( i ) ) end if ! --- End check ! If total number of vertices in plane < 3, it is not a plane if ( num_verts_inplane ( i ) < 3 ) isplane = . false . ! Otherwise remove collinear points and identical points if ( isplane ) then do iv = 1 , num_verts_inplane ( i ) - 2 if ( active ( iv , i )) then do jv = iv + 1 , num_verts_inplane ( i ) - 1 if ( active ( jv , i )) then do kv = jv + 1 , num_verts_inplane ( i ) if ( active ( kv , i )) then vrtIV = ind_verts_indifplane ( iv , i ) vrtJV = ind_verts_indifplane ( jv , i ) vrtKV = ind_verts_indifplane ( kv , i ) !remove identical points equalIJ = norma ( vertex (:, vrtIV ) - vertex (:, vrtJV ) ) <= eps1 equalIK = norma ( vertex (:, vrtIV ) - vertex (:, vrtKV ) ) <= eps1 equalJK = norma ( vertex (:, vrtJV ) - vertex (:, vrtKV ) ) <= eps1 areequal = . true . if ( equalIJ . and . equalIK ) then ! Three vertices are identical. ! Keep the one with the largest index iv < jv < kv active ( iv , i ) = . false . active ( jv , i ) = . false . else if ( equalIJ ) then active ( iv , i ) = . false . else if ( equalIK ) then active ( iv , i ) = . false . else if ( equalJK ) then active ( jv , i ) = . false . else areequal = . false . end if ! ! if ( . not . areequal ) then vector1 = vertex (:, vrtJV ) - vertex (:, vrtIV ) vector2 = vertex (:, vrtKV ) - vertex (:, vrtIV ) normalvector = cross ( vector1 , vector2 ) if ( norma ( normalvector ) < eps1 ) then ! vertices are collinear if ( verb ) write ( info_unit , * ) ' are collinear' write ( * , * ) 'Found collinear vertices. Stopping ' if ( verb ) write ( info_unit , * ) 'Found collinear vertices. Stopping ' STOP ! Skip this for the moment. It looks this can not happen end if !if (norma(normalvector) < eps1) end if ! not areequal ! ! end if ! active kv end do ! kv end if ! active jv end do ! jv end if ! active iv end do ! iv !Store all active vertices in plane i (after repetitions removed) if ( verb ) write ( info_unit , * ) 'Vertices without repetition' nverplai_final = 0 do iv = 1 , num_verts_inplane ( i ) if ( active ( iv , i )) then nverplai_final = nverplai_final + 1 ind_verts_indifplane_final ( nverplai_final , i ) = ind_verts_indifplane ( iv , i ) num_verts_inplane_final ( i ) = nverplai_final if ( verb ) write ( info_unit , '(2i4,3f12.8)' ) nverplai_final , ind_verts_indifplane_final ( nverplai_final , i ), & ( vertex ( j , ind_verts_indifplane_final ( nverplai_final , i )), j = 1 , 3 ) end if end do ! iv if ( nverplai_final <= 2 . and . verb ) write ( info_unit , * ) '------THIS IS NOT A FACE!' if ( nverplai_final > 2 ) then ! Write raw file (vertices might not be in order) if ( verb ) write ( info_unit , * ) '......... THIS IS A FACE!' num_plane = num_plane + 1 write ( io_unit1 , * ) num_plane , nverplai_final do ii = 1 , nverplai_final write ( io_unit1 , \"(3(x,f18.15))\" ) ( vertex ( j , ind_verts_indifplane_final ( ii , i )), j = 1 , 3 ) end do end if end if ! isplane ! Write raw file (vertices might not be in order) !if ( isplane .and. (nverplai_final>2) ) then ! write(info_unit, *) '......... THIS IS A FACE!' !  num_plane = num_plane +1 !  write(io_unit1, *) num_plane, nverplai_final !  do ii = 1, nverplai_final !   write(io_unit1, \"(3(x,f18.15))\") ( vertex(j,ind_verts_indifplane_final(ii,i)), j = 1, 3 ) !  end do ! end if end do ! i (list of diferent planes) close ( io_unit1 ) if ( verb ) then write ( * , '(\"|     The BZ has \",i4,\" outer faces                   |\")' ) num_plane write ( info_unit , * ) write ( info_unit , '(a, i4,a)' ) 'The BZ has ' , num_plane , \" outer faces\" write ( info_unit , * ) 'WS done' close ( info_unit ) end if end subroutine wigner_seitz_cell subroutine plot_poly () use intw_utility , only : find_free_unit , hpsort_real use intw_matrix_vector , only : norma implicit none integer , parameter :: nv_max = 200 , npl_max = 30 real ( dp ) :: vp ( 1 : 3 , nv_max , npl_max ), dist ( nv_max ) integer :: io_unit1 , io_unit2 , dummy , nvp ( npl_max ), ierr , ind ( nv_max ) integer :: vp_dif_index ( nv_max , npl_max ) integer :: ndif , npl , nn real ( dp ) :: vp_dif ( 1 : 3 , nv_max ), vnew ( 1 : 3 ) integer :: i , j , k logical :: done ( nv_max , nv_max ) done = . false . io_unit1 = find_free_unit () open ( io_unit1 , file = \"polyhedra.dat\" , status = \"unknown\" ) io_unit2 = find_free_unit () open ( io_unit2 , file = \"polyplot.dat\" , status = \"unknown\" ) npl = 0 do read ( unit = io_unit1 , fmt =* , iostat = ierr ) dummy , nn if ( ierr /= 0 ) exit npl = npl + 1 nvp ( npl ) = nn do i = 1 , nvp ( npl ) !each plane read ( io_unit1 , * ) ( vp ( j , i , npl ), j = 1 , 3 ) enddo enddo ndif = 1 vp_dif ( 1 : 3 , 1 ) = vp ( 1 : 3 , 1 , 1 ) do i = 1 , npl do j = 1 , nvp ( i ) ! vnew (:) = vp (:, j , i ) do k = 1 , ndif if ( sum ( abs ( vnew - vp_dif ( 1 : 3 , k ))) < 1.0E-7 ) then vp_dif_index ( j , i ) = k cycle endif enddo ! ndif = ndif + 1 vp_dif ( 1 : 3 , ndif ) = vnew ( 1 : 3 ) vp_dif_index ( j , i ) = ndif ! enddo enddo do i = 1 , npl do j = 1 , nvp ( i ) do k = 1 , nvp ( i ) dist ( k ) = norma ( vp (:, j , i ) - vp (:, k , i )) enddo call hpsort_real ( nvp ( i ), dist ( 1 : nvp ( i )), ind ) do k = 2 , 3 ! if ( .not.done(vp_dif_index(ind(k),i),vp_dif_index(k,i)) ) then write ( io_unit2 , \"(100f12.6)\" ) vp (:, j , i ), vp (:, ind ( k ), i ) ! matmul(bg, vp(:,j,i)), matmul(bg, vp(:,ind(k),i)) done ( vp_dif_index ( ind ( k ), i ), vp_dif_index ( k , i )) = . true . done ( vp_dif_index ( k , i ), vp_dif_index ( ind ( k ), i )) = . true . ! endif enddo enddo enddo close ( unit = io_unit1 ) close ( unit = io_unit2 ) end subroutine plot_poly subroutine polyhedra_off () use intw_utility , only : find_free_unit use intw_matrix_vector , only : norma implicit none integer :: nvp ( 100 ) integer :: i , j , k , l , iface , ierr real ( dp ) :: vlist ( 1 : 3 , 10000 ), v ( 1 : 3 ), vaux ( 1 : 3 ), dist2 , dist , vvp ( 1 : 3 , 1000 ) real ( dp ) :: vec1 ( 3 ), vec2 ( 3 ), alpha , alpha2 integer :: nv integer , dimension ( 100 , 100 ) :: ind integer :: io_unit io_unit = find_free_unit () open ( io_unit , file = \"polyhedra.dat\" , status = \"unknown\" ) k = 0 nv = 0 ind = 0 do read ( unit = io_unit , fmt =* , iostat = ierr ) iface , nvp ( iface ) if ( ierr /= 0 ) exit do i = 1 , nvp ( iface ) read ( io_unit , * ) ( vvp ( j , i ), j = 1 , 3 ) end do l = 1 do if ( l == nvp ( iface )) exit if ( l == 1 ) then ! Find neighbour vertex to 1 and assign as second vertex !dist = huge(dist) alpha = 0.0_dp vec1 (:) = vvp (:, 2 ) - vvp (:, l ) do i = 3 , nvp ( iface ) !dist2 = norma(vvp(:,i)-vvp(:,l)) !if (dist2<=dist) then !  dist = dist2 !  j = i !  vaux(:) = vvp(:,i) !end if vec2 (:) = vvp (:, i ) - vvp (:, l ) alpha2 = acos ( dot_product ( vec2 , vec1 ) / ( norma ( vec2 ) * norma ( vec1 ) + 1.0E-07_dp ) ) !print*, alpha, alpha2 if ( alpha2 > alpha ) then alpha = alpha2 j = i vaux (:) = vvp (:, i ) end if end do vvp (:, j ) = vvp (:, 2 ) vvp (:, 2 ) = vaux (:) l = l + 1 else ! Find next vertex by looking for smallest angle w/r vector joining previous vertices alpha = 2.0_dp * acos ( - 1.0_dp ) vec1 (:) = vvp (:, l ) - vvp (:, l - 1 ) do i = l + 1 , nvp ( iface ) vec2 (:) = vvp (:, i ) - vvp (:, l ) alpha2 = acos ( dot_product ( vec2 , vec1 ) / ( norma ( vec2 ) * norma ( vec1 ) + 1.0E-07_dp ) ) !print*, alpha, alpha2 if ( alpha2 < alpha ) then alpha = alpha2 j = i vaux (:) = vvp (:, i ) end if end do vvp (:, j ) = vvp (:, l + 1 ) vvp (:, l + 1 ) = vaux (:) l = l + 1 end if end do i_loop : do i = 1 , nvp ( iface ) !each plane k = k + 1 !read(io_unit, *) ( v(j), j = 1, 3 ) v (:) = vvp (:, i ) if ( nv == 0 ) then nv = nv + 1 vlist (:, nv ) = v (:) ind ( iface , i ) = nv else do j = 1 , nv if (( sum ( abs ( v (:) - vlist (:, j )))) < 1.0E-7_dp ) then ind ( iface , i ) = j cycle i_loop end if end do nv = nv + 1 vlist (:, nv ) = v (:) ind ( iface , i ) = nv end if enddo i_loop enddo close ( unit = io_unit ) io_unit = find_free_unit () open ( io_unit , file = \"polyhedra.off\" , status = \"unknown\" ) write ( unit = io_unit , fmt = \"(a)\" ) \"OFF\" write ( unit = io_unit , fmt = \"(3i6)\" ) nv , iface , 0 write ( unit = io_unit , fmt =* ) do i = 1 , nv write ( unit = io_unit , fmt = \"(3f18.10)\" ) vlist (:, i ) end do do i = 1 , iface write ( unit = io_unit , fmt = \"(100I6)\" ) nvp ( i ), ( ind ( i , j ) - 1 , j = 1 , nvp ( i ) ) end do close ( io_unit ) end subroutine polyhedra_off subroutine plot_tetra_off ( tag_in , num_tetra , vertx_tetra , plot_surface ) use intw_utility , only : find_free_unit use intw_matrix_vector , only : norma implicit none character ( len = 25 ), intent ( in ) :: tag_in integer , intent ( in ) :: num_tetra ! Number of tetrahedra to be plotted real ( dp ), dimension ( 1 : 3 , 1 : 4 , num_tetra ), intent ( in ) :: vertx_tetra ! Coordinates of the four vertex of the tetrahedra logical , intent ( in ) :: plot_surface ! .true. if extra file is to be written with only the surface triangles ! local variables integer :: i , j , k , l , nv , indx ( 2000 ), io_unit , io_unit2 real ( dp ) :: vlist ( 1 : 3 , 2000 ) l = 0 nv = 0 do i = 1 , num_tetra j_loop : do j = 1 , 4 l = l + 1 !write(unit=io_unit, fmt='(3f12.6)') ( vertx_tetra(k,j,i), k = 1, 3 ) if ( nv == 0 ) then nv = nv + 1 vlist (:, nv ) = vertx_tetra (:, j , i ) indx ( l ) = nv ! vertex index cycle j_loop end if do k = 1 , nv if ( norma ( vertx_tetra (:, j , i ) - vlist (:, k )) < 1 0E-6 ) then ! check if vertex already stored indx ( l ) = k cycle j_loop end if end do nv = nv + 1 vlist (:, nv ) = vertx_tetra (:, j , i ) indx ( l ) = nv end do j_loop end do io_unit = find_free_unit () open ( unit = io_unit , file = TRIM ( tag_in ), status = \"unknown\" ) write ( unit = io_unit , fmt = \"(a)\" ) \"OFF\" write ( unit = io_unit , fmt = \"(3I6)\" ) nv , 4 * num_tetra , 0 write ( unit = io_unit , fmt =* ) if ( plot_surface ) then io_unit2 = find_free_unit () open ( unit = io_unit2 , file = \"faces_BZ.off\" , status = \"unknown\" ) write ( unit = io_unit2 , fmt = \"(a)\" ) \"OFF\" write ( unit = io_unit2 , fmt = \"(3I6)\" ) nv , num_tetra , 0 write ( unit = io_unit2 , fmt =* ) end if ! Vertices of tetrahedra do i = 1 , nv write ( unit = io_unit , fmt = \"(3f12.6)\" ) ( vlist ( j , i ), j = 1 , 3 ) if ( plot_surface ) write ( unit = io_unit2 , fmt = \"(3f12.6)\" ) ( vlist ( j , i ), j = 1 , 3 ) end do ! Triangular faces of tetrahedra l = 1 do i = 1 , num_tetra write ( unit = io_unit , fmt = \"(4I6)\" ) 3 , indx ( l ) - 1 , indx ( l + 2 ) - 1 , indx ( l + 1 ) - 1 write ( unit = io_unit , fmt = \"(4I6)\" ) 3 , indx ( l ) - 1 , indx ( l + 3 ) - 1 , indx ( l + 1 ) - 1 write ( unit = io_unit , fmt = \"(4I6)\" ) 3 , indx ( l ) - 1 , indx ( l + 2 ) - 1 , indx ( l + 3 ) - 1 write ( unit = io_unit , fmt = \"(4I6)\" ) 3 , indx ( l + 1 ) - 1 , indx ( l + 2 ) - 1 , indx ( l + 3 ) - 1 if ( plot_surface ) write ( unit = io_unit2 , fmt = \"(4I6)\" ) 3 , indx ( l + 1 ) - 1 , indx ( l + 2 ) - 1 , indx ( l + 3 ) - 1 l = l + 4 end do close ( unit = io_unit ) if ( plot_surface ) close ( io_unit2 ) end subroutine plot_tetra_off function normal_of_tri ( vertices ) use intw_matrix_vector , only : norma , cross implicit none real ( dp ), dimension ( 1 : 3 , 1 : 3 ), intent ( in ) :: vertices real ( dp ), dimension ( 1 : 3 ) :: normal_of_tri real ( dp ), dimension ( 1 : 3 ) :: v1 , v2 v1 = vertices ( 1 : 3 , 2 ) - vertices ( 1 : 3 , 1 ) v2 = vertices ( 1 : 3 , 3 ) - vertices ( 1 : 3 , 1 ) normal_of_tri = cross ( v2 , v1 ) / norma ( cross ( v2 , v1 )) end function normal_of_tri subroutine tetrasym ( bcell , nsym , s , TR_sym , nt_max , n_b_tetra_all , b_tetra_all , n_b_tetra_irr , b_tetra_irr , tetra_equiv , tetra_symlink ) ! Subroutine that divides the BZ in tetrahedra, and finds the irreducible ones. use intw_utility , only : find_free_unit use intw_matrix_vector , only : cross implicit none real ( dp ), intent ( in ) :: bcell ( 1 : 3 , 1 : 3 ) integer , intent ( in ) :: nsym integer , intent ( in ) :: s ( 1 : 3 , 1 : 3 , nsym ) logical , intent ( in ) :: TR_sym integer , intent ( in ) :: nt_max real ( dp ), intent ( out ) :: b_tetra_all ( 1 : 3 , 1 : 4 , nt_max ) integer , intent ( out ) :: n_b_tetra_all real ( dp ), intent ( out ) :: b_tetra_irr ( 1 : 3 , 1 : 4 , nt_max ) integer , intent ( out ) :: n_b_tetra_irr , tetra_equiv ( nt_max ), tetra_symlink ( nt_max , 1 : 2 ) real ( dp ) :: b_tetra_aux ( 1 : 3 , 1 : 4 , nt_max ) integer :: n_b_tetra_aux real ( dp ) :: new_t ( 1 : 3 , 1 : 4 ), centre ( 1 : 3 , 24 ) integer :: nvert , nfaces , nedges , iface integer :: i , j , i_sym , it , jt , iv real ( dp ), dimension (:,:), allocatable :: vcoord integer , dimension (:,:), allocatable :: vindex integer , dimension (:), allocatable :: nvp real ( dp ) :: tirr_vol , t_vol , t1 ( 3 ), t2 ( 3 ), t3 ( 3 ) logical :: t_done ( nt_max ) integer :: io_unit t_done = . false . !--------------------------------------------------------------- ! Read BZ polyhedra from file !--------------------------------------------------------------- io_unit = find_free_unit () !open(io_unit, file=\"polyhedra.dat\", status=\"unknown\") open ( io_unit , file = \"polyhedra.off\" , status = \"unknown\" ) read ( unit = io_unit , fmt =* ) read ( unit = io_unit , fmt = '(3I6)' ) nvert , nfaces , nedges read ( unit = io_unit , fmt =* ) allocate ( vcoord ( 1 : 3 , 1 : nvert )) allocate ( vindex ( 1 : 24 , nfaces )) allocate ( nvp ( nfaces )) n_b_tetra_all = 0 do iv = 1 , nvert read ( unit = io_unit , fmt = \"(3f18.10)\" ) vcoord (:, iv ) end do do iface = 1 , nfaces read ( unit = io_unit , fmt = \"(100I6)\" ) nvp ( iface ), ( vindex ( j , iface ), j = 1 , nvp ( iface ) ) end do ! Make index go from 1 to nvert vindex = vindex + 1 !--------------------------------------------------------------- ! Divide the BZ polyhedron in tetrahedra !--------------------------------------------------------------- centre = 0.0_dp f_loop : do iface = 1 , nfaces !each plane do iv = 1 , nvp ( iface ) centre ( 1 : 3 , iface ) = centre ( 1 : 3 , iface ) + vcoord ( 1 : 3 , vindex ( iv , iface )) end do centre ( 1 : 3 , iface ) = centre ( 1 : 3 , iface ) / nvp ( iface ) ! center of each plane do iv = 1 , nvp ( iface ) do j = 1 , 2 n_b_tetra_all = n_b_tetra_all + 1 tetra_equiv ( n_b_tetra_all ) = - 1 ! n_b_tetra_all                             ! Initialize equivalence tetra_symlink ( n_b_tetra_all , 1 ) = 1 tetra_symlink ( n_b_tetra_all , 2 ) = 0 b_tetra_all ( 1 : 3 , 1 , n_b_tetra_all ) = ( / 0.0d0 , 0.0d0 , 0.0d0 / ) b_tetra_all ( 1 : 3 , 2 , n_b_tetra_all ) = centre ( 1 : 3 , iface ) if ( iv == 1 . and . j == 1 ) then ! special case for first vertex b_tetra_all ( 1 : 3 , 3 , n_b_tetra_all ) = ( vcoord ( 1 : 3 , vindex ( 1 , iface )) + vcoord ( 1 : 3 , vindex ( nvp ( iface ), iface )) ) / 2.0_dp b_tetra_all ( 1 : 3 , 4 , n_b_tetra_all ) = vcoord ( 1 : 3 , vindex ( 1 , iface )) else if ( iv == nvp ( iface ) . and . j == 2 ) then ! special case for last vertex b_tetra_all ( 1 : 3 , 3 , n_b_tetra_all ) = vcoord ( 1 : 3 , vindex ( nvp ( iface ), iface )) b_tetra_all ( 1 : 3 , 4 , n_b_tetra_all ) = ( vcoord ( 1 : 3 , vindex ( 1 , iface )) + vcoord ( 1 : 3 , vindex ( nvp ( iface ), iface )) ) / 2.0_dp else if ( iv /= 1 . and . j == 1 ) then b_tetra_all ( 1 : 3 , 3 , n_b_tetra_all ) = ( vcoord ( 1 : 3 , vindex ( iv , iface )) + vcoord ( 1 : 3 , vindex ( iv - 1 , iface )) ) / 2.0_dp b_tetra_all ( 1 : 3 , 4 , n_b_tetra_all ) = vcoord ( 1 : 3 , vindex ( iv , iface )) else if ( iv /= nvp ( iface ) . and . j == 2 ) then b_tetra_all ( 1 : 3 , 3 , n_b_tetra_all ) = vcoord ( 1 : 3 , vindex ( iv , iface )) b_tetra_all ( 1 : 3 , 4 , n_b_tetra_all ) = ( vcoord ( 1 : 3 , vindex ( iv , iface )) + vcoord ( 1 : 3 , vindex ( iv + 1 , iface )) ) / 2.0_dp end if end do ! j end do ! iv enddo f_loop !planes close ( io_unit ) deallocate ( vcoord , vindex , nvp ) ! Filter and eliminate equal t n_b_tetra_aux = n_b_tetra_all b_tetra_aux = b_tetra_all n_b_tetra_all = 0 b_tetra_all = 0 aux_loop : do it = 1 , n_b_tetra_aux do i = 1 , 4 new_t ( 1 : 3 , i ) = b_tetra_aux ( 1 : 3 , i , it ) end do do jt = 1 , n_b_tetra_all if ( equal_tetra ( new_t , b_tetra_all ( 1 : 3 , 1 : 4 , jt ))) then cycle aux_loop endif end do n_b_tetra_all = n_b_tetra_all + 1 do i = 1 , 4 b_tetra_all ( 1 : 3 , i , n_b_tetra_all ) = new_t ( 1 : 3 , i ) end do end do aux_loop !--------------------------------------------------------------- ! Find irreducible tetrahedra sampling of the BZ (find the IBZ) !--------------------------------------------------------------- n_b_tetra_irr = 1 do i = 1 , 4 b_tetra_irr ( 1 : 3 , i , 1 ) = b_tetra_all ( 1 : 3 , i , 1 ) enddo tetra_equiv ( 1 ) = 1 tetra_symlink ( 1 , 1 ) = 1 tetra_symlink ( 1 , 2 ) = 0 ! it_loop : do it = 2 , n_b_tetra_all do i = 1 , 4 new_t ( 1 : 3 , i ) = b_tetra_all ( 1 : 3 , i , it ) enddo do i = 1 , n_b_tetra_irr do i_sym = 1 , nsym if ( equal_tetra ( new_t ( 1 : 3 , 1 : 4 ), rot_tetra ( bcell , s (:,:, i_sym ), b_tetra_irr ( 1 : 3 , 1 : 4 , i )) ) ) then tetra_symlink ( it , 1 ) = i_sym tetra_symlink ( it , 2 ) = 0 ! tetra_equiv ( it ) = i cycle it_loop end if end do !TR_symmetry do i_sym = 1 , nsym if ( TR_sym . and . ( equal_tetra ( - new_t ( 1 : 3 , 1 : 4 ), rot_tetra ( bcell , s (:,:, i_sym ), b_tetra_irr ( 1 : 3 , 1 : 4 , i )) )) ) then tetra_symlink ( it , 1 ) = i_sym tetra_symlink ( it , 2 ) = 1 ! tetra_equiv ( it ) = i cycle it_loop end if end do end do n_b_tetra_irr = n_b_tetra_irr + 1 tetra_equiv ( it ) = n_b_tetra_irr tetra_symlink ( it , 1 ) = 1 tetra_symlink ( it , 2 ) = 0 ! do i = 1 , 4 b_tetra_irr ( 1 : 3 , i , n_b_tetra_irr ) = new_t ( 1 : 3 , i ) end do end do it_loop ! Compute volume of IBZ and BZ tirr_vol = 0.0_dp do it = 1 , n_b_tetra_irr t1 (:) = b_tetra_irr (:, 2 , it ) - b_tetra_irr (:, 1 , it ) t2 (:) = b_tetra_irr (:, 3 , it ) - b_tetra_irr (:, 1 , it ) t3 (:) = b_tetra_irr (:, 4 , it ) - b_tetra_irr (:, 1 , it ) tirr_vol = tirr_vol + abs ( dot_product ( t1 , cross ( t2 , t3 ))) / 6.0_dp end do write ( * , '(A34,F16.10,2X,A1)' ) '|   Volume of IBZ (2pi/alat)**3 = ' , tirr_vol , '|' ! Compute volume of IBZ t_vol = 0.0_dp do it = 1 , n_b_tetra_all t1 (:) = b_tetra_all (:, 2 , it ) - b_tetra_all (:, 1 , it ) t2 (:) = b_tetra_all (:, 3 , it ) - b_tetra_all (:, 1 , it ) t3 (:) = b_tetra_all (:, 4 , it ) - b_tetra_all (:, 1 , it ) t_vol = t_vol + abs ( dot_product ( t1 , cross ( t2 , t3 ))) / 6.0_dp end do write ( * , '(A34,F16.10,2X,A1)' ) '|   Volume of BZ (2pi/alat)**3 =  ' , t_vol , '|' write ( * , '(A34,F16.10,2X,A1)' ) '|   BZ volume / IBZ volume =      ' , t_vol / tirr_vol , '|' !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ! Modification to test compact_tetra i = 0 do it = 1 , n_b_tetra_all if ( i == n_b_tetra_irr ) exit if ( tetra_symlink ( it , 1 ) /= 1 ) then b_tetra_irr ( 1 : 3 , 1 : 4 , tetra_equiv ( it )) = b_tetra_all ( 1 : 3 , 1 : 4 , it ) i = i + 1 end if end do !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! end subroutine tetrasym function rot_tetra ( bcell , symop , t ) use intw_matrix_vector , only : ainv implicit none real ( dp ), intent ( in ) :: bcell ( 1 : 3 , 1 : 3 ) integer , intent ( in ) :: symop ( 3 , 3 ) real ( dp ), intent ( in ) :: t ( 1 : 3 , 1 : 4 ) real ( dp ) :: v ( 1 : 3 ) real ( dp ) :: rot_tetra ( 1 : 3 , 1 : 4 ), bcelli ( 3 , 3 ) integer :: i bcelli = ainv ( bcell ) do i = 1 , 4 v = matmul ( bcelli , t (:, i )) rot_tetra ( 1 : 3 , i ) = matmul ( bcell , matmul ( dble ( symop (:,:)), v )) ! rot_tetra(1:3,i) = matmul(s_cart(:,:,i_sym), t(:,i)) end do end function rot_tetra subroutine compact_tetra ( bcell , nsym , s , TR_sym , nt_max , n_b_tetra_irr , b_tetra_irr , n_b_tetra_all , b_tetra_all , tetra_equiv , tetra_symlink ) implicit none real ( dp ), intent ( in ) :: bcell ( 1 : 3 , 1 : 3 ) integer , intent ( in ) :: nsym integer , intent ( in ) :: s ( 1 : 3 , 1 : 3 , nsym ) logical , intent ( in ) :: TR_sym integer , intent ( in ) :: nt_max , n_b_tetra_irr , n_b_tetra_all real ( dp ), intent ( inout ) :: b_tetra_irr ( 1 : 3 , 1 : 4 , nt_max ), b_tetra_all ( 1 : 3 , 1 : 4 , nt_max ) integer , intent ( inout ) :: tetra_equiv ( nt_max ), tetra_symlink ( nt_max , 1 : 2 ) !local integer :: i , j , i_sym , nbt real ( dp ) :: b_tetra_irr_l ( 1 : 3 , 1 : 4 , nt_max ) integer :: tetra_equiv_l ( nt_max ), tetra_symlink_l ( nt_max , 1 : 2 ) integer :: overlap ( nsym , 2 ) real ( dp ) :: t1 ( 3 , 4 ), t2 ( 3 , 4 ) integer :: maxindex ( 2 ), it b_tetra_irr_l = b_tetra_irr tetra_equiv_l = tetra_equiv tetra_symlink_l = tetra_symlink nbt = 1 ! We will not move the first one and we count it is already done b_tetra_irr ( 1 : 3 , 1 : 4 , 1 ) = b_tetra_irr_l ( 1 : 3 , 1 : 4 , 1 ) ! b_tetra_irr will be the rotated one in return do i = 2 , n_b_tetra_irr overlap (:, 1 ) = 0 do i_sym = 1 , nsym t1 = rot_tetra ( bcell , s (:,:, i_sym ), b_tetra_irr_l ( 1 : 3 , 1 : 4 , i )) ! b_tetra_irr_l before rotation do j = 1 , nbt t2 = b_tetra_irr ( 1 : 3 , 1 : 4 , j ) ! b_tetra_irr rotated overlap ( i_sym , 1 ) = overlap ( i_sym , 1 ) + overlap_tetra ( t1 , t2 ) enddo enddo if ( TR_sym ) then overlap (:, 2 ) = 0 do i_sym = 1 , nsym t1 = rot_tetra ( bcell , s (:,:, i_sym ), b_tetra_irr ( 1 : 3 , 1 : 4 , i )) do j = 1 , nbt t2 = b_tetra_irr_l ( 1 : 3 , 1 : 4 , j ) overlap ( i_sym , 2 ) = overlap ( i_sym , 2 ) + overlap_tetra ( t1 , t2 ) enddo enddo end if maxindex = maxloc ( overlap ) nbt = nbt + 1 if ( maxindex ( 2 ) == 1 ) then i_sym = maxindex ( 1 ) b_tetra_irr ( 1 : 3 , 1 : 4 , nbt ) = rot_tetra ( bcell , s (:,:, i_sym ), b_tetra_irr_l ( 1 : 3 , 1 : 4 , i )) else if ( maxindex ( 2 ) == 2 ) then i_sym = maxindex ( 1 ) b_tetra_irr ( 1 : 3 , 1 : 4 , nbt ) = - rot_tetra ( bcell , s (:,:, i_sym ), b_tetra_irr_l ( 1 : 3 , 1 : 4 , i )) end if enddo !i ! Update tetra_equiv and tetra_symlink it_loop : do it = 1 , n_b_tetra_all do i = 1 , 4 t1 ( 1 : 3 , i ) = b_tetra_all ( 1 : 3 , i , it ) enddo do i = 1 , n_b_tetra_irr do i_sym = 1 , nsym if ( equal_tetra ( t1 ( 1 : 3 , 1 : 4 ), rot_tetra ( bcell , s (:,:, i_sym ), b_tetra_irr ( 1 : 3 , 1 : 4 , i )) ) ) then tetra_symlink ( it , 1 ) = i_sym tetra_symlink ( it , 2 ) = 0 ! tetra_equiv ( it ) = i cycle it_loop end if if ( TR_sym . and .( equal_tetra ( - t1 ( 1 : 3 , 1 : 4 ), rot_tetra ( bcell , s (:,:, i_sym ), b_tetra_irr ( 1 : 3 , 1 : 4 , i )) )) ) then tetra_symlink ( it , 1 ) = i_sym tetra_symlink ( it , 2 ) = 1 ! tetra_equiv ( it ) = i cycle it_loop end if end do end do end do it_loop end subroutine compact_tetra function overlap_tetra ( t1 , t2 ) implicit none real ( dp ) :: t1 ( 1 : 3 , 1 : 4 ) real ( dp ) :: t2 ( 1 : 3 , 1 : 4 ) integer :: overlap_tetra integer :: i , j overlap_tetra = 0 do i = 1 , 4 do j = 1 , 4 if ( sum ( abs ( t1 (:, i ) - t2 (:, j ))) < 1.0E-4_dp ) overlap_tetra = overlap_tetra + 1 enddo enddo end function overlap_tetra function overlap_tri ( t1 , t2 ) implicit none integer , dimension ( 1 : 3 ), intent ( in ) :: t1 , t2 integer :: overlap_tri integer :: i , j if (( size ( t1 ) > 3 ). or .( size ( t2 ) > 3 )) then write ( unit =* , fmt =* ) \"ERROR (overlap_tri). Input are not triangles.\" , size ( t1 ), size ( t2 ) stop endif overlap_tri = 0 do i = 1 , size ( t1 ) do j = 1 , size ( t2 ) if ( t1 ( i ) == t2 ( j )) then overlap_tri = overlap_tri + 1 endif enddo enddo end function overlap_tri function overlap_edge ( e1 , e2 ) implicit none integer , intent ( in ) :: e1 ( 1 : 2 ), e2 ( 1 : 2 ) integer :: overlap_edge integer :: i , j overlap_edge = 0 do i = 1 , 2 do j = 1 , 2 if ( abs ( e1 ( i ) - e2 ( j )) < 1.0E-4_dp ) overlap_edge = overlap_edge + 1 enddo enddo end function overlap_edge function overlap_face ( f1 , f2 ) use intw_matrix_vector , only : norma implicit none real ( dp ), intent ( in ) :: f1 ( 1 : 3 , 1 : 3 ), f2 ( 1 : 3 , 1 : 3 ) integer :: overlap_face integer :: iv , jv overlap_face = 0 do iv = 1 , 3 do jv = 1 , 3 if ( norma ( f1 (:, iv ) - f2 (:, jv )) < 1.0E-6_dp ) overlap_face = overlap_face + 1 enddo enddo end function overlap_face function overlap_faces_int ( f1 , f2 ) implicit none integer , intent ( in ) :: f1 ( 1 : 3 ), f2 ( 1 : 3 ) integer :: overlap_faces_int integer :: iv , jv overlap_faces_int = 0 do iv = 1 , 3 do jv = 1 , 3 if ( abs ( f1 ( iv ) - f2 ( jv )) < 1.0E-6_dp ) overlap_faces_int = overlap_faces_int + 1 enddo enddo end function overlap_faces_int function equal_tetra ( t1 , t2 ) implicit none real ( dp ) :: t1 ( 1 : 3 , 1 : 4 ) real ( dp ) :: t2 ( 1 : 3 , 1 : 4 ) logical :: equal_tetra integer :: i , j , c equal_tetra = . false . c = 0 do i = 1 , 4 do j = 1 , 4 if ( sum ( abs ( t1 (:, i ) - t2 (:, j ))) < 1.0E-5_dp ) c = c + 1 enddo enddo if ( c == 4 ) then equal_tetra = . true . endif end function equal_tetra subroutine tetraIBZ_2_vert_faces_edges ( num_tetra , vertx_tetra , verb , nv , nf , ne , vlist , face_as_vert , edge ) use intw_utility , only : find_free_unit use intw_matrix_vector , only : norma implicit none integer , intent ( in ) :: num_tetra ! Number of tetrahedra on the IBZ real ( dp ), intent ( in ) :: vertx_tetra ( 1 : 3 , 1 : 4 , num_tetra ) ! Coordinates of the four vertex of each tetrahedra logical , intent ( in ) :: verb ! Output info files or not integer , intent ( out ) :: nv , nf , ne ! Number of vertices, edges and faces real ( dp ), intent ( out ) :: vlist ( 1 : 3 , 4 * num_tetra ) ! List of non-repeated vertices integer , intent ( out ) :: face_as_vert ( 1 : 3 , 4 * num_tetra ) ! List of non-repeated faces (not reduced by S+G symmetry yet) integer , intent ( out ) :: edge ( 1 : 2 , 6 * num_tetra ) ! List of non-repeated edges ! local variables integer :: i , j , k , l , e , f , ex , te , tf , fx , fx2 integer :: io_unit , io_unit2 , io_unit3 integer :: indx ( 4 * num_tetra ), edge_aux ( 1 : 2 , 1 : 6 ), edge_indx ( 6 * num_tetra ), face_aux ( 1 : 3 , 1 : 4 ), face_indx ( 4 * num_tetra ) ! Detect non-repeated vertices l = 0 nv = 0 do i = 1 , num_tetra j_loop : do j = 1 , 4 l = l + 1 ! counter tetra+vertex !write(unit=io_unit, fmt='(3f12.6)') ( vertx_tetra(k,j,i), k = 1, 3 ) if ( nv == 0 ) then nv = nv + 1 vlist (:, nv ) = vertx_tetra (:, j , i ) indx ( l ) = nv ! vertex index cycle j_loop end if do k = 1 , nv if ( norma ( vertx_tetra (:, j , i ) - vlist (:, k )) < 1 0E-6 ) then ! check if vertex already stored indx ( l ) = k cycle j_loop end if end do nv = nv + 1 vlist (:, nv ) = vertx_tetra (:, j , i ) indx ( l ) = nv end do j_loop end do ! Define edges (non-duplicated) and faces (non-duplicated) of IBZ ne = 0 te = 0 ! counter tetra+edge l = 1 do i = 1 , num_tetra if ( i == 1 ) then ! first tetrahedra, save all the edges. edge ( 1 : 2 , 1 ) = ( / indx ( l ), indx ( l + 1 ) / ) edge ( 1 : 2 , 2 ) = ( / indx ( l ), indx ( l + 2 ) / ) edge ( 1 : 2 , 3 ) = ( / indx ( l ), indx ( l + 3 ) / ) edge ( 1 : 2 , 4 ) = ( / indx ( l + 1 ), indx ( l + 2 ) / ) edge ( 1 : 2 , 5 ) = ( / indx ( l + 2 ), indx ( l + 3 ) / ) edge ( 1 : 2 , 6 ) = ( / indx ( l + 3 ), indx ( l + 1 ) / ) ne = ne + 6 ! do ex = 1 , 6 te = te + 1 edge_indx ( te ) = te end do else edge_aux ( 1 : 2 , 1 ) = ( / indx ( l ), indx ( l + 1 ) / ) edge_aux ( 1 : 2 , 2 ) = ( / indx ( l ), indx ( l + 2 ) / ) edge_aux ( 1 : 2 , 3 ) = ( / indx ( l ), indx ( l + 3 ) / ) edge_aux ( 1 : 2 , 4 ) = ( / indx ( l + 1 ), indx ( l + 2 ) / ) edge_aux ( 1 : 2 , 5 ) = ( / indx ( l + 2 ), indx ( l + 3 ) / ) edge_aux ( 1 : 2 , 6 ) = ( / indx ( l + 3 ), indx ( l + 1 ) / ) ! Check if any edge has been already stored aux_edge_loop : do ex = 1 , 6 te = te + 1 ! Compare edge_aux with all the stored edges do e = 1 , ne if ( overlap_edge ( edge_aux (:, ex ), edge (:, e )) == 2 ) then edge_indx ( te ) = e cycle aux_edge_loop ! edge_aux already stored, don't save end if end do ne = ne + 1 edge (:, ne ) = edge_aux (:, ex ) edge_indx ( te ) = ne ! index of repeated edge list on non-repeated edge list end do aux_edge_loop end if ! i==1 l = l + 4 end do ! i ! Triangular faces as vertices l = 1 ! counter tetra+vert tf = 0 ! counter tetra+face nf = 1 ! total number of faces do i = 1 , num_tetra if ( i == 1 ) then face_as_vert ( 1 : 3 , nf ) = ( / indx ( l ), indx ( l + 2 ), indx ( l + 1 ) / ) face_as_vert ( 1 : 3 , nf + 1 ) = ( / indx ( l ), indx ( l + 3 ), indx ( l + 1 ) / ) face_as_vert ( 1 : 3 , nf + 2 ) = ( / indx ( l ), indx ( l + 2 ), indx ( l + 3 ) / ) face_as_vert ( 1 : 3 , nf + 3 ) = ( / indx ( l + 1 ), indx ( l + 2 ), indx ( l + 3 ) / ) nf = nf + 3 ! do fx = 1 , 4 tf = tf + 1 face_indx ( tf ) = tf end do else face_aux ( 1 : 3 , 1 ) = ( / indx ( l ), indx ( l + 2 ), indx ( l + 1 ) / ) face_aux ( 1 : 3 , 2 ) = ( / indx ( l ), indx ( l + 3 ), indx ( l + 1 ) / ) face_aux ( 1 : 3 , 3 ) = ( / indx ( l ), indx ( l + 2 ), indx ( l + 3 ) / ) face_aux ( 1 : 3 , 4 ) = ( / indx ( l + 1 ), indx ( l + 2 ), indx ( l + 3 ) / ) ! Check if any edge has been already stored aux_face_loop : do fx = 1 , 4 tf = tf + 1 ! Compare edge_aux with all the stored edges do f = 1 , nf if ( overlap_faces_int ( face_aux (:, fx ), face_as_vert (:, f )) == 3 ) then face_indx ( tf ) = f !cycle aux_face_loop ! face_aux already stored, don't save !! Duplicated face! This means face fx and f are inner faces. Remove f. !! This will remove inner faces do fx2 = f , nf face_as_vert (:, fx2 ) = face_as_vert (:, fx2 + 1 ) end do nf = nf - 1 cycle aux_face_loop end if end do nf = nf + 1 face_as_vert (:, nf ) = face_aux (:, fx ) face_indx ( tf ) = nf ! index of repeated face list on non-repeated face list end do aux_face_loop end if ! i==1 l = l + 4 end do ! i ! Print vertices, edges and faces files if wanted if ( verb ) then io_unit = find_free_unit () open ( unit = io_unit , file = 'vertices_IBZ.dat' , status = 'unknown' ) write ( unit = io_unit , fmt =* ) nv do i = 1 , nv write ( unit = io_unit , fmt = \"(3f12.6)\" ) ( vlist ( j , i ), j = 1 , 3 ) end do close ( io_unit ) io_unit2 = find_free_unit () open ( unit = io_unit2 , file = 'edges_IBZ.dat' , status = 'unknown' ) write ( unit = io_unit2 , fmt =* ) ne do e = 1 , ne write ( unit = io_unit2 , fmt =* ) edge ( 1 : 2 , e ) end do close ( io_unit2 ) io_unit3 = find_free_unit () open ( unit = io_unit3 , file = 'faces_IBZ.dat' , status = 'unknown' ) write ( unit = io_unit3 , fmt =* ) nf do f = 1 , nf write ( unit = io_unit3 , fmt =* ) face_as_vert ( 1 : 3 , f ) - 1 end do close ( io_unit3 ) end if end subroutine tetraIBZ_2_vert_faces_edges subroutine irr_faces ( num_tetra , nsym , s , TR_sym , bcell , verb , vlist , nf , face_as_vert , nfaces_irr , face_Gsymlink , face_indx , face_inv_indx ) use intw_matrix_vector , only : ainv implicit none ! I/O integer , intent ( in ) :: num_tetra , nsym , nf integer , intent ( in ) :: s ( 1 : 3 , 1 : 3 , nsym ) logical , intent ( in ) :: TR_sym real ( dp ), intent ( in ) :: bcell ( 1 : 3 , 1 : 3 ) logical , intent ( in ) :: verb real ( dp ), intent ( in ) :: vlist ( 1 : 3 , 4 * num_tetra ) ! List of non-repeated vertices integer , intent ( in ) :: face_as_vert ( 1 : 3 , 4 * num_tetra ) ! List of non-repeated faces (not reduced by S+G symmetry yet) integer , intent ( out ) :: nfaces_irr ! Number of irreducible faces integer , intent ( out ) :: face_Gsymlink ( 4 * num_tetra , 2 , - 1 : 1 , - 1 : 1 , - 1 : 1 ), face_indx ( 4 * num_tetra ), face_inv_indx ( 4 * num_tetra ) real ( dp ) :: face_aux ( 1 : 3 , 1 : 3 ) real ( dp ) :: bcelli ( 1 : 3 , 1 : 3 ), vert_crys ( 1 : 3 ), rot_face ( 1 : 3 , 1 : 3 ) ! Local integer :: iv , fx , f , isym , ig , jg , kg ! Detect irreducible faces considering S+G symmetry operations bcelli = ainv ( bcell ) face_Gsymlink = 0 nfaces_irr = 1 face_indx ( 1 ) = 1 face_inv_indx ( 1 ) = 1 aux_face_loop : do fx = 2 , nf do iv = 1 , 3 face_aux ( 1 : 3 , iv ) = vlist (:, face_as_vert ( iv , fx )) end do ! Compare face with the already stored faces + all the possible S+G rotations do f = 1 , nfaces_irr do isym = 1 , nsym do ig = - 1 , 1 do jg = - 1 , 1 do kg = - 1 , 1 if ( ig == 0 . and . jg == 0 . and . kg == 0 ) cycle do iv = 1 , 3 vert_crys = matmul ( bcelli , vlist (:, face_as_vert ( iv , face_inv_indx ( f )))) rot_face ( 1 : 3 , iv ) = matmul ( bcell , matmul ( dble ( s (:,:, isym )), vert_crys )) & ! rotate with S + ig * bcell ( 1 : 3 , 1 ) + jg * bcell ( 1 : 3 , 2 ) + kg * bcell ( 1 : 3 , 3 ) ! add G end do ! check with face_aux if ( overlap_face ( face_aux , rot_face ) == 3 ) then ! Face is related to stored face f by symm.operation isym, no TR, adding (ig,jg,kg) G vector if ( verb ) then write ( * , '(\"|     Face \",I4,\" is related to face \",I4,\" by:         |\")' ) fx , face_inv_indx ( f ) write ( * , '(\"|       G = \",3I4,\"                            |\")' ) ig , jg , kg endif face_indx ( fx ) = f face_Gsymlink ( fx , 1 , ig , jg , kg ) = isym face_Gsymlink ( fx , 2 , ig , jg , kg ) = 0 ! no TR cycle aux_face_loop end if ! TR symmetry if ( TR_sym ) then do iv = 1 , 3 vert_crys = matmul ( bcelli , vlist (:, face_as_vert ( iv , face_inv_indx ( f )))) rot_face ( 1 : 3 , iv ) = - matmul ( bcell , matmul ( dble ( s (:,:, isym )), vert_crys )) & ! rotate with S + TR + ig * bcell ( 1 : 3 , 1 ) + jg * bcell ( 1 : 3 , 2 ) + kg * bcell ( 1 : 3 , 3 ) ! add G end do if ( overlap_face ( face_aux , rot_face ) == 3 ) then ! Face is related to stored f face by isym symm.operation + TR, plus (ig,jg,kg) G vector if ( verb ) then write ( * , '(\"|     Face \",I4,\" is related to face \",I4,\" by:         |\")' ) fx , face_inv_indx ( f ) write ( * , '(\"|       G = \",3I4,\"  +  TR                     |\")' ) ig , jg , kg endif face_indx ( fx ) = f face_Gsymlink ( fx , 1 , ig , jg , kg ) = isym face_Gsymlink ( fx , 2 , ig , jg , kg ) = 1 ! cycle aux_face_loop end if end if ! end do !kg end do !jg end do !ig end do !isym end do !f ! Face not related by sym with any stored face nfaces_irr = nfaces_irr + 1 face_indx ( fx ) = nfaces_irr face_inv_indx ( nfaces_irr ) = fx ! Relates new stored face with index in old list end do aux_face_loop if ( verb ) write ( * , '(\"|     Number of faces on IBZ:      \",I4,\"             |\")' ) nf if ( verb ) write ( * , '(\"|     Number of irreducible faces: \",I4,\"             |\")' ) nfaces_irr end subroutine irr_faces subroutine sort_edges ( nen , nemx , nein , nemn ) implicit none ! I/O integer , dimension ( 1 : 3 ), intent ( in ) :: nen integer , intent ( out ) :: nemx , nein , nemn ! Local integer :: i ! special case when all edges have same number of nodes if ( nen ( 1 ) == nen ( 2 ) . and . nen ( 2 ) == nen ( 3 ) ) then nemx = 1 nein = 2 nemn = 3 return end if nemx = maxloc ( nen (:), dim = 1 ) nemn = minloc ( nen (:), dim = 1 ) nein = 1 do i = 1 , 3 if ( i /= nemn . and . i /= nemx ) nein = i end do if ( nemx == nemn . or . nemx == nein . or . nemn == nein ) then write ( * , '(\"ERROR on sorting edges, stopping\")' ) write ( * , '(\"ne1, ne2, ne3 :\",3I6)' ) nen ( 1 ), nen ( 2 ), nen ( 3 ) write ( * , '(\"nemax, neint, nemin :\",3I6)' ) nemx , nein , nemn stop end if end subroutine sort_edges subroutine write_node_list_face ( f , tot_nodes , node_coords ) use intw_utility , only : find_free_unit , int2str implicit none ! I/O integer , intent ( in ) :: f , tot_nodes real ( dp ), dimension (:,:), intent ( in ) :: node_coords ! Local integer :: io_unit , i io_unit = find_free_unit () open ( unit = io_unit , file = trim ( int2str ( f )) // \"nodes_on_face.node\" , status = \"unknown\" ) write ( unit = io_unit , fmt = '(I12)' ) tot_nodes do i = 1 , tot_nodes write ( io_unit , fmt = '(I6, 3E18.10)' ) i , node_coords ( 1 : 3 , i ) end do close ( unit = io_unit ) end subroutine write_node_list_face subroutine nodes_on_face_and_rotate_to_plane ( f , nk1 , nk2 , nk3 , bg , ntetra , face_as_vert , vert_coord , verb , split_edges_nodes , k , theta ) use intw_utility , only : find_free_unit use intw_matrix_vector , only : norma , cross implicit none ! I/O integer , intent ( in ) :: f ! face number (only needed for writing node file) integer , intent ( in ) :: nk1 , nk2 , nk3 ! BZ partition from input real ( dp ), intent ( in ) :: bg ( 1 : 3 , 1 : 3 ) ! reciprocal lattice vectors as columns integer , intent ( in ) :: ntetra integer , intent ( in ) :: face_as_vert ( 1 : 3 ) ! list with vertices of face real ( dp ), intent ( in ) :: vert_coord ( 1 : 3 , 4 * ntetra ) ! list of vertices coordinates logical , intent ( in ) :: verb ! output edge nodes or not real ( dp ), intent ( out ) :: split_edges_nodes ( 1 : 3 , nk1 + nk2 + nk3 , 1 : 3 ) ! xzy coords. of nodes of split edges real ( dp ), intent ( out ) :: k ( 1 : 3 ) ! rotation axis from actual 3d to xy plane real ( dp ), intent ( out ) :: theta ! rotation angle ! Local integer :: ne ( 3 ) ! number of splitted points for each edge integer :: tot_nodes_face ! total number of nodes on face real ( dp ) :: node_list ( 1 : 3 , 3 * ( nk1 + nk2 + nk3 )) ! list with total node coordinates of face real ( dp ) :: nodes_in_plane ( 1 : 2 , 3 * ( nk1 + nk2 + nk3 )) ! 2d coords of nodes displaced and rotated to xy plane real ( dp ) :: edges_vector ( 1 : 3 , 1 : 3 ) ! 3d vectors of edges of face real ( dp ), dimension ( 1 : 3 , 1 : 3 ) :: vf ! Coordinates of vertices of face real ( dp ), dimension ( 1 : 3 ) :: normal , xy_plane ! Normal vector of face, normal of xy plane, and rotation axis real ( dp ) :: node_aux ( 1 : 3 ), dist , dist_aux , vec_extra ( 1 : 3 ) real ( dp ), allocatable :: rotated_nodes (:,:) ! Rotated and displaced nodes integer :: io_unit , i , j , l , nemax , neint , nemin , ne_extra !!------------------------ Split edges in nodes edges_vector ( 1 : 3 , 1 ) = vert_coord ( 1 : 3 , face_as_vert ( 2 )) - vert_coord ( 1 : 3 , face_as_vert ( 1 )) edges_vector ( 1 : 3 , 2 ) = vert_coord ( 1 : 3 , face_as_vert ( 3 )) - vert_coord ( 1 : 3 , face_as_vert ( 2 )) edges_vector ( 1 : 3 , 3 ) = vert_coord ( 1 : 3 , face_as_vert ( 1 )) - vert_coord ( 1 : 3 , face_as_vert ( 3 )) ne ( 1 ) = NINT ( sqrt ( nk1 * abs ( dot_product ( edges_vector ( 1 : 3 , 1 ), bg ( 1 : 3 , 1 ))) + & nk2 * abs ( dot_product ( edges_vector ( 1 : 3 , 1 ), bg ( 1 : 3 , 2 ))) + & nk3 * abs ( dot_product ( edges_vector ( 1 : 3 , 1 ), bg ( 1 : 3 , 3 )))) ) ne ( 2 ) = NINT ( sqrt ( nk1 * abs ( dot_product ( edges_vector ( 1 : 3 , 2 ), bg ( 1 : 3 , 1 ))) + & nk2 * abs ( dot_product ( edges_vector ( 1 : 3 , 2 ), bg ( 1 : 3 , 2 ))) + & nk3 * abs ( dot_product ( edges_vector ( 1 : 3 , 2 ), bg ( 1 : 3 , 3 )))) ) ne ( 3 ) = NINT ( sqrt ( nk1 * abs ( dot_product ( edges_vector ( 1 : 3 , 3 ), bg ( 1 : 3 , 1 ))) + & nk2 * abs ( dot_product ( edges_vector ( 1 : 3 , 3 ), bg ( 1 : 3 , 2 ))) + & nk3 * abs ( dot_product ( edges_vector ( 1 : 3 , 3 ), bg ( 1 : 3 , 3 )))) ) ! Convention: last node will be stored as first of the next edge (not to repeat nodes) tot_nodes_face = 0 do i = 1 , ne ( 1 ) split_edges_nodes ( 1 : 3 , i , 1 ) = vert_coord ( 1 : 3 , face_as_vert ( 1 )) + edges_vector ( 1 : 3 , 1 ) * ( i - 1 ) / ne ( 1 ) tot_nodes_face = tot_nodes_face + 1 node_list ( 1 : 3 , tot_nodes_face ) = split_edges_nodes ( 1 : 3 , i , 1 ) end do do i = 1 , ne ( 2 ) split_edges_nodes ( 1 : 3 , i , 2 ) = vert_coord ( 1 : 3 , face_as_vert ( 2 )) + edges_vector ( 1 : 3 , 2 ) * ( i - 1 ) / ne ( 2 ) tot_nodes_face = tot_nodes_face + 1 node_list ( 1 : 3 , tot_nodes_face ) = split_edges_nodes ( 1 : 3 , i , 2 ) end do do i = 1 , ne ( 3 ) split_edges_nodes ( 1 : 3 , i , 3 ) = vert_coord ( 1 : 3 , face_as_vert ( 3 )) + edges_vector ( 1 : 3 , 3 ) * ( i - 1 ) / ne ( 3 ) tot_nodes_face = tot_nodes_face + 1 node_list ( 1 : 3 , tot_nodes_face ) = split_edges_nodes ( 1 : 3 , i , 3 ) end do !!------------------------ Fill face with more nodes ! Sort edges with number of nodes call sort_edges ( ne , nemax , neint , nemin ) ! Join nodes on most populated edge with nodes of intermediate edge if ( ne ( nemax ) > 1 ) then do i = 2 , ne ( nemax ) ! first node is always shared by two edges ! !! detect closest node on intermediate edge and define vector in between !dist_aux = huge(dist) !do j = 2, ne(neint) !  dist = norma(split_edges_nodes(1:3,j,neint) - split_edges_nodes(1:3,i,nemax)) !  if (dist<dist_aux) then !    vec_extra(1:3) = split_edges_nodes(1:3,j,neint) - split_edges_nodes(1:3,i,nemax) !    dist_aux = dist !  end if !end do ! j ! assign pair-node on intermediate edge \"by hand\" if ( i <= ne ( neint ) ) then vec_extra ( 1 : 3 ) = split_edges_nodes ( 1 : 3 , ne ( neint ) - ( i - 2 ), neint ) - split_edges_nodes ( 1 : 3 , i , nemax ) !else if ( i == ne(neint)+1 ) then !  vec_extra(1:3) = split_edges_nodes(1:3,1,neint) - split_edges_nodes(1:3,i,nemax) else cycle end if ! add extra nodes on line connecting nodes on edges ne_extra = NINT ( sqrt ( nk1 * abs ( dot_product ( vec_extra ( 1 : 3 ), bg ( 1 : 3 , 1 ))) + & nk2 * abs ( dot_product ( vec_extra ( 1 : 3 ), bg ( 1 : 3 , 2 ))) + & nk3 * abs ( dot_product ( vec_extra ( 1 : 3 ), bg ( 1 : 3 , 3 )))) ) if ( ne_extra > 1 ) then do l = 2 , ne_extra node_list ( 1 : 3 , tot_nodes_face + l - 1 ) = split_edges_nodes ( 1 : 3 , i , nemax ) + vec_extra ( 1 : 3 ) * ( l - 1 ) / ne_extra end do tot_nodes_face = tot_nodes_face + ne_extra - 1 end if ! ne_exgtra>1 ! end do ! i end if ! Write nodes on face to file if needed if ( verb ) call write_node_list_face ( f , tot_nodes_face , node_list ) !!------------------------ Rotate nodes to lie at (x,y) plane and displace w/r first node ! xy_plane = ( / 0.0_dp , 0.0_dp , 1.0_dp / ) ! Vertices of face vf ( 1 : 3 , 1 ) = vert_coord ( 1 : 3 , face_as_vert ( 1 )) vf ( 1 : 3 , 2 ) = vert_coord ( 1 : 3 , face_as_vert ( 2 )) vf ( 1 : 3 , 3 ) = vert_coord ( 1 : 3 , face_as_vert ( 3 )) ! Normal vector of face normal = normal_of_tri ( vf ) if ( norma ( cross ( normal , xy_plane )) < 1.0E-6_dp ) then ! plane of face is already xy plane if ( verb ) then write ( * , '(\"|   Face is on xy plane                             |\")' ) write ( * , '(\"|   Vectors: \",3F12.6,\"   |\")' ) vf ( 1 : 3 , 1 ) write ( * , '(\"|            \",3F12.6,\"   |\")' ) vf ( 1 : 3 , 2 ) write ( * , '(\"|            \",3F12.6,\"   |\")' ) vf ( 1 : 3 , 3 ) write ( * , '(\"|   Normal:  \",3F12.6,\"   |\")' ) normal endif k = ( / 0.0_dp , 0.0_dp , 0.0_dp / ) theta = 0.0_dp else ! define rotation vector and angle k = cross ( normal , xy_plane ) / norma ( cross ( normal , xy_plane ) ) theta = acos ( dot_product ( xy_plane , normal ) ) end if ! ! Rodrigues' rotation formula for each node allocate ( rotated_nodes ( 1 : 3 , tot_nodes_face )) do i = 1 , tot_nodes_face ! displace to origin and rotate to xy plane node_aux ( 1 : 3 ) = node_list ( 1 : 3 , i ) - split_edges_nodes ( 1 : 3 , 1 , 1 ) rotated_nodes ( 1 : 3 , i ) = node_aux ( 1 : 3 ) * cos ( theta ) + cross ( k , node_aux ) * sin ( theta ) + k ( 1 : 3 ) * dot_product ( k , node_aux ) * ( 1.d0 - cos ( theta )) ! check if ( abs ( rotated_nodes ( 3 , i )) > 1.0E-10_dp ) then write ( * , * ) \"Rotation of face failed, something wrong...\" write ( * , * ) \"z-component of node i:\" , i write ( * , * ) \"Before rotating      :\" , node_list ( 1 : 3 , i ) write ( * , * ) \"After rotating       :\" , rotated_nodes ( 1 : 3 , i ) write ( * , * ) \"Origin node          :\" , split_edges_nodes ( 1 : 3 , 1 , 1 ) write ( * , * ) \"EXIT\" stop end if nodes_in_plane ( 1 : 2 , i ) = rotated_nodes ( 1 : 2 , i ) end do ! i deallocate ( rotated_nodes ) !!------------------------ Write node list in poly format to triangulate ! Write .poly file to be read by Triangle io_unit = find_free_unit () open ( unit = io_unit , file = \"face_split_edges.poly\" , status = \"unknown\" ) write ( io_unit , fmt = '(4I6)' ) tot_nodes_face , 2 , 0 , 0 do j = 1 , tot_nodes_face write ( io_unit , fmt = '(I6, 2F18.10)' ) j , nodes_in_plane ( 1 : 2 , j ) end do write ( io_unit , fmt = '(2I6)' ) sum ( ne (:)), 0 ! add segments on border of face do j = 1 , sum ( ne (:)) - 1 write ( io_unit , fmt = '(3I6)' ) j , j , j + 1 end do write ( io_unit , fmt = '(3I6)' ) sum ( ne (:)), sum ( ne (:)), 1 write ( io_unit , fmt = '(I6)' ) 0 close ( io_unit ) end subroutine nodes_on_face_and_rotate_to_plane subroutine triangulate_faces ( ntetra , nfaces , faces_Gsymlink , nsym , s , faces_indx , faces_inv_indx , nk1 , nk2 , nk3 , bcell , & faces_as_vert , vert_coord , verbose ) use intw_utility , only : find_free_unit , int2str use intw_matrix_vector , only : ainv , norma , cross implicit none ! I/O integer , intent ( in ) :: ntetra , nfaces ! number of tetrahedra and faces on IBZ integer , intent ( in ) :: faces_Gsymlink ( 4 * ntetra , 2 , - 1 : 1 , - 1 : 1 , - 1 : 1 ) ! info about S+G symm of faces integer , intent ( in ) :: nsym ! number of symmetry operations integer , intent ( in ) :: s ( 1 : 3 , 1 : 3 , nsym ) ! symmetry operation matrices integer , intent ( in ) :: faces_indx ( 4 * ntetra ), faces_inv_indx ( 4 * ntetra ) ! faces indexes from full to reduced list integer , intent ( in ) :: nk1 , nk2 , nk3 ! partition chosen to perform edge-splitting real ( dp ), intent ( in ) :: bcell ( 1 : 3 , 1 : 3 ) ! reciprocal cell vectors on columns integer , intent ( in ) :: faces_as_vert ( 1 : 3 , 4 * ntetra ) ! vertices indices on faces real ( dp ), intent ( in ) :: vert_coord ( 1 : 3 , 4 * ntetra ) ! Coordinates of vertices on IBZ logical , intent ( in ) :: verbose ! logical controlling output verbosity ! Local integer :: isym , f , iface_irr , iface_full integer :: i , j , k , l , ig , jg , kg , iv , nv , it , nt integer :: io_unit , io_unit2 , dummy_i real ( dp ) :: kvec ( 1 : 3 ), theta , v_aux ( 1 : 3 ) logical , allocatable :: triangulated_face (:) integer , allocatable :: nvert_face (:), ntri_face (:), triangles_face (:,:,:), indx (:), tri_face_indx (:,:) real ( dp ), allocatable :: split_edges_nodes (:,:,:), nodes_fplane (:,:), vertices_face (:,:,:), vlist (:,:) character ( len = 10 ) :: text allocate ( nvert_face ( nfaces ), ntri_face ( nfaces ), triangulated_face ( nfaces )) allocate ( vertices_face ( 1 : 3 , 3 * ( nk1 + nk2 + nk3 ), nfaces ), triangles_face ( 1 : 3 , 3 * ( nk1 + nk2 + nk3 ), nfaces )) allocate ( split_edges_nodes ( 1 : 3 , nk1 + nk2 + nk3 , 1 : 3 )) allocate ( nodes_fplane ( 1 : 2 , 3 * ( nk1 + nk2 + nk3 ))) triangulated_face (:) = . false . if ( verbose ) write ( * , '(\"|         ---------------------------------         |\")' ) ! Clear triangle output file CALL EXECUTE_COMMAND_LINE ( \"echo '---------------------------------' > triangle.out\" ) do f = 1 , nfaces ! if ( ANY ( faces_Gsymlink ( f ,:,:,:,:) /= 0 )) then ! if ( verbose ) then write ( * , '(\"| Face \",I2,\" will be obtained by symmetry from face \",I2,\" |\")' ) f , faces_indx ( f ) write ( * , '(\"|         ---------------------------------         |\")' ) write ( * , '(\"| Face \",I2,\" will be triangulated                      |\")' ) faces_indx ( f ) endif ! iface_irr = faces_indx ( f ) iface_full = faces_inv_indx ( iface_irr ) call nodes_on_face_and_rotate_to_plane ( iface_full , nk1 , nk2 , nk3 , bcell , ntetra , faces_as_vert ( 1 : 3 , iface_full ), & vert_coord , verbose , split_edges_nodes , kvec , theta ) ! if ( verbose ) then write ( * , '(\"| Running triangle with command:                    |\")' ) write ( * , '(\"| triangle -g face_split_edges.poly > triangle.out  |\")' ) endif ! write ( text , '(\"Face \",I4,\":\")' ) faces_indx ( f ) CALL EXECUTE_COMMAND_LINE ( \"echo '\" // trim ( text ) // \"' >> triangle.out\" ) CALL EXECUTE_COMMAND_LINE ( \"triangle -g face_split_edges.poly >> triangle.out\" ) CALL EXECUTE_COMMAND_LINE ( \"echo '---------------------------------' >> triangle.out\" ) ! ! Read output face triangulation file, rotate vertices and write to file ! if ( verbose ) then io_unit2 = find_free_unit () open ( unit = io_unit2 , file = trim ( int2str ( iface_full )) // \"_triangle_output.off\" , status = 'unknown' ) end if ! io_unit = find_free_unit () open ( unit = io_unit , file = 'face_split_edges.1.off' , status = 'unknown' ) read ( unit = io_unit , fmt =* ) read ( unit = io_unit , fmt =* ) nvert_face ( iface_full ), ntri_face ( iface_full ) if ( verbose ) write ( unit = io_unit2 , fmt =* ) \"OFF\" if ( verbose ) write ( unit = io_unit2 , fmt =* ) nvert_face ( iface_full ), ntri_face ( iface_full ) do iv = 1 , nvert_face ( iface_full ) read ( unit = io_unit , fmt =* ) v_aux ( 1 : 3 ) ! read vertices_face ( 1 : 3 , iv , iface_full ) = v_aux ( 1 : 3 ) * cos ( - theta ) + cross ( kvec , v_aux ) * sin ( - theta ) + kvec ( 1 : 3 ) * dot_product ( kvec , v_aux ) * ( 1.d0 - cos ( - theta )) & ! rotate to true 3D plane + split_edges_nodes ( 1 : 3 , 1 , 1 ) ! displace to correct origin if ( verbose ) write ( unit = io_unit2 , fmt = '(3F12.6)' ) vertices_face ( 1 : 3 , iv , iface_full ) end do do it = 1 , ntri_face ( iface_full ) read ( unit = io_unit , fmt =* ) dummy_i , triangles_face ( 1 : 3 , it , iface_full ) if ( verbose ) write ( unit = io_unit2 , fmt = '(4I6)' ) dummy_i , triangles_face ( 1 : 3 , it , iface_full ) end do triangles_face (:,:, iface_full ) = triangles_face (:,:, iface_full ) + 1 ! start indexes from 1 close ( unit = io_unit ) if ( verbose ) close ( unit = io_unit2 ) ! ! Rotate triangulation to faces related by symmetry do ig = - 1 , 1 do jg = - 1 , 1 do kg = - 1 , 1 isym = faces_Gsymlink ( f , 1 , ig , jg , kg ) if ( isym == 0 ) cycle if ( faces_Gsymlink ( f , 2 , ig , jg , kg ) == 0 ) then ! no TR do iv = 1 , nvert_face ( iface_full ) v_aux = matmul ( ainv ( bcell ), vertices_face ( 1 : 3 , iv , iface_full )) vertices_face ( 1 : 3 , iv , f ) = matmul ( bcell , matmul ( dble ( s (:,:, isym )), v_aux )) & ! rotate with S + ig * bcell ( 1 : 3 , 1 ) + jg * bcell ( 1 : 3 , 2 ) + kg * bcell ( 1 : 3 , 3 ) ! add G end do !iv else ! TR do iv = 1 , nvert_face ( iface_full ) v_aux = matmul ( ainv ( bcell ), vertices_face ( 1 : 3 , iv , iface_full )) vertices_face ( 1 : 3 , iv , f ) = - matmul ( bcell , matmul ( dble ( s (:,:, isym )), v_aux )) & ! rotate with S + ig * bcell ( 1 : 3 , 1 ) + jg * bcell ( 1 : 3 , 2 ) + kg * bcell ( 1 : 3 , 3 ) ! add G end do !iv end if end do !kg end do !jg end do !ig ! Equal number and indexes of triangles nvert_face ( f ) = nvert_face ( iface_full ) ntri_face ( f ) = ntri_face ( iface_full ) triangles_face (:,:, f ) = triangles_face (:,:, iface_full ) ! Set faces as triangulated triangulated_face ( f ) = . true . triangulated_face ( iface_full ) = . true . ! end if ! ANY(faces_Gsymlink) end do if ( verbose ) write ( * , '(\"|         ---------------------------------         |\")' ) do f = 1 , nfaces ! if ( triangulated_face ( f )) cycle ! if ( verbose ) then write ( * , '(\"| Face \", I2,\" will be triangulated                      |\")' ) f endif ! call nodes_on_face_and_rotate_to_plane ( f , nk1 , nk2 , nk3 , bcell , ntetra , faces_as_vert ( 1 : 3 , f ), vert_coord , verbose , & split_edges_nodes , kvec , theta ) ! if ( verbose ) then write ( * , '(\"| Running triangle with command:                    |\")' ) write ( * , '(\"| triangle -pg face_split_edges.poly > triangle.out |\")' ) write ( * , '(\"|         ---------------------------------         |\")' ) endif ! write ( text , '(\"Face \",I4,\":\")' ) f CALL EXECUTE_COMMAND_LINE ( \"echo '\" // trim ( text ) // \"' >> triangle.out\" ) CALL EXECUTE_COMMAND_LINE ( \"triangle -pg face_split_edges.poly >> triangle.out\" ) CALL EXECUTE_COMMAND_LINE ( \"echo '---------------------------------' >> triangle.out\" ) ! ! Read output face triangulation file, rotate vertices and write to file ! if ( verbose ) then io_unit2 = find_free_unit () open ( unit = io_unit2 , file = trim ( int2str ( f )) // \"_triangle_output.off\" , status = 'unknown' ) end if ! io_unit = find_free_unit () open ( unit = io_unit , file = 'face_split_edges.1.off' , status = 'unknown' ) read ( unit = io_unit , fmt =* ) read ( unit = io_unit , fmt =* ) nvert_face ( f ), ntri_face ( f ) if ( verbose ) write ( unit = io_unit2 , fmt =* ) \"OFF\" if ( verbose ) write ( unit = io_unit2 , fmt =* ) nvert_face ( f ), ntri_face ( f ) do iv = 1 , nvert_face ( f ) read ( unit = io_unit , fmt =* ) v_aux ( 1 : 3 ) ! read vertices_face ( 1 : 3 , iv , f ) = v_aux ( 1 : 3 ) * cos ( - theta ) + cross ( kvec , v_aux ) * sin ( - theta ) + kvec ( 1 : 3 ) * dot_product ( kvec , v_aux ) * ( 1.d0 - cos ( - theta )) & ! rotate to true 3D plane + split_edges_nodes ( 1 : 3 , 1 , 1 ) ! displace to correct origin if ( verbose ) write ( unit = io_unit2 , fmt = '(3F12.6)' ) vertices_face ( 1 : 3 , iv , f ) end do do it = 1 , ntri_face ( f ) read ( unit = io_unit , fmt =* ) dummy_i , triangles_face ( 1 : 3 , it , f ) if ( verbose ) write ( unit = io_unit2 , fmt = '(4I6)' ) dummy_i , triangles_face ( 1 : 3 , it , f ) end do triangles_face (:,:, f ) = triangles_face (:,:, f ) + 1 ! start indexes from 1 close ( unit = io_unit ) if ( verbose ) close ( unit = io_unit2 ) ! triangulated_face ( f ) = . true . ! end do !f deallocate ( split_edges_nodes , nodes_fplane ) ! ! Create a single OFF file with all the triangulated faces cleaning repeated nodes allocate ( vlist ( 1 : 3 , sum ( nvert_face (:))), indx ( maxval ( nvert_face (:))), tri_face_indx ( 1 : 3 , sum ( ntri_face (:)))) nv = 0 nt = 0 do f = 1 , nfaces l = 0 !! Do not plot rotated triangulation !if (ANY(faces_Gsymlink(f,:,:,:,:)/=0)) cycle !! Plot only rotated face !if (ALL(faces_Gsymlink(f,:,:,:,:)==0)) cycle ! iv_loop : do iv = 1 , nvert_face ( f ) l = l + 1 if ( nv == 0 ) then nv = nv + 1 vlist (:, nv ) = vertices_face ( 1 : 3 , iv , f ) indx ( l ) = nv ! vertex index cycle iv_loop end if do k = 1 , nv if ( norma ( vertices_face ( 1 : 3 , iv , f ) - vlist ( 1 : 3 , k )) < 1.0E-5_dp ) then ! check if vertex already stored indx ( l ) = k cycle iv_loop end if end do nv = nv + 1 vlist (:, nv ) = vertices_face (:, iv , f ) indx ( l ) = nv end do iv_loop ! it_loop : do it = 1 , ntri_face ( f ) nt = nt + 1 tri_face_indx ( 1 : 3 , nt ) = ( / indx ( triangles_face ( 1 , it , f )), indx ( triangles_face ( 2 , it , f )), indx ( triangles_face ( 3 , it , f )) / ) end do it_loop ! !!end if end do ! nfaces ! Write to OFF file io_unit = find_free_unit () open ( unit = io_unit , file = \"Triangulated_IBZ.off\" , status = \"unknown\" ) write ( unit = io_unit , fmt = \"(a)\" ) \"OFF\" write ( unit = io_unit , fmt = \"(3I6)\" ) nv , nt , 0 write ( unit = io_unit , fmt =* ) ! Vertices of triangles do i = 1 , nv write ( unit = io_unit , fmt = \"(3f12.6)\" ) ( vlist ( j , i ), j = 1 , 3 ) end do ! Triangle indexes do i = 1 , nt write ( unit = io_unit , fmt = \"(4I6)\" ) 3 , tri_face_indx ( 1 : 3 , i ) - 1 end do close ( unit = io_unit ) ! Write nodes on faces to file if needed if ( verbose ) then io_unit = find_free_unit () open ( unit = io_unit , file = \"nodes_on_faces.node\" , status = \"unknown\" ) write ( unit = io_unit , fmt = \"(3I6)\" ) nv write ( unit = io_unit , fmt =* ) ! Vertices of triangles do i = 1 , nv write ( unit = io_unit , fmt = \"(I6, 3f12.6)\" ) i , ( vlist ( j , i ), j = 1 , 3 ) end do end if close ( io_unit ) deallocate ( vlist , indx , tri_face_indx ) deallocate ( nvert_face , ntri_face , triangulated_face , vertices_face , triangles_face ) end subroutine triangulate_faces subroutine add_nodes_IBZ_volume ( nk1 , nk2 , nk3 , m , epsface , bg , n_BZ_tetra_irr , BZ_tetra_irr , verb ) ! Create regular mesh and check which points lie inside IBZ use intw_utility , only : find_free_unit use intw_matrix_vector , only : ainv , norma , cross implicit none ! I/O integer , intent ( in ) :: nk1 , nk2 , nk3 , n_BZ_tetra_irr real ( dp ), intent ( in ) :: m , epsface real ( dp ), intent ( in ) :: BZ_tetra_irr ( 1 : 3 , 1 : 4 , n_BZ_tetra_irr ) real ( dp ), intent ( in ) :: bg ( 1 : 3 , 1 : 3 ) logical , intent ( in ) :: verb ! Local integer :: io_unit , i , j , k , l , it , i_min , i_max , j_min , j_max , k_min , k_max , nk_in real ( dp ) :: vcrys ( 1 : 3 ), vcart ( 1 : 3 ), mat ( 1 : 3 , 1 : 3 ), coord ( 1 : 3 ), face ( 1 : 3 , 1 : 3 ), coef ( 1 : 3 ) real ( dp ), allocatable :: node_coords (:,:) ! real(dp), parameter :: epsvert = 1.0E-6_dp ! integer, parameter :: m = 1 ! real(dp), parameter :: m = 1.5_dp i_min = - int ( m * nk1 ) i_max = int ( m * nk1 ) j_min = - int ( m * nk2 ) j_max = int ( m * nk2 ) k_min = - int ( m * nk3 ) k_max = int ( m * nk3 ) if ( verb ) write ( * , '(\"|     nk1, nk2, nk3 = \",3I4,\"                  |\")' ) nk1 , nk2 , nk3 if ( verb ) write ( * , '(\"|     i_min, i_max  = \",2I4,\"                      |\")' ) i_min , i_max if ( verb ) write ( * , '(\"|     j_min, j_max  = \",2I4,\"                      |\")' ) j_min , j_max if ( verb ) write ( * , '(\"|     k_min, k_max  = \",2I4,\"                      |\")' ) k_min , k_max allocate ( node_coords ( 3 , n_BZ_tetra_irr * ( i_max - i_min ) * ( j_max - j_min ) * ( k_max - k_min ))) nk_in = 0 ! do i = i_min, i_max !   do j = j_min, j_max !     k_loop: do k = k_min, k_max do i = 0 , 2 * int ( m * nk1 ) do j = 0 , 2 * int ( m * nk2 ) k_loop : do k = 0 , 2 * int ( m * nk3 ) ! !vcrys = (/real(i-1, dp)/(2.0_dp*nk1), real(j-1, dp)/(2.0_dp*nk2), real(k-1, dp)/(2.0_dp*nk3)/) !vcrys = (/real(i, dp)/(int(m)*nk1), real(j, dp)/(int(m)*nk2), real(k, dp)/(int(m)*nk3)/) vcrys = ( / - 1.0_dp + real ( i , dp ) / ( int ( m * nk1 )), - 1.0_dp + real ( j , dp ) / ( int ( m * nk2 )), - 1.0_dp + real ( k , dp ) / ( int ( m * nk3 )) / ) vcart = matmul ( bg , vcrys ) ! do it = 1 , n_BZ_tetra_irr mat = BZ_tetra_irr ( 1 : 3 , 2 : 4 , it ) coord = matmul ( ainv ( mat ), vcart ) ! ! Check if k-point is inside IBZ if ( ( - epsface <= coord ( 1 )) . and . ( - epsface <= coord ( 2 )) . and . ( - epsface <= coord ( 3 )) & . and . ( coord ( 1 ) - 1.d0 <= epsface ) . and . ( coord ( 2 ) - 1.d0 <= epsface ) & . and . ( coord ( 3 ) - 1.d0 <= epsface ). and .( sum ( coord ) - 1.d0 <= epsface ) ) then ! Check if k-point is on border of BZ if ( ANY ( coord (:) - epsface <= 0.0_dp ) . or . abs ( sum ( coord (:)) - 1.0_dp ) <= epsface ) then ! Node lies on BZ border face, discard cycle end if ! Check if k-point is on any other face of tetrahedra do l = 2 , 3 face (:, 1 ) = BZ_tetra_irr (:, l , it ) - BZ_tetra_irr (:, 1 , it ) ! vface(:,1,j) face (:, 2 ) = BZ_tetra_irr (:, l + 1 , it ) - BZ_tetra_irr (:, 1 , it ) face (:, 3 ) = cross ( face (:, 2 ), face (:, 1 )) face (:, 3 ) = face (:, 3 ) / norma ( face (:, 3 )) coef ( 1 : 3 ) = matmul ( ainv ( face ( 1 : 3 , 1 : 3 )), coord ( 1 : 3 )) ! Coordinate vector of the vertex is perpendicular to normal vector of face (face and vector coplanar) if ( abs ( dot_product ( face (:, 3 ), coord (:))) < epsface ) then ! Coordinate vector of the vertex lies within the face if ( coef ( 1 ) >= 0.0_dp - epsface . and . coef ( 1 ) <= 1.0_dp + epsface & . and . coef ( 2 ) >= 0.0_dp - epsface . and . coef ( 2 ) <= 1.0_dp + epsface & !) then . and . sum ( coef ( 1 : 2 )) - 1.0_dp < epsface ) then ! ! Node lies on IBZ face, discard cycle ! end if end if end do ! l ! Node lies within a IBZ tetra, and not on its faces, so save nk_in = nk_in + 1 node_coords ( 1 : 3 , nk_in ) = vcart ( 1 : 3 ) cycle k_loop end if ! Check if k-point is inside IBZ end do ! it ! end do k_loop ! k end do ! j end do ! i if ( verb ) write ( * , '(\"|     Number of points on IBZ: \",I4,\"                 |\")' ) nk_in ! Write nodes to .node file io_unit = find_free_unit () open ( unit = io_unit , file = \"Triangulated_IBZ.a.node\" , status = \"unknown\" ) write ( unit = io_unit , fmt = '(I12)' ) nk_in do i = 1 , nk_in write ( io_unit , fmt = '(I6, 3E18.10)' ) i , node_coords ( 1 : 3 , i ) end do close ( unit = io_unit ) deallocate ( node_coords ) end subroutine add_nodes_IBZ_volume end module triFS_geometry","tags":"","url":"sourcefile/geometry.f90.html"},{"title":"w90_setup.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_w90_setup !! display: none !! !! This module contains subroutines and variables for reading and storing !! Wannier90 data, and for preforming Wannier interpolation. !! !! ### Details !! !! The utility W902INTW should: !! 1. call read_nnkp_file in intw_intw2wannier module to obtain !!     nnkp_exclude_bands, nnkp_kpoints, etc. !! 2. call read_w90_chk !! 3. call allocate_and_build_u_mesh !! 4. call write_formatted_u_mesh !! !! Then, any utility using u_mesh can simply obtain it by using !! read_formatted_u_mesh !! use kinds , only : dp implicit none ! ! variables public :: use_disentanglement public :: n_wss , n_ws_search ! search space for WS vectors public :: irvec , nrpts , ndegen ! these will substitute w90_hamiltonian: irvec, nrpts, ndegen public :: ham_k , ham_r ! ham_k, ham_r public :: ndimwin , lwindow ! NOTE probably we do not need these outside the module public :: u_mesh ! unitary matrices public :: eigenval_intw ! coarse-mesh eigenvalues used in wannier (read from .eig) ! subroutines public :: read_w90_chk , allocate_and_build_u_mesh , write_formatted_u_mesh , allocate_and_build_ws_irvec , & allocate_and_build_ham_k , allocate_and_build_ham_r , read_eig , write_ham_r , & allocate_and_read_ham_r , allocate_and_read_u_mesh , & interpolate_1k , interpolated_DOS , & wann_rotate_matrix , wann_fourier_1index , wann_IFT_1index , wann_FT_1index_1k ! private ! save ! logical :: use_disentanglement logical , allocatable :: lwindow (:,:) integer :: nrpts integer , allocatable :: ndegen (:), ndimwin (:) ! NOTE n_wss and n_ws_search  could be given somewhere as input integer , parameter :: n_wss = 27 integer , dimension ( 3 ) , parameter :: n_ws_search = ( / 1 , 1 , 1 / ) !real(kind=dp), allocatable :: irvec(:,:) integer , allocatable :: irvec (:,:) real ( kind = dp ), allocatable :: eigenval_intw (:,:) complex ( kind = dp ), allocatable :: u_mesh (:,:,:), ham_k (:,:,:), ham_r (:,:,:) complex ( kind = dp ), allocatable :: u_matrix (:,:,:), u_matrix_opt (:,:,:) ! contains ! !----------------------------------------------------------------------------! subroutine read_w90_chk () !----------------------------------------------------------------------------! ! This subroutine assumes set_num_bands() and read_nnkp_file() ! have been called before !----------------------------------------------------------------------------! use intw_reading , only : num_bands_intw , num_wann_intw use intw_input_parameters , only : outdir , prefix , nk1 , nk2 , nk3 use intw_utility , only : find_free_unit use intw_useful_constants , only : eps_8 use intw_intw2wannier , only : nnkp_exclude_bands , nnkp_num_kpoints , nnkp_kpoints implicit none character ( 20 ) :: checkpoint character ( 33 ) :: header character ( 256 ) :: filename integer :: io_unit_chk , nb , nexc , nkpt , nw , nntot integer :: n1 , n2 , n3 , i , j , ik , iw , ib integer :: exc_bands ( nnkp_exclude_bands ) real ( kind = dp ) :: dir_latt ( 3 , 3 ), rec_latt ( 3 , 3 ), omega_invariant , kp ( 3 ) real ( kind = dp ), allocatable :: kpts (:,:) io_unit_chk = find_free_unit () filename = trim ( outdir ) // trim ( prefix ) // trim ( '.chk' ) open ( unit = io_unit_chk , file = filename , status = 'old' , form = 'unformatted' ) ! .nnkp file should be read before calling this subroutine ! bands read ( io_unit_chk ) header read ( io_unit_chk ) nb ! no. of bands !JLB !if ( nb .ne. nbands ) then if ( nb . ne . num_bands_intw ) then write ( * , * ) \"Number of bands in .chk is not the same as num_bands_intw = nbands-exclude_bands in .nnkp file\" write ( * , * ) \"Stopping...\" stop end if read ( io_unit_chk ) nexc ! no. of excluded bands if ( nnkp_exclude_bands . ne . nexc ) then write ( * , * ) \" nexc in .chk is not the same as nnkp_exclude_bands in .nnkp file\" write ( * , * ) \"Stopping...\" stop end if read ( io_unit_chk ) exc_bands ( 1 : nexc ) ! excluded bands ! lattice read ( io_unit_chk ) (( dir_latt ( i , j ), i = 1 , 3 ), j = 1 , 3 ) ! direct read ( io_unit_chk ) (( rec_latt ( i , j ), i = 1 , 3 ), j = 1 , 3 ) ! reciprocal ! k grid read ( io_unit_chk ) nkpt if ( nkpt . ne . nnkp_num_kpoints ) then write ( * , * ) \"Number of k-points in .chk is not the same as in .nnkp file\" write ( * , * ) \"Stopping...\" stop end if read ( io_unit_chk ) n1 , n2 , n3 if ( ( n1 . ne . nk1 ) . or . ( n2 . ne . nk2 ) . or . ( n3 . ne . nk3 ) ) then write ( * , * ) \" nk1, nk2, nk3 in .chk is not the same as in INTW\" write ( * , * ) \"Stopping...\" stop end if allocate ( kpts ( 3 , nkpt )) read ( io_unit_chk ) (( kpts ( i , ik ), i = 1 , 3 ), ik = 1 , nkpt ) ! Check if kpts == nnkp_kpoints. ! Note that in intw2W90 we already checked that nnkp_kpoints ! coincide with the full-zone points provided by generate_kmesh do ik = 1 , nkpt kp = kpts (:, ik ) - nnkp_kpoints (:, ik ) if ( sqrt ( sum ( kp * kp )) > eps_8 ) then write ( * , * ) \"kpts list in .chk different from nnkp_kpoints (and INTW mesh)\" write ( * , * ) \"Stopping...\" stop end if end do read ( io_unit_chk ) nntot ! no. of neighbours, not used read ( io_unit_chk ) nw if ( nw . ne . num_wann_intw ) then write ( * , * ) \"Number of Wannier functions in .chk is not the same as number of projections in .nnkp file\" write ( * , * ) \"Stopping...\" stop end if read ( io_unit_chk ) checkpoint ! not used read ( io_unit_chk ) use_disentanglement ! u_matrix_opt allocate ( lwindow ( num_bands_intw , nnkp_num_kpoints ), ndimwin ( nnkp_num_kpoints )) allocate ( u_matrix_opt ( num_bands_intw , num_wann_intw , nnkp_num_kpoints )) if ( use_disentanglement ) then read ( io_unit_chk ) omega_invariant ! not used read ( io_unit_chk ) (( lwindow ( ib , ik ), ib = 1 , num_bands_intw ), ik = 1 , nnkp_num_kpoints ) read ( io_unit_chk ) ( ndimwin ( ik ), ik = 1 , nnkp_num_kpoints ) read ( io_unit_chk ) ((( u_matrix_opt ( ib , iw , ik ), ib = 1 , num_bands_intw ), iw = 1 , num_wann_intw ), ik = 1 , nnkp_num_kpoints ) end if ! u_matrix allocate ( u_matrix ( num_wann_intw , num_wann_intw , nnkp_num_kpoints )) read ( io_unit_chk ) ((( u_matrix ( ib , iw , ik ), ib = 1 , num_wann_intw ), iw = 1 , num_wann_intw ), ik = 1 , nnkp_num_kpoints ) ! These are also contained in .chk but, as for now, we do not use them in INTW: ! ! m_matrix ! centers ! spreads close ( io_unit_chk ) return end subroutine read_w90_chk ! !----------------------------------------------------------------------------! subroutine read_eig ( eigenval ) !----------------------------------------------------------------------------! ! Allocates and reads the eigenvalues for the relevant num_bands_intw from the .eig file    ! !----------------------------------------------------------------------------! use intw_input_parameters , only : outdir , prefix use intw_utility , only : find_free_unit use intw_reading , only : num_bands_intw use intw_intw2wannier , only : nnkp_num_kpoints ! I/O real ( kind = dp ), optional , intent ( out ) :: eigenval ( num_bands_intw , nnkp_num_kpoints ) ! Local variables character ( 256 ) :: filename integer :: io_unit , ik , ib , i , j allocate ( eigenval_intw ( num_bands_intw , nnkp_num_kpoints )) io_unit = find_free_unit () filename = trim ( outdir ) // trim ( prefix ) // trim ( '.eig' ) open ( unit = io_unit , file = filename , form = 'formatted' , status = 'old' ) ! do ik = 1 , nnkp_num_kpoints do ib = 1 , num_bands_intw ! read ( io_unit , * ) i , j , eigenval_intw ( ib , ik ) ! enddo enddo close ( io_unit ) if ( present ( eigenval )) eigenval = eigenval_intw end subroutine ! !----------------------------------------------------------------------------! subroutine allocate_and_build_u_mesh () !----------------------------------------------------------------------------! ! This is pretty much produce_u_mesh from W90_to_wannier ! ! This subroutine computes the \"rotation\" matrices which must be applied ! to the matrix elements to take them from band space to Wannier space. ! ! If disentanglement is used, u_mesh    = u_matrix_opt x u_matrix ! If no disentanglement is used, u_mesh = u_matrix ! ! note that the number of k-points in the coarse mesh, in Wannier90, ! is defined in the variable num_kpts. Consistency demands that this number ! be equal to nkmesh, the same quantity in the intw program. ! !----------------------------------------------------------------------------! use intw_useful_constants , only : cmplx_0 use intw_reading , only : num_bands_intw , num_wann_intw use intw_intw2wannier , only : nnkp_num_kpoints implicit none integer :: i , ik , n1 , n2 , nb1 call read_w90_chk () ! allocate and read use_disentanglement, lwindow, u_matrix_opt, u_matrix allocate ( u_mesh ( num_bands_intw , num_wann_intw , nnkp_num_kpoints )) !fullzone k-points u_mesh = cmplx_0 if ( use_disentanglement ) then do ik = 1 , nnkp_num_kpoints n1 = 0 do nb1 = 1 , num_bands_intw ! MBR-JBL: decided to use lwindow as in w90, instead of exclude_bands as in previus INTW version if (. not . lwindow ( nb1 , ik )) cycle ! At each k, bands are reordered so that ! u_matrix_opt for bands within the disentanglement window are filled first ! and the rest are just padded with zeros n1 = n1 + 1 do n2 = 1 , num_wann_intw do i = 1 , num_wann_intw !u_mesh(n1,n2,ik) = u_mesh(n1,n2,ik) + u_matrix_opt(n1,i,ik)*u_matrix(i,n2,ik) !MBR 10/05/24 correction. It should be: u_mesh ( nb1 , n2 , ik ) = u_mesh ( nb1 , n2 , ik ) + u_matrix_opt ( n1 , i , ik ) * u_matrix ( i , n2 , ik ) enddo !i enddo !n2 enddo !nb1 enddo !ik else u_mesh = u_matrix endif ! !deallocate arrays which are no longer useful !if (use_disentanglement) deallocate(u_matrix_opt) !deallocate(u_matrix) ! return end subroutine allocate_and_build_u_mesh !----------------------------------------------------------------------------! subroutine write_formatted_u_mesh () !----------------------------------------------------------------------------! use intw_reading , only : nbands , num_bands_intw , num_wann_intw use intw_input_parameters , only : outdir , prefix use intw_utility , only : find_free_unit use intw_intw2wannier , only : nnkp_exclude_bands , nnkp_excluded_bands , & nnkp_num_kpoints , nnkp_kpoints implicit none character ( 256 ) :: filename integer :: i , ik , ib , iw , io_unit_u io_unit_u = find_free_unit () filename = trim ( outdir ) // trim ( prefix ) // trim ( '.u_mesh' ) open ( unit = io_unit_u , file = filename , status = 'unknown' ) write ( io_unit_u , * ) 'NBANDS' write ( io_unit_u , * ) nbands write ( io_unit_u , * ) 'EXCLUDED_BANDS' write ( io_unit_u , * ) nnkp_exclude_bands write ( io_unit_u , * ) ( nnkp_excluded_bands ( i ), i = 1 , nbands ) write ( io_unit_u , * ) 'num_bands  num_wann  num_kpt' write ( io_unit_u , * ) num_bands_intw , num_wann_intw , nnkp_num_kpoints write ( io_unit_u , * ) 'USE_DISENTANGLEMENT' write ( io_unit_u , * ) use_disentanglement do ik = 1 , nnkp_num_kpoints ! ! MBR 20/12/24 change format: remove blank lines write ( io_unit_u , * ) 'K-POINT' , ik write ( io_unit_u , \"(3f16.10)\" ) ( nnkp_kpoints ( i , ik ), i = 1 , 3 ) write ( io_unit_u , * ) 'LWINDOW' write ( io_unit_u , * ) ( lwindow ( ib , ik ), ib = 1 , num_bands_intw ) write ( io_unit_u , * ) 'EIGENVALUES' write ( io_unit_u , \"(5es18.8)\" ) ( eigenval_intw ( ib , ik ), ib = 1 , num_bands_intw ) write ( io_unit_u , * ) 'u_mesh' do ib = 1 , num_bands_intw write ( io_unit_u , \"(5es18.8)\" ) ( u_mesh ( ib , iw , ik ), iw = 1 , num_wann_intw ) end do ! if ( use_disentanglement ) then write ( io_unit_u , * ) 'u_matrix_opt' do ib = 1 , num_bands_intw write ( io_unit_u , \"(5es18.8)\" ) ( u_matrix_opt ( ib , iw , ik ), iw = 1 , num_wann_intw ) end do write ( io_unit_u , * ) 'u_matrix' do ib = 1 , num_wann_intw write ( io_unit_u , \"(5es18.8)\" ) ( u_matrix ( ib , iw , ik ), iw = 1 , num_wann_intw ) end do end if ! end do close ( io_unit_u ) end subroutine write_formatted_u_mesh ! ! subroutine allocate_and_build_ws_irvec ( nk1 , nk2 , nk3 ) !----------------------------------------------------------------------------! !  Calculate real-space Wigner-Seitz lattice vectors !----------------------------------------------------------------------------! ! use intw_reading , only : at , alat use intw_useful_constants , only : eps_8 use intw_utility , only : generate_kmesh , cryst_to_cart ! implicit none ! integer , intent ( in ) :: nk1 , nk2 , nk3 ! logical :: in_ws integer :: ik , nboundary , i , j , k , l , l0 , l1 integer :: r_cryst_int ( 3 ), Rs ( 3 , n_wss ), ndegen_ws ( nk1 * nk2 * nk3 * n_wss ), irvec_ws ( 3 , nk1 * nk2 * nk3 * n_wss ) real ( kind = dp ) :: kmesh ( 3 , nk1 * nk2 * nk3 ) real ( kind = dp ) :: r_cryst ( 3 ), r_length_l , r_length_l1 , r_cart ( 3 ) ! call generate_kmesh ( kmesh , nk1 , nk2 , nk3 ) ! ! generate superlattice replica vectors search mesh l = 0 do i = - n_ws_search ( 1 ), n_ws_search ( 1 ) do j = - n_ws_search ( 2 ), n_ws_search ( 2 ) do k = - n_ws_search ( 3 ), n_ws_search ( 3 ) l = l + 1 Rs (:, l ) = ( / i , j , k / ) if ( i == 0 . and . j == 0 . and . k == 0 ) l0 = l ! Origin O end do end do end do ! nrpts = 0 ! total number of WS vectors do ik = 1 , nk1 * nk2 * nk3 ! do l = 1 , n_wss ! r-R(l), where for r-supercell-vector I use a conventional cell mesh of size nk1, nk2, nk3 ! and R(l) runs over replicas r_cryst = ( kmesh (:, ik ) - real ( Rs (:, l ), dp ) ) * real ( ( / nk1 , nk2 , nk3 / ), dp ) r_cryst_int = nint ( r_cryst ) !R-vector from crystallographic to cartesian r_cart = r_cryst call cryst_to_cart ( 1 , r_cart , at , 1 ) r_length_l = alat * sqrt ( sum ( r_cart * r_cart ) ) ! distance of r-R(l) to O (cartesian, bohr) ! ! r-R(l) is in the WS if its distance to O is shorter than its ! distance to any other O' origin. ! If it is equidistant, it lies on the boundary and is degenerate. in_ws = . true . nboundary = 1 ! ! Loop over origins O' given by R(l1) do l1 = 1 , n_wss ! r-R(l)-R(l1) r_cryst = ( kmesh (:, ik ) - real ( Rs (:, l ) + Rs (:, l1 ), dp ) ) * real ( ( / nk1 , nk2 , nk3 / ), dp ) r_cart = r_cryst call cryst_to_cart ( 1 , r_cart , at , 1 ) r_length_l1 = alat * sqrt ( sum ( r_cart * r_cart ) ) ! distance of r-R(l) to O' (cartesian, bohr) ! compare distances leaving a eps_8 gap if ( r_length_l > r_length_l1 + eps_8 . and . l1 /= l0 ) then ! not in the WS => remove vector from list in_ws = . false . exit else if ( abs ( r_length_l - r_length_l1 ) <= eps_8 . and . l1 /= l0 ) then ! on the boundary => add degeneracy nboundary = nboundary + 1 end if end do ! ! store r-R(l) and its degeneracy if it is inside WS if ( in_ws ) then nrpts = nrpts + 1 irvec_ws (:, nrpts ) = r_cryst_int ndegen_ws ( nrpts ) = nboundary end if ! end do end do ! ik ! ! Data for Wannier: WS kpoint list and degeneracies. ! Simply dismiss the array at sites >nrpts, which have not been used allocate ( irvec ( 3 , nrpts ) ) allocate ( ndegen ( nrpts ) ) ndegen = ndegen_ws ( 1 : nrpts ) do i = 1 , 3 irvec ( i ,:) = irvec_ws ( i , 1 : nrpts ) end do !JLB test !write (*, '(I5)') nrpts !write (*, '(15I5)') (ndegen(i), i=1, nrpts) !do i = 1, nrpts !      write (*, '(i5,3I6)') i, irvec(:, i) !end do return end subroutine allocate_and_build_ws_irvec ! !----------------------------------------------------------------------------! subroutine allocate_and_build_ham_k () !----------------------------------------------------------------------------! !  Construct ham_k with u_matrices on the fullzone k-mesh !----------------------------------------------------------------------------! ! use intw_useful_constants , only : cmplx_0 use intw_reading , only : num_wann_intw use intw_intw2wannier , only : nnkp_num_kpoints ! implicit none ! ! integer :: ik , iw , jw , nwin complex ( kind = dp ) :: cterm ! allocate ( ham_k ( num_wann_intw , num_wann_intw , nnkp_num_kpoints )) ham_k = cmplx_0 !$omp parallel do & !$omp default(none) & !$omp shared(nnkp_num_kpoints, num_wann_intw, use_disentanglement) & !$omp shared(ndimwin, u_mesh, eigenval_intw, lwindow, ham_k) & !$omp private(nwin, jw, iw, cterm) do ik = 1 , nnkp_num_kpoints nwin = ndimwin ( ik ) do jw = 1 , num_wann_intw do iw = 1 , jw ! JLB: Needs to be checked. I think lwindow has been incorporated in u_mesh building so here just multiply. if ( use_disentanglement ) then !  According to comment on lwindow in allocate_and_build_u_mesh, !  excl_bands should have been already excluded. ! Pick up eigenvalues inside the opt window for this k. ! They correspond to the first items in u_matrix_opt. cterm = sum ( conjg ( u_mesh ( 1 : nwin , iw , ik )) * pack ( eigenval_intw (:, ik ), lwindow (:, ik )) * u_mesh ( 1 : nwin , jw , ik ) ) else cterm = sum ( conjg ( u_mesh (:, iw , ik )) * eigenval_intw (:, ik ) * u_mesh (:, jw , ik ) ) end if !ham_k(iw,jw,ik) = ham_k(iw,jw,ik) + cterm ! force hermiticity !ham_k(jw,iw,ik) = ham_k(jw,iw,ik) + cterm !JLB (also changed order of jw, iw loops above): ham_k ( iw , jw , ik ) = cterm if ( iw . lt . jw ) ham_k ( jw , iw , ik ) = conjg ( cterm ) end do end do end do !$omp end parallel do ! return end subroutine allocate_and_build_ham_k ! TODO we may need another routine allocate_and_build_ham_k_for1k_only. ! Will need to find the k in the list first ! !----------------------------------------------------------------------------! subroutine allocate_and_build_ham_r () !----------------------------------------------------------------------------! !  Construct ham_r by Fourier transform of ham_k, k in the fullzone k-mesh !----------------------------------------------------------------------------! ! use intw_reading , only : num_wann_intw use intw_useful_constants , only : tpi , cmplx_0 , cmplx_i use intw_intw2wannier , only : nnkp_num_kpoints , nnkp_kpoints ! implicit none ! integer :: ik , i , ib , jb complex ( kind = dp ) :: phasefac ! allocate ( ham_r ( num_wann_intw , num_wann_intw , nrpts )) ham_r = cmplx_0 !$omp parallel do & !$omp default(none) & !$omp shared(nrpts, nnkp_num_kpoints, num_wann_intw) & !$omp shared(nnkp_kpoints, irvec, ham_k, ham_r) & !$omp private(ik, ib, jb, phasefac) do i = 1 , nrpts do ik = 1 , nnkp_num_kpoints do ib = 1 , num_wann_intw do jb = 1 , num_wann_intw phasefac = exp ( - cmplx_i * tpi * sum ( nnkp_kpoints (:, ik ) * irvec (:, i ) ) ) ham_r ( ib , jb , i ) = ham_r ( ib , jb , i ) + phasefac * ham_k ( ib , jb , ik ) end do end do enddo enddo !$omp end parallel do ham_r = ham_r / real ( nnkp_num_kpoints , dp ) return end subroutine allocate_and_build_ham_r ! !----------------------------------------------------------------------------! subroutine write_ham_r () !----------------------------------------------------------------------------! !  Write ham_r to file, to check decay (and compare to w90 if needed) !----------------------------------------------------------------------------! ! use intw_utility , only : find_free_unit use intw_input_parameters , only : outdir , prefix use intw_reading , only : num_wann_intw use intw_intw2wannier , only : generate_header ! implicit none ! character ( 256 ) :: filename , header integer :: io_unit , ir , in , jn ! io_unit = find_free_unit () filename = trim ( outdir ) // trim ( prefix ) // trim ( '_hr_intw.dat' ) open ( io_unit , file = filename , form = 'formatted' , status = 'unknown' ) call generate_header ( ' ' , header ) write ( io_unit , * ) trim ( header ) write ( io_unit , * ) num_wann_intw write ( io_unit , * ) nrpts write ( io_unit , '(15I5)' ) ( ndegen ( ir ), ir = 1 , nrpts ) do ir = 1 , nrpts do in = 1 , num_wann_intw do jn = 1 , num_wann_intw ! JLB: I would increase the writing accuracy, here just same as w90 for comparison write ( io_unit , '(5I5,2F12.6)' ) irvec (:, ir ), jn , in , ham_r ( jn , in , ir ) end do end do end do close ( io_unit ) return end subroutine write_ham_r ! ! MBR new routines 28/08/23: ! allocate_and_read_u_mesh and _ham_r: reads previously generated and ! printed u_mesh and _ham_r by utility W902intw. ! !----------------------------------------------------------------------------! subroutine allocate_and_read_ham_r () ! !----------------------------------------------------------------------------! !  MBR: !  This reads: nrpts, ndegen, irvec, ham_r !  (num_bands_intw, num_wann_intw have been read previously from nnkp using set_numbands) !  from formatted file outdir/prefix_hr_intw.dat !----------------------------------------------------------------------------! ! use intw_useful_constants , only : cmplx_0 use intw_utility , only : find_free_unit use intw_reading , only : num_wann_intw use intw_input_parameters , only : outdir , prefix ! implicit none ! character ( 256 ) :: filename , header integer :: io_unit , ir , in , jn , i , j ! ! open file and read dimensions ! io_unit = find_free_unit () filename = trim ( outdir ) // trim ( prefix ) // trim ( '_hr_intw.dat' ) open ( io_unit , file = filename , form = 'formatted' , status = 'old' ) read ( io_unit , * ) header read ( io_unit , * ) ir if ( ir . ne . num_wann_intw ) then write ( * , * ) 'num_wann_intw in ' , filename , ' does not coincide with nnkp value. Stopping.' stop end if read ( io_unit , * ) nrpts ! ! allocate arrays ! careful, in case they had been allocated by previous call to build ham_r ! note: if irvec has been calculated before, reading the _hr file will ! overwrite it ! if (. not . allocated ( ndegen )) & allocate ( ndegen ( nrpts )) if (. not . allocated ( irvec )) & allocate ( irvec ( 3 , nrpts ) ) if (. not . allocated ( ham_r )) & allocate ( ham_r ( num_wann_intw , num_wann_intw , nrpts )) ndegen = 0 irvec = 0 ham_r = cmplx_0 ! ! read irvec, ham_r ! read ( io_unit , '(15I5)' ) ( ndegen ( ir ), ir = 1 , nrpts ) do ir = 1 , nrpts do in = 1 , num_wann_intw do jn = 1 , num_wann_intw read ( io_unit , '(5I5,2F12.6)' ) irvec (:, ir ), j , i , ham_r ( jn , in , ir ) end do end do end do ! close ( io_unit ) ! return end subroutine allocate_and_read_ham_r subroutine allocate_and_read_u_mesh ! !----------------------------------------------------------------------------! !  MBR: !  This reads all dimensions in the W90 problem !  (except for nbands, num_bands_intw, num_wann_intw have been read previously !  from nnkp using set_numbands) !  which include: nnkp_num_kpoints, nnkp_exclude_bands, !  and quantities use_disentanglement, nnkp_excluded_bands, & !  nnkp_kpoints, eigenval, lwindow, u_mesh, etc. !  from formatted file outdir/prefix_u_mesh.dat ! !----------------------------------------------------------------------------! ! use intw_reading , only : nbands , num_bands_intw , num_wann_intw use intw_input_parameters , only : outdir , prefix use intw_utility , only : find_free_unit use intw_intw2wannier , only : nnkp_exclude_bands , nnkp_excluded_bands , & nnkp_num_kpoints , nnkp_kpoints implicit none character ( 256 ) :: filename , varname integer :: i , ik , ib , iw , io_unit_u io_unit_u = find_free_unit () filename = trim ( outdir ) // trim ( prefix ) // trim ( '.u_mesh' ) open ( unit = io_unit_u , file = filename , status = 'old' ) read ( io_unit_u , * ) varname !'NBANDS' read ( io_unit_u , * ) ib if ( ib . ne . nbands ) then write ( * , * ) 'nbands in ' , filename , ' does not coincide with value in QE. Stopping.' stop end if read ( io_unit_u , * ) varname !'EXCLUDED_BANDS' read ( io_unit_u , * ) nnkp_exclude_bands if (. not . allocated ( nnkp_excluded_bands )) & allocate ( nnkp_excluded_bands ( nbands )) read ( io_unit_u , * ) ( nnkp_excluded_bands ( i ), i = 1 , nbands ) read ( io_unit_u , * ) varname !'num_bands  num_wann  num_kpt' read ( io_unit_u , * ) ib , iw , nnkp_num_kpoints if ( ib . ne . num_bands_intw ) then write ( * , * ) 'num_bands_intw in ' , filename , ' does not coincide with nnkp value. Stopping.' stop end if if ( iw . ne . num_wann_intw ) then write ( * , * ) 'num_wann_intw in ' , filename , ' does not coincide with nnkp value. Stopping.' stop end if read ( io_unit_u , * ) varname ! 'USE_DISENTANGLEMENT' read ( io_unit_u , * ) use_disentanglement ! ! allocate quantities ! (careful in case allocate_and_build had been called first) ! if (. not . allocated ( nnkp_kpoints )) & allocate ( nnkp_kpoints ( 3 , nnkp_num_kpoints )) if (. not . allocated ( lwindow )) & allocate ( lwindow ( num_bands_intw , nnkp_num_kpoints )) if (. not . allocated ( eigenval_intw )) & allocate ( eigenval_intw ( num_bands_intw , nnkp_num_kpoints )) if (. not . allocated ( u_mesh )) & allocate ( u_mesh ( num_bands_intw , num_wann_intw , nnkp_num_kpoints )) if ( use_disentanglement ) then if (. not . allocated ( u_matrix_opt )) & allocate ( u_matrix_opt ( num_bands_intw , num_wann_intw , nnkp_num_kpoints )) if (. not . allocated ( u_matrix )) & allocate ( u_matrix ( num_wann_intw , num_wann_intw , nnkp_num_kpoints )) end if ! do ik = 1 , nnkp_num_kpoints ! ! MBR 20/12/24 change format: remove blank lines read ( io_unit_u , * ) varname ! 'K-POINT', ik read ( io_unit_u , \"(3f16.10)\" ) ( nnkp_kpoints ( i , ik ), i = 1 , 3 ) read ( io_unit_u , * ) varname ! 'LWINDOW' read ( io_unit_u , * ) ( lwindow ( ib , ik ), ib = 1 , num_bands_intw ) read ( io_unit_u , * ) varname ! 'EIGENVALUES' read ( io_unit_u , \"(5es18.8)\" ) ( eigenval_intw ( ib , ik ), ib = 1 , num_bands_intw ) read ( io_unit_u , * ) varname ! 'u_mesh' do ib = 1 , num_bands_intw read ( io_unit_u , \"(5es18.8)\" ) ( u_mesh ( ib , iw , ik ), iw = 1 , num_wann_intw ) end do ! if ( use_disentanglement ) then read ( io_unit_u , * ) varname ! 'u_matrix_opt' do ib = 1 , num_bands_intw read ( io_unit_u , \"(5es18.8)\" ) ( u_matrix_opt ( ib , iw , ik ), iw = 1 , num_wann_intw ) end do read ( io_unit_u , * ) varname ! 'u_matrix' do ib = 1 , num_wann_intw read ( io_unit_u , \"(5es18.8)\" ) ( u_matrix ( ib , iw , ik ), iw = 1 , num_wann_intw ) end do end if ! end do ! close ( io_unit_u ) ! end subroutine allocate_and_read_u_mesh ! Finally, modules for interpolation utilities subroutine interpolate_1k ( kpoint , eig_int , u_interp ) ! !----------------------------------------------------------------------------! !  MBR: !  Given a kpoint in crystal coordinates, it interpolates the eigenvalues !  using already available variables eigenval_intw, ham_r, ir_vec, ndegen, nrpts. ! !  Interpolation matrix, which can be used to obtain weights for fatbands, !  is an optional output ! !----------------------------------------------------------------------------! ! use intw_useful_constants , only : cmplx_0 , cmplx_i , tpi use intw_reading , only : num_wann_intw ! implicit none ! integer :: ir , i , j real ( kind = dp ), intent ( in ) :: kpoint ( 3 ) real ( kind = dp ), intent ( out ) :: eig_int ( num_wann_intw ) complex ( kind = dp ) :: cfac complex ( kind = dp ) :: ham_pack_1k (( num_wann_intw * ( num_wann_intw + 1 )) / 2 ) complex ( kind = dp ) :: u_pass ( num_wann_intw , num_wann_intw ) complex ( kind = dp ) , optional , intent ( out ) :: u_interp ( num_wann_intw , num_wann_intw ) ! for ZHPEVX we use the same dimensions as W90 does integer :: neig_found , info integer :: iwork ( 5 * num_wann_intw ), ifail ( num_wann_intw ) real ( kind = dp ) :: rwork ( 7 * num_wann_intw ) complex ( kind = dp ) :: cwork ( 2 * num_wann_intw ) ! external :: ZHPEVX ! ! generate ham_k directly packed at this point ! ham_pack_1k = cmplx_0 do ir = 1 , nrpts cfac = exp ( cmplx_i * tpi * dot_product ( kpoint (:), irvec (:, ir ))) / real ( ndegen ( ir ), dp ) do j = 1 , num_wann_intw do i = 1 , j ham_pack_1k ( i + (( j - 1 ) * j ) / 2 ) = ham_pack_1k ( i + (( j - 1 ) * j ) / 2 ) + cfac * ham_r ( i , j , ir ) end do end do end do ! ! diagonalize ! Note: actual Wannier interpolation matrix will be upass&#94;dagger ! eig_int = 0.0_dp call ZHPEVX ( 'V' , 'A' , 'U' , num_wann_intw , ham_pack_1k , & 0.0_dp , 0.0_dp , 0 , 0 , - 1.0_dp , & neig_found , eig_int , u_pass , num_wann_intw , & cwork , rwork , iwork , ifail , info ) ! if ( info < 0 ) then write ( * , * ) 'Wrong argument in ZHPEVX. Stopping.' stop else if ( info > 0 ) then write ( * , * ) 'ZHPEVX failed. Stopping.' stop end if ! ! Interpolation matrix each eigenergy on the WFs ! if ( present ( u_interp )) then u_interp = conjg ( transpose ( u_pass )) end if ! end subroutine interpolate_1k subroutine interpolated_DOS ( nik1 , nik2 , nik3 , eini , efin , esmear , ne , DOS , PDOS ) ! !----------------------------------------------------------------------------! !  MBR: ! !  Calculate DOS using a fine grid nik1 x nik2 x nik3 !  and a lorentzian smearing. !  Optionally, write PDOS using weights from u_interp ! !----------------------------------------------------------------------------! ! use intw_useful_constants , only : cmplx_0 , cmplx_i , tpi use intw_reading , only : num_wann_intw use intw_utility , only : smeared_lorentz ! implicit none ! integer :: ik1 , ik2 , ik3 , ie , iw integer , intent ( in ) :: nik1 , nik2 , nik3 , ne real ( kind = dp ), intent ( in ) :: eini , efin , esmear real ( kind = dp ), intent ( out ) :: DOS ( ne ) real ( kind = dp ), optional , intent ( out ) :: PDOS ( ne , num_wann_intw ) real ( kind = dp ) :: ener , estep , lorentz real ( kind = dp ) :: kpoint ( 3 ), eig_int ( num_wann_intw ) complex ( kind = dp ) :: u_interp ( num_wann_intw , num_wann_intw ) estep = ( efin - eini ) / real ( ne - 1 , dp ) DOS = 0.0_dp if ( present ( PDOS )) PDOS = 0.0_dp ! construct fine grid of kpoints, interpolate 1 by 1 and add ! contribution to DOS(e) !$omp parallel do collapse(3) reduction(+: DOS, PDOS) & !$omp default(none) & !$omp shared(nik1, nik2, nik3, num_wann_intw) & !$omp shared(ne, eini, estep, esmear) & !$omp private(kpoint, eig_int, u_interp) & !$omp private(ie, iw, ener, lorentz) do ik1 = 1 , nik1 do ik2 = 1 , nik2 do ik3 = 1 , nik3 kpoint ( 1 ) = real ( ik1 - 1 , dp ) / real ( nik1 , dp ) kpoint ( 2 ) = real ( ik2 - 1 , dp ) / real ( nik2 , dp ) kpoint ( 3 ) = real ( ik3 - 1 , dp ) / real ( nik3 , dp ) ! call interpolate_1k ( kpoint , eig_int , u_interp ) do ie = 1 , ne ener = eini + ( ie - 1 ) * estep do iw = 1 , num_wann_intw !lorentz = 1.0_dp / ((ener-eig_int(iw))**2+esmear**2) !lorentz = lorentz * 0.5_dp*esmear/tpi lorentz = smeared_lorentz ( ener - eig_int ( iw ), esmear ) DOS ( ie ) = DOS ( ie ) + lorentz if ( present ( PDOS )) PDOS ( ie ,:) = PDOS ( ie ,:) + lorentz * ( abs ( u_interp ( iw ,:))) ** 2 end do end do ! end do end do end do !$omp end parallel do DOS = DOS / real ( nik1 * nik2 * nik3 , dp ) ! normalize for Nk points PDOS = PDOS / real ( nik1 * nik2 * nik3 , dp ) ! normalize for Nk points ! end subroutine interpolated_DOS subroutine wann_rotate_matrix ( ik1 , ik2 , matin , matout ) ! !----------------------------------------------------------------------------! !  MBR 9/1/24: !  Given a matrix 2x2 of elements on the coarse k-mesh, this routine !  rotates it to the Wannier gauge: !  Mat_out(ik1,ik2) =  U&#94;dagger(ik1) * Mat_in(ik1,ik2) * U(ik2) !  where U is u_mesh, i.e. it already accounts for the entanglement option, !  taking the elements from band space to Wannier space. ! !  It is assumed that the u_mesh has been built or read already. !----------------------------------------------------------------------------! ! use intw_useful_constants , only : cmplx_0 use intw_reading , only : num_bands_intw , num_wann_intw ! implicit none ! integer , intent ( in ) :: ik1 , ik2 complex ( kind = dp ) , intent ( in ) :: matin ( num_bands_intw , num_bands_intw ) complex ( kind = dp ) , intent ( out ) :: matout ( num_wann_intw , num_wann_intw ) ! integer :: iw , jw , ib , jb ! matout = cmplx_0 do iw = 1 , num_wann_intw do jw = 1 , num_wann_intw do ib = 1 , num_bands_intw do jb = 1 , num_bands_intw matout ( iw , jw ) = matout ( iw , jw ) + conjg ( u_mesh ( ib , iw , ik1 )) * matin ( ib , jb ) * u_mesh ( jb , jw , ik2 ) end do end do end do end do ! return end subroutine wann_rotate_matrix subroutine wann_fourier_1index ( matL , matk , switch , sig ) ! !----------------------------------------------------------------------------! !  MBR 9/1/24: !  Given a matrix of elements to be interpolated, this routine acts on one of !  the indices, which contains the input dataset (complex). !  Depending on the switch, it does the (inverse) Fourier transform between the !  coarse k-mesh vectors and the direct lattice vectors L (Wigner-Seitz). !  The inverse FT on the matrix elements rotated to the Wannier gauge !  is what will be used in a parent routine or utility for interpolation. !  switch = 1 does L --> k ( FT) !  switch =-1 does k --> L (IFT) !  The optional sign \"sig\" choses the sign to be used in the exponential. !  If not specified, the usual (I)FT convention is used  (same as switch). !  It is useful when you want to (I)FT matrix elements on the bra/ket sides !  with the corresponding sign. !----------------------------------------------------------------------------! ! use intw_useful_constants , only : cmplx_0 , cmplx_i , tpi use intw_reading , only : num_wann_intw use intw_intw2wannier , only : nnkp_num_kpoints , nnkp_kpoints ! implicit none ! integer , intent ( in ) :: switch integer , optional , intent ( in ) :: sig complex ( kind = dp ) , intent ( inout ) :: matk ( num_wann_intw , num_wann_intw , nnkp_num_kpoints ), & matL ( num_wann_intw , num_wann_intw , nrpts ) ! integer :: ir , ik real ( kind = dp ) :: signo complex ( kind = dp ) :: fac ! if ( switch . eq . - 1 ) then ! IFT ! signo = - 1.0_dp if ( present ( sig )) signo = real ( sig , dp ) ! matL = cmplx_0 do ir = 1 , nrpts do ik = 1 , nnkp_num_kpoints fac = exp ( signo * cmplx_i * tpi * dot_product ( nnkp_kpoints (:, ik ), irvec (:, ir ))) matL (:,:, ir ) = matL (:,:, ir ) + fac * matk (:,:, ik ) end do end do matL = matL / real ( nnkp_num_kpoints , dp ) ! else if ( switch . eq . 1 ) then ! FT ! signo = 1.0_dp if ( present ( sig )) signo = real ( sig , dp ) ! matk = cmplx_0 do ik = 1 , nnkp_num_kpoints do ir = 1 , nrpts fac = exp ( signo * cmplx_i * tpi * dot_product ( nnkp_kpoints (:, ik ), irvec (:, ir ))) / real ( ndegen ( ir ), dp ) matk (:,:, ik ) = matk (:,:, ik ) + fac * matL (:,:, ir ) end do end do ! else write ( * , * ) ' Error in switch of wann_fourier_1index. Stopping' stop end if ! return end subroutine wann_fourier_1index subroutine wann_IFT_1index ( nks , kpoints , matk , matL ) ! !----------------------------------------------------------------------------! !  MBR 9/1/24: !  This does the same as wann_fourier_1index with switch -1, !  but for a given kpoints list !----------------------------------------------------------------------------! ! use intw_useful_constants , only : cmplx_0 , cmplx_i , tpi use intw_reading , only : num_wann_intw ! implicit none ! integer , intent ( in ) :: nks real ( kind = dp ) , intent ( in ) :: kpoints ( 3 , nks ) complex ( kind = dp ) , intent ( in ) :: matk ( num_wann_intw , num_wann_intw , nks ) complex ( kind = dp ) , intent ( out ) :: matL ( num_wann_intw , num_wann_intw , nrpts ) ! integer :: ir , ik complex ( kind = dp ) :: fac matL = cmplx_0 do ir = 1 , nrpts do ik = 1 , nks fac = exp ( - cmplx_i * tpi * dot_product ( kpoints (:, ik ), irvec (:, ir ))) matL (:,:, ir ) = matL (:,:, ir ) + fac * matk (:,:, ik ) end do end do matL = matL / real ( nks , dp ) return end subroutine wann_IFT_1index subroutine wann_FT_1index_1k ( kpoint , matL , matk ) ! !----------------------------------------------------------------------------! !  MBR 9/1/24: !  As above, for one index of a matrix of elements in the direct lattice grid, and given any kpoint !  (this is the interpolation step) this calculates !   sum_L e&#94;ikL mat(L) / degen(L) !----------------------------------------------------------------------------! ! ! use intw_useful_constants , only : cmplx_0 , cmplx_i , tpi use intw_reading , only : num_wann_intw ! implicit none ! real ( kind = dp ) , intent ( in ) :: kpoint ( 3 ) complex ( kind = dp ) , intent ( in ) :: matL ( num_wann_intw , num_wann_intw , nrpts ) complex ( kind = dp ) , intent ( out ) :: matk ( num_wann_intw , num_wann_intw ) ! integer :: ir complex ( kind = dp ) :: fac ! matk = cmplx_0 do ir = 1 , nrpts fac = exp ( cmplx_i * tpi * dot_product ( kpoint (:), irvec (:, ir ))) / real ( ndegen ( ir ), dp ) matk (:,:) = matk (:,:) + fac * matL (:,:, ir ) end do ! return end subroutine wann_FT_1index_1k !----------------------------------------------------------------------------! end module intw_w90_setup !----------------------------------------------------------------------------!","tags":"","url":"sourcefile/w90_setup.f90.html"},{"title":"intw2wannier.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_intw2wannier !! display: none !! !! This module contains variables and subroutines to perform the same tasks !! as the Quantum Espresso post-processing program \"pw2wannier90\", but using !! symmetries. !! !! ### Details !! !! In particular, this module contains: !! - subroutines and variables for reading and storing $seed.nnkp file data. !! - subroutines for producing the $seed.mmn and $seed.amn files using !!   only the wave functions in the IBZ, rotating them appropriately. !! use kinds , only : dp implicit none ! variables public :: nnkp_exclude_bands , nnkp_real_lattice , nnkp_recip_lattice , & nnkp_num_kpoints , nnkp_nnkpts , nnkp_n_proj , nnkp_kpoints , & nnkp_Wcenters , nnkp_proj_x , nnkp_proj_z , nnkp_proj_zona , & nnkp_proj_n , nnkp_proj_l , nnkp_proj_m , & nnkp_proj_s , nnkp_proj_spin_axis , & nnkp_list_ikpt_nn , nnkp_list_G , nnkp_excluded_bands ! subroutines public :: deallocate_nnkp , read_nnkp_file , output_nnkp_file , & intw2W90_check_mesh , generate_header , & generate_mmn_using_allwfc , generate_amn_using_allwfc , & generate_guiding_function , & get_guiding_function_overlap_FFT , & get_guiding_function_overlap_convolution , get_radial_part , & get_angular_part , ylm_wannier !, get_bvec_list private ! declare some global variables; the prefix \"nnkp\" will indicate ! variables read from the $prefix.nnkp file, which must be checked with ! the data read from the input file for consistency. integer :: nnkp_exclude_bands !how many bands are excluded? real ( dp ) :: nnkp_real_lattice ( 3 , 3 ) ! the lattice vectors ! These are in angstrom coordinates in the file ! but will be transformed to alat cartesian ! coordinates real ( dp ) :: nnkp_recip_lattice ( 3 , 3 ) ! the reciprocal lattice vectors ! These are in angstrom&#94;-1 coordinates in the file ! but will be transformed to 2pi/alat cartesian ! coordinates integer :: nnkp_num_kpoints !the number of k-points in the 1BZ integer :: nnkp_nnkpts !the number near neighbor k-points integer :: nnkp_n_proj !the number of projections specified !(should be the same as number of Wannier functions) real ( dp ), allocatable :: nnkp_kpoints (:,:) ! the k vectors in the 1BZ real ( dp ), allocatable :: nnkp_Wcenters (:,:) ! the Wannier centers, for trial projection real ( dp ), allocatable :: nnkp_proj_x (:,:) ! x projection, for trial real ( dp ), allocatable :: nnkp_proj_z (:,:) ! z projection, for trial real ( dp ), allocatable :: nnkp_proj_zona (:) ! Z on a: gauge broadness of the hydrogenoid trial wfc. ! The hydrogenoid quantum numbers, psi_{nlm} integer , allocatable :: nnkp_proj_n (:) ! the radial-pojection, for trial integer , allocatable :: nnkp_proj_l (:) ! the l-pojection, for trial integer , allocatable :: nnkp_proj_m (:) ! the m-pojection, for trial ! JLB: Extra variables for spinor projections real ( dp ), allocatable :: nnkp_proj_spin_axis (:,:) ! spin quantization axis for spinor projection integer , allocatable :: nnkp_proj_s (:) ! up or down spin integer , allocatable :: nnkp_list_ikpt_nn (:,:) ! the neighbors of ikpt1 integer , allocatable :: nnkp_list_G (:,:,:) ! the G vectors linking one point to another logical , allocatable :: nnkp_excluded_bands (:) ! what bands are excluded contains subroutine deallocate_nnkp () use intw_reading , only : lspin implicit none deallocate ( nnkp_kpoints ) deallocate ( nnkp_Wcenters ) deallocate ( nnkp_proj_l ) deallocate ( nnkp_proj_m ) deallocate ( nnkp_proj_n ) deallocate ( nnkp_proj_x ) deallocate ( nnkp_proj_z ) deallocate ( nnkp_proj_zona ) if ( lspin ) deallocate ( nnkp_proj_spin_axis ) if ( lspin ) deallocate ( nnkp_proj_s ) deallocate ( nnkp_list_ikpt_nn ) deallocate ( nnkp_list_G ) deallocate ( nnkp_excluded_bands ) end subroutine deallocate_nnkp subroutine read_nnkp_file ( nnkp_file ) !----------------------------------------------------------------------------! ! This subroutine reads the .nnkp input file produced by W90. ! It assumes the file has been checked for existence and is already ! opened. !----------------------------------------------------------------------------! use intw_useful_constants , only : bohr , tpi , eps_8 use intw_reading , only : nbands , alat , lspin , scan_file_to use intw_utility , only : find_free_unit implicit none integer :: nnkp_unit integer :: i , j , nn , dummy character ( * ) :: nnkp_file ! read in the various quantities stored in the .nnkp parameters file. nnkp_unit = find_free_unit () ! !=============================== ! open the file, which exists! !=============================== ! open ( unit = nnkp_unit , file = nnkp_file , status = 'old' ) ! !======================= ! real lattice vectors !======================= ! call scan_file_to ( nnkp_unit , 'real_lattice' ) ! do j = 1 , 3 ! read ( nnkp_unit , * ) ( nnkp_real_lattice ( i , j ), i = 1 , 3 ) ! enddo ! ! convert to alat coordinates ! nnkp_real_lattice = nnkp_real_lattice / ( alat * bohr ) ! !============================== ! reciprocal lattice vectors !============================== ! call scan_file_to ( nnkp_unit , 'recip_lattice' ) ! do j = 1 , 3 ! read ( nnkp_unit , * ) ( nnkp_recip_lattice ( i , j ), i = 1 , 3 ) ! enddo ! ! convert to 2pi/alat coordinates ! nnkp_recip_lattice = nnkp_recip_lattice * ( alat * bohr ) / tpi ! !====================================== ! kpoints in the zone (crystal units) !====================================== ! call scan_file_to ( nnkp_unit , 'kpoints' ) read ( nnkp_unit , * ) nnkp_num_kpoints ! allocate ( nnkp_kpoints ( 3 , nnkp_num_kpoints )) ! do j = 1 , nnkp_num_kpoints ! read ( nnkp_unit , * ) ( nnkp_kpoints ( i , j ), i = 1 , 3 ) ! enddo ! !========================== ! projection information !========================== ! if ( lspin ) then call scan_file_to ( nnkp_unit , 'spinor_projections' ) read ( nnkp_unit , * ) nnkp_n_proj allocate ( nnkp_proj_s ( nnkp_n_proj )) allocate ( nnkp_proj_spin_axis ( 3 , nnkp_n_proj )) else call scan_file_to ( nnkp_unit , 'projections' ) read ( nnkp_unit , * ) nnkp_n_proj end if ! allocate ( nnkp_Wcenters ( 3 , nnkp_n_proj )) allocate ( nnkp_proj_l ( nnkp_n_proj )) allocate ( nnkp_proj_m ( nnkp_n_proj )) allocate ( nnkp_proj_n ( nnkp_n_proj )) allocate ( nnkp_proj_x ( 3 , nnkp_n_proj )) allocate ( nnkp_proj_z ( 3 , nnkp_n_proj )) allocate ( nnkp_proj_zona ( nnkp_n_proj )) ! do j = 1 , nnkp_n_proj ! read ( nnkp_unit , * ) ( nnkp_Wcenters ( i , j ), i = 1 , 3 ), & nnkp_proj_l ( j ), & nnkp_proj_m ( j ), & nnkp_proj_n ( j ) ! read ( nnkp_unit , * ) ( nnkp_proj_z ( i , j ), i = 1 , 3 ), & ( nnkp_proj_x ( i , j ), i = 1 , 3 ), & nnkp_proj_zona ( j ) ! if ( lspin ) then read ( nnkp_unit , * ) nnkp_proj_s ( j ), nnkp_proj_spin_axis (:, j ) ! Check if ( abs ( nnkp_proj_s ( j )) /= 1 ) then write ( * , * ) \"Error in spinor projection! Should be +-1\" write ( * , * ) \"Stopping...\" stop else if ( abs ( nnkp_proj_spin_axis ( 1 , j )) > eps_8 & . or . abs ( nnkp_proj_spin_axis ( 2 , j )) > eps_8 & . or . abs ( nnkp_proj_spin_axis ( 3 , j ) - 1 ) > eps_8 ) then write ( * , * ) \"Currently, only (/0, 0, 1/) spin-axis orientation implemented\" write ( * , * ) \"Stopping...\" stop end if ! end if ! enddo ! !========================================== ! connection information (near neighbors) !========================================== ! call scan_file_to ( nnkp_unit , 'nnkpts' ) ! read ( nnkp_unit , * ) nnkp_nnkpts ! allocate ( nnkp_list_ikpt_nn ( nnkp_nnkpts , nnkp_num_kpoints )) allocate ( nnkp_list_G ( 3 , nnkp_nnkpts , nnkp_num_kpoints )) ! do j = 1 , nnkp_num_kpoints do nn = 1 , nnkp_nnkpts ! read ( nnkp_unit , * ) dummy , nnkp_list_ikpt_nn ( nn , j ),( nnkp_list_G ( i , nn , j ), i = 1 , 3 ) ! enddo enddo ! !================= ! band exclusion !================= ! call scan_file_to ( nnkp_unit , 'exclude_bands ' ) ! read ( nnkp_unit , * ) nnkp_exclude_bands ! ! JLB: Now this is done in reading.f90 -> set_num_bands !      Here only poulating nnkp_* variables, !      then check for consistency with intw_* in main program / utility !num_exclude_bands=nnkp_exclude_bands !allocate(exclude_bands(num_exclude_bands)) ! allocate ( nnkp_excluded_bands ( nbands )) ! nnkp_excluded_bands (:) = . false . ! do j = 1 , nnkp_exclude_bands ! read ( nnkp_unit , * ) nn nnkp_excluded_bands ( nn ) = . true . !exclude_bands(j)=nn ! enddo ! !============= ! close file !============= ! close ( unit = nnkp_unit ) ! return end subroutine read_nnkp_file subroutine output_nnkp_file () !----------------------------------------------------------------------------! ! This subroutine simply outputs what was read from the nnkp file, for ! testing. !----------------------------------------------------------------------------! use intw_reading , only : lspin use intw_utility , only : find_free_unit implicit none integer :: io_unit integer :: i , j , nn io_unit = find_free_unit () open ( unit = io_unit , file = 'nnkp.test' , status = 'unknown' ) write ( io_unit , * ) '=====================================================' write ( io_unit , * ) '|            content of prefix.nnkp                 |' write ( io_unit , * ) '|        ---------------------------------          |' write ( io_unit , * ) '|        This file is generated for testing         |' write ( io_unit , * ) '|        purposes; it should be compared to         |' write ( io_unit , * ) '|        the actual .nnkp file to check             |' write ( io_unit , * ) '|        consistency.                               |' write ( io_unit , * ) '=====================================================' write ( io_unit , * ) 'nnkp_real_lattice' write ( io_unit , * ) '-----------------' do j = 1 , 3 write ( io_unit , '(3F8.4)' ) ( nnkp_real_lattice ( i , j ), i = 1 , 3 ) end do write ( io_unit , * ) '' write ( io_unit , * ) 'nnkp_recip_lattice' write ( io_unit , * ) '------------------' do j = 1 , 3 write ( io_unit , '(3F8.4)' ) ( nnkp_recip_lattice ( i , j ), i = 1 , 3 ) end do write ( io_unit , * ) '' write ( io_unit , '(a,I6)' ) 'nnkp_num_kpoints = ' , nnkp_num_kpoints write ( io_unit , * ) '' write ( io_unit , '(a,I6)' ) 'k-points' write ( io_unit , '(a,I6)' ) '--------' do j = 1 , nnkp_num_kpoints write ( io_unit , '(3F8.4)' ) ( nnkp_kpoints ( i , j ), i = 1 , 3 ) end do write ( io_unit , '(a,I6)' ) 'nnkp_n_proj= ' , nnkp_n_proj write ( io_unit , * ) '' write ( io_unit , * ) 'projection information' write ( io_unit , * ) '----------------------' write ( io_unit , * ) '  n          center           l   m   n          proj_z                  proj_x            Z/a' write ( io_unit , * ) '---------------------------------------------------------------------------------------------------' do j = 1 , nnkp_n_proj write ( io_unit , 100 ) j ,( nnkp_Wcenters ( i , j ), i = 1 , 3 ), & nnkp_proj_l ( j ), & nnkp_proj_m ( j ), & nnkp_proj_n ( j ), & ( nnkp_proj_z ( i , j ), i = 1 , 3 ), & ( nnkp_proj_x ( i , j ), i = 1 , 3 ), & nnkp_proj_zona ( j ) if ( lspin ) then write ( io_unit , '(I6, 3F12.6)' ) nnkp_proj_s ( j ), & ( nnkp_proj_spin_axis ( i , j ), i = 1 , 3 ) end if end do write ( io_unit , * ) '' write ( io_unit , * ) 'connection information' write ( io_unit , * ) '----------------------' write ( io_unit , * ) 'ikpt1     ikpt2       G' write ( io_unit , * ) '----------------------------' do j = 1 , nnkp_num_kpoints do nn = 1 , nnkp_nnkpts write ( io_unit , 200 ) j , nnkp_list_ikpt_nn ( nn , j ),( nnkp_list_G ( i , nn , j ), i = 1 , 3 ) end do end do close ( unit = io_unit ) 100 format ( I4 , 3 F8 . 4 , 3 I4 , 7 F8 . 4 ) 200 format ( I4 , 6 x , I4 , 2 x , 3 I4 ) end subroutine output_nnkp_file subroutine intw2W90_check_mesh ( nkmesh , kmesh ) !--------------------------------------------------------------------! ! This subroutine checks that the irreducible kpoints and the mesh ! read from the nnkp file are related. !--------------------------------------------------------------------! use intw_useful_constants , only : eps_8 implicit none !I/O variables integer , intent ( in ) :: nkmesh real ( dp ), intent ( in ) :: kmesh ( 3 , nkmesh ) !local variables integer :: ikpt real ( dp ) :: kpt ( 3 ), norm if ( nkmesh . ne . nnkp_num_kpoints ) then ! write ( * , * ) '**********************************************************' write ( * , * ) '                INCONSISTENCY ERROR                       ' write ( * , * ) '       The number of points in the MP mesh corresponding  ' write ( * , * ) '       to the input DOES NOT MATCH the number of k-points ' write ( * , * ) '       in the Wannier90 .nnkp file.                       ' write ( * , * ) '  nkmesh                                                  ' write ( * , * ) '         ' , nkmesh write ( * , * ) '  nnkp_num_kpoints                                                    ' write ( * , * ) '         ' , nnkp_num_kpoints write ( * , * ) '**********************************************************' ! stop ! endif ! do ikpt = 1 , nkmesh ! kpt = kmesh (:, ikpt ) - nnkp_kpoints (:, ikpt ) ! norm = sqrt ( kpt ( 1 ) ** 2 + kpt ( 2 ) ** 2 + kpt ( 3 ) ** 2 ) ! if ( norm > eps_8 ) then ! write ( * , * ) '**********************************************************' write ( * , * ) '                INCONSISTENCY ERROR                   ' write ( * , * ) '  The MP mesh generated from input does not match     ' write ( * , * ) '  the MP mesh expected by Wannier90. Are the points   ' write ( * , * ) '  properly ordered in the .win file?                  ' write ( * , * ) '**********************************************************' ! endif ! enddo !ikpt ! return end subroutine intw2W90_check_mesh subroutine generate_header ( method , header ) !----------------------------------------------------------- ! This is a utility routine which creates a date and time ! header to provide a time stamp in our files !----------------------------------------------------------- character ( 256 ) :: header character ( 8 ) :: cdate character ( 10 ) :: ctime character ( * ) :: method call date_and_time ( DATE = cdate , TIME = ctime ) ! header = 'intw2W90::' // trim ( method ) // ' time:: ' & // trim ( ctime ( 1 : 2 )) // ':' // trim ( ctime ( 3 : 4 )) // ':' // trim ( ctime ( 5 : 6 )) & // ' day:: ' // trim ( cdate ( 7 : 8 )) // '/' // trim ( cdate ( 5 : 6 )) // '/' // trim ( cdate ( 1 : 4 )) ! return end subroutine generate_header subroutine generate_mmn_using_allwfc ( intw2W_fullzone , method ) !----------------------------------------------------------------------------! ! This subroutine computes the plane wave matrix elements needed by Wannier90 ! by using symmetry. It fetches the wfc in the IBZ, rotates them, and computes ! the needed matrix elements. !----------------------------------------------------------------------------! use intw_allwfcs , only : get_psi_general_k_all_wfc use intw_utility , only : find_free_unit use intw_matrix_elements , only : get_plane_wave_matrix_element_FFT , get_plane_wave_matrix_element_convolution_map use intw_input_parameters , only : outdir , prefix use intw_reading , only : nbands , num_bands_intw , nGk_max , nspin implicit none logical , intent ( in ) :: intw2W_fullzone character ( * ), intent ( in ) :: method integer :: ikpt_1 , ikpt_2 , ineighbor integer :: G ( 3 ) integer :: ngk1 , ngk2 integer :: list_iG_1 ( nGk_max ), list_iG_2 ( nGk_max ) complex ( dp ) :: wfc_1 ( nGk_max , num_bands_intw , nspin ), wfc_2 ( nGk_max , num_bands_intw , nspin ) character ( 256 ) :: filename integer :: io_unit_mmn , io_unit_eig character ( 256 ) :: header integer :: iband , jband , ispin real ( dp ) :: QE_eig ( nnkp_num_kpoints , num_bands_intw ) complex ( dp ) :: pw_mat_el ( nnkp_num_kpoints , nnkp_nnkpts , num_bands_intw , num_bands_intw , nspin , nspin ) !loop on all points !$omp parallel do & !$omp default(none) & !$omp shared(nnkp_num_kpoints, nnkp_nnkpts, method) & !$omp shared(nnkp_kpoints, nnkp_list_G, nnkp_list_ikpt_nn) & !$omp shared(QE_eig, pw_mat_el) & !$omp private(ngk1, list_iG_1, wfc_1) & !$omp private(ngk2, list_iG_2, wfc_2) & !$omp private(ineighbor, G, ikpt_2) do ikpt_1 = 1 , nnkp_num_kpoints ! fetch the data call get_psi_general_k_all_wfc ( nnkp_kpoints (:, ikpt_1 ), ngk1 , list_iG_1 , wfc_1 , QE_eig ( ikpt_1 ,:)) ! loop on neighbors do ineighbor = 1 , nnkp_nnkpts G = nnkp_list_G (:, ineighbor , ikpt_1 ) ikpt_2 = nnkp_list_ikpt_nn ( ineighbor , ikpt_1 ) ! fetch data call get_psi_general_k_all_wfc ( nnkp_kpoints (:, ikpt_2 ) + G , ngk2 , list_iG_2 , wfc_2 ) ! Compute the matrix elements if ( trim ( method ) == 'CONVOLUTION' ) then call get_plane_wave_matrix_element_convolution_map & (( / 0 , 0 , 0 / ), list_iG_1 , ngk1 , list_iG_2 , ngk2 , wfc_1 , wfc_2 , pw_mat_el ( ikpt_1 , ineighbor ,:,:,:,:)) else if ( trim ( method ) == 'FFT' ) then call get_plane_wave_matrix_element_FFT & (( / 0 , 0 , 0 / ), list_iG_1 , list_iG_2 , wfc_1 , wfc_2 , pw_mat_el ( ikpt_1 , ineighbor ,:,:,:,:)) else write ( * , * ) 'ERROR in generate_mmn' stop end if end do ! ineighbor end do ! ikpt_1 !$omp end parallel do !----------------------------------- ! Save to file !----------------------------------- io_unit_eig = find_free_unit () filename = trim ( outdir ) // trim ( prefix ) // trim ( '.eig' ) open ( unit = io_unit_eig , file = filename , status = 'unknown' ) io_unit_mmn = find_free_unit () filename = trim ( outdir ) // trim ( prefix ) // trim ( '.mmn' ) open ( unit = io_unit_mmn , file = filename , status = 'unknown' ) if ( intw2W_fullzone ) then call generate_header ( trim ( method ) // trim ( '-fullzone' ), header ) else call generate_header ( trim ( method ) // trim ( '-IBZ' ), header ) end if write ( io_unit_mmn , * ) trim ( header ) write ( io_unit_mmn , '(3i12)' ) nbands - nnkp_exclude_bands , nnkp_num_kpoints , nnkp_nnkpts !loop on all points do ikpt_1 = 1 , nnkp_num_kpoints ! print out the eigenvalues do iband = 1 , num_bands_intw write ( io_unit_eig , '(2(I6,x),F18.12)' ) iband , ikpt_1 , QE_eig ( ikpt_1 , iband ) end do ! loop on neighbors do ineighbor = 1 , nnkp_nnkpts G = nnkp_list_G (:, ineighbor , ikpt_1 ) ikpt_2 = nnkp_list_ikpt_nn ( ineighbor , ikpt_1 ) write ( io_unit_mmn , '(5I7)' ) ikpt_1 , ikpt_2 , G do jband = 1 , num_bands_intw do iband = 1 , num_bands_intw write ( io_unit_mmn , '(2F18.12)' ) & sum ( ( / ( pw_mat_el ( ikpt_1 , ineighbor , iband , jband , ispin , ispin ), ispin = 1 , nspin ) / ) ) end do end do end do ! ineighbor end do ! ikpt_1 close ( io_unit_mmn ) close ( io_unit_eig ) end subroutine generate_mmn_using_allwfc subroutine generate_amn_using_allwfc ( intw2W_fullzone , method ) !----------------------------------------------------------------------------! ! This subroutine computes the overlap with trial functions, thus producing ! the amn file needed by Wannier90. !----------------------------------------------------------------------------! use intw_allwfcs , only : get_psi_general_k_all_wfc use intw_utility , only : find_free_unit use intw_useful_constants , only : cmplx_0 use intw_reading , only : nbands , num_bands_intw , nGk_max , lspin , nspin use intw_input_parameters , only : outdir , prefix implicit none logical , intent ( in ) :: intw2W_fullzone character ( 256 ), intent ( in ) :: method integer :: ikpt , iband , iproj integer :: ngk , list_iG ( nGk_max ) complex ( dp ) :: wfc ( nGk_max , num_bands_intw , nspin ) complex ( dp ) :: guiding_function ( nGk_max , nspin ) complex ( dp ) :: amn ( nnkp_num_kpoints , nnkp_n_proj , num_bands_intw ) integer :: io_unit_amn character ( 256 ) :: filename character ( 256 ) :: header !loop on all k-points !$omp parallel do & !$omp default(none) & !$omp shared(lspin, method) & !$omp shared(nnkp_num_kpoints, nnkp_n_proj, nnkp_kpoints, nnkp_proj_s) & !$omp shared(amn) & !$omp private(ngk, list_iG, wfc) & !$omp private(iproj, guiding_function) do ikpt = 1 , nnkp_num_kpoints ! fetch the data call get_psi_general_k_all_wfc ( nnkp_kpoints (:, ikpt ), ngk , list_iG , wfc ) !loop on all bands and all trial functions do iproj = 1 , nnkp_n_proj ! Generate the fourier transform of the trial function (called guiding ! function, just like in pw2wannier). call generate_guiding_function ( ikpt , ngk , list_iG , iproj , guiding_function (:, 1 )) !JLB spinor projection. Should be generalized to quantization axis /= z if ( lspin ) then if ( nnkp_proj_s ( iproj ) < 0 ) then guiding_function (:, 2 ) = guiding_function (:, 1 ) guiding_function (:, 1 ) = cmplx_0 else guiding_function (:, 2 ) = cmplx_0 end if end if if ( trim ( method ) == 'CONVOLUTION' ) then call get_guiding_function_overlap_convolution ( ngk , wfc , guiding_function , amn ( ikpt , iproj ,:)) else if ( trim ( method ) == 'FFT' ) then call get_guiding_function_overlap_FFT ( list_iG , wfc , guiding_function , amn ( ikpt , iproj ,:)) else write ( * , * ) 'ERROR in generate_amn' stop end if end do ! iproj end do ! ikpt !$omp end parallel do !----------------------------------- ! Save to file !----------------------------------- io_unit_amn = find_free_unit () filename = trim ( outdir ) // trim ( prefix ) // trim ( '.amn' ) open ( unit = io_unit_amn , file = filename , status = 'unknown' ) call generate_header ( method , header ) write ( io_unit_amn , * ) trim ( header ) write ( io_unit_amn , '(3I12)' ) nbands - nnkp_exclude_bands , nnkp_num_kpoints , nnkp_n_proj do ikpt = 1 , nnkp_num_kpoints do iproj = 1 , nnkp_n_proj do iband = 1 , num_bands_intw write ( io_unit_amn , '(3I7,2F18.12)' ) iband , iproj , ikpt , amn ( ikpt , iproj , iband ) end do ! iband end do ! iproj end do ! ikpt close ( io_unit_amn ) end subroutine generate_amn_using_allwfc subroutine generate_guiding_function ( ikpt , ngk , list_iG , n_proj , guiding_function ) !--------------------------------------------------------------------------- ! This subroutine computes the normalized guiding function in reciprocal ! space. ! ! This subroutine is heavily inspired by a similar routine in pw2wannier. !--------------------------------------------------------------------------- use intw_reading , only : gvec , alat , nGk_max use intw_useful_constants , only : tpi , fpi , ZERO , cmplx_0 , cmplx_i implicit none !I/O variables integer , intent ( in ) :: ikpt , ngk , n_proj , list_iG ( nGk_max ) complex ( dp ), intent ( out ) :: guiding_function ( nGk_max ) !local variables integer , parameter :: lmax = 3 , lmmax = ( lmax + 1 ) ** 2 ! max Ylm implemented in wannier90 integer :: i , mu , iG integer :: proj_nr , proj_l , proj_m integer :: l , m , lm real ( dp ) :: zona , zaxis ( 3 ), xaxis ( 3 ), ylm ( nGk_max ) real ( dp ) :: k_cryst ( 3 ), tau_cryst ( 3 ), tau_cart ( 3 ) real ( dp ) :: k_plus_G_cart ( 3 , ngk ) real ( dp ) :: norm2 real ( dp ) :: radial_l ( nGk_max , 0 : lmax ), coef ( lmmax ) complex ( dp ) :: four_pi_i_l ! ! get all the relevant vectors in reciprocal space ! express the vectors in bohrs&#94;-1 cartesian coordinates ! k_cryst (:) = nnkp_kpoints (:, ikpt ) k_plus_G_cart = ZERO ! do iG = 1 , ngk do mu = 1 , 3 do i = 1 , 3 ! k_plus_G_cart ( mu , iG ) = k_plus_G_cart ( mu , iG ) & + nnkp_recip_lattice ( mu , i ) * ( k_cryst ( i ) + dble ( gvec ( i , list_ig ( iG )))) ! enddo !i enddo !mu enddo !iG ! k_plus_G_cart = k_plus_G_cart * tpi / alat ! bohr&#94;-1 ! ! compute the guiding function ! guiding_function = cmplx_0 ! ! Set projection l and m proj_l = nnkp_proj_l ( n_proj ) proj_m = nnkp_proj_m ( n_proj ) ! JLB note: Not sure whether this works currently, needs to be tested zaxis (:) = nnkp_proj_z (:, n_proj ) xaxis (:) = nnkp_proj_x (:, n_proj ) ! ! JLB: Expansion coefficients of this projection in lm-s (needed for hybrids) call projection_expansion ( proj_l , proj_m , coef ) ! ! get the part from the radial integration proj_nr = nnkp_proj_n ( n_proj ) ! the radial projection parameter zona = nnkp_proj_zona ( n_proj ) ! Z/a, the diffusive parameter ! ! MBR, JLB: radial integrals based on pw2wannier !call get_radial_part(proj_nr,zona,k_plus_G_cart,guiding_function) call get_radial_part_numerical ( lmax , coef , proj_nr , zona , ngk , k_plus_G_cart , radial_l ) ! do l = 0 , lmax do m = 1 , 2 * l + 1 ! ! Check which lm are needed in this projection lm = l ** 2 + m if ( abs ( coef ( lm )) < 1.0d-8 ) cycle ! call get_angular_part ( l , m , xaxis , zaxis , ngk , k_plus_G_cart , ylm ) ! four_pi_i_l = fpi * ( - cmplx_i ) ** l ! do iG = 1 , ngk ! guiding_function ( iG ) = guiding_function ( iG ) + coef ( lm ) * radial_l ( iG , l ) * ylm ( iG ) * four_pi_i_l ! enddo !iG ! end do !m end do !l ! ! Add extra phase coming from Wannier center positions tau_cryst = nnkp_Wcenters (:, n_proj ) ! crystal coordinates tau_cart = ZERO do mu = 1 , 3 do i = 1 , 3 ! tau_cart ( mu ) = tau_cart ( mu ) + alat * nnkp_real_lattice ( mu , i ) * tau_cryst ( i ) ! enddo !i enddo !mu ! do iG = 1 , ngk guiding_function ( ig ) = guiding_function ( ig ) & * exp ( - cmplx_i * ( k_plus_G_cart ( 1 , ig ) * tau_cart ( 1 ) & + k_plus_G_cart ( 2 , ig ) * tau_cart ( 2 ) & + k_plus_G_cart ( 3 , ig ) * tau_cart ( 3 ) )) end do !iG ! ! Normalize norm2 = sum ( abs ( guiding_function ) ** 2 ) guiding_function = guiding_function / sqrt ( norm2 ) ! return end subroutine generate_guiding_function subroutine get_guiding_function_overlap_FFT ( list_iG , wfc , guiding_function , amn ) !------------------------------------------------------------------------ ! This subroutine computes the overlap between a given wavefunction ! wfc and a given guiding_function (assumed normalized) ! !                   amn(band) =  < wfc(band) |  guiding_function > . ! ! The computation is done over all bands using FFT. !------------------------------------------------------------------------ use intw_useful_constants , only : cmplx_0 use intw_reading , only : nGk_max , nr1 , nr2 , nr3 , num_bands_intw , nspin use intw_fft , only : wfc_from_g_to_r , wfc_from_r_to_g implicit none !I/O variables integer , intent ( in ) :: list_iG ( nGk_max ) complex ( dp ), intent ( in ) :: wfc ( nGk_max , num_bands_intw , nspin ) complex ( dp ), intent ( in ) :: guiding_function ( nGk_max , nspin ) complex ( dp ), intent ( out ) :: amn ( num_bands_intw ) !local variables integer :: ibnd , ir , is complex ( dp ) :: wfc_r ( nr1 * nr2 * nr3 ), fr ( nr1 * nr2 * nr3 ) complex ( dp ) :: fg ( nGk_max ) amn = cmplx_0 ! do ibnd = 1 , num_bands_intw ! do is = 1 , nspin ! call wfc_from_g_to_r ( list_iG , guiding_function (:, is ), fr ) call wfc_from_g_to_r ( list_iG , wfc (:, ibnd , is ), wfc_r ) ! do ir = 1 , nr1 * nr2 * nr3 ! fr ( ir ) = conjg ( wfc_r ( ir )) * fr ( ir ) ! enddo !ir ! call wfc_from_r_to_g ( list_iG , fr , fg ) ! amn ( ibnd ) = amn ( ibnd ) + fg ( 1 ) ! enddo !is ! enddo !ibnd ! return end subroutine get_guiding_function_overlap_FFT subroutine get_guiding_function_overlap_convolution ( ngk , wfc , guiding_function , amn ) !-------------------------------------------------------------------------- ! This subroutine computes the overlap between a given wavefunction ! wfc and a given guiding_function (assumed normalized) ! !             amn(band) =  < wfc(band) |  guiding_function > . ! ! The computation is done over all bands. !-------------------------------------------------------------------------- use intw_useful_constants , only : cmplx_0 use intw_reading , only : nGk_max , num_bands_intw , nspin implicit none !I/O variables integer , intent ( in ) :: ngk complex ( dp ), intent ( in ) :: wfc ( nGk_max , num_bands_intw , nspin ) complex ( dp ), intent ( in ) :: guiding_function ( nGk_max , nspin ) complex ( dp ), intent ( out ) :: amn ( num_bands_intw ) !local variables integer :: ibnd , is complex ( dp ), external :: zdotc amn = cmplx_0 ! do ibnd = 1 , num_bands_intw do is = 1 , nspin ! amn ( ibnd ) = amn ( ibnd ) + zdotc ( nGk_max , wfc (:, ibnd , is ), 1 , guiding_function (:, is ), 1 ) ! enddo !is enddo !ibnd end subroutine get_guiding_function_overlap_convolution subroutine get_radial_part_numerical ( lmax , coef , proj_nr , zona , ngk , k_plus_G_cart , radial_l ) ! MBR ! Numerical integration ! JLB: Extended to multiple l, needed for hybrid projections ! ! This subroutine is based on radialpart subroutine distributed as part of the Quantum Espresso ! code and has been adapted to INTW: !   Copyright (C) 2003-2013 Quantum ESPRESSO and Wannier90 groups !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! use intw_reading , only : nGk_max , volume0 use intw_utility , ONLY : simpson , sphb use intw_useful_constants , only : fpi , ZERO implicit none !I/O variables integer , intent ( in ) :: lmax , proj_nr , ngk real ( dp ), intent ( in ) :: coef (( lmax + 1 ) ** 2 ), zona , k_plus_G_cart ( 3 , ngk ) real ( dp ), intent ( out ) :: radial_l ( nGk_max , 0 : lmax ) !local variables integer :: iG , l real ( dp ) :: z , z2 , z4 , z6 , z52 , sqrt_z real ( dp ) :: p ( ngk ) ! from pw2wannier integer :: mesh_r , ir real ( DP ), PARAMETER :: xmin =- 6.d0 , dx = 0.025d0 , rmax = 1 0.d0 real ( DP ) :: x , rad_int real ( DP ), ALLOCATABLE :: bes (:), func_r (:), r (:), rij (:), aux (:) z = zona z2 = z * z z4 = z2 * z2 z6 = z4 * z2 sqrt_z = sqrt ( z ) z52 = z2 * sqrt_z ! !find the norms ! do iG = 1 , ngk ! p ( iG ) = sqrt ( k_plus_G_cart ( 1 , iG ) ** 2 & + k_plus_G_cart ( 2 , iG ) ** 2 & + k_plus_G_cart ( 3 , iG ) ** 2 ) ! enddo !iG ! ! from pw2intw: ! mesh_r = nint ( ( log ( rmax ) - xmin ) / dx + 1 ) allocate ( bes ( mesh_r ), func_r ( mesh_r ), r ( mesh_r ), rij ( mesh_r )) allocate ( aux ( mesh_r )) ! !    compute the radial mesh ! do ir = 1 , mesh_r x = xmin + dble ( ir - 1 ) * dx r ( ir ) = exp ( x ) / zona rij ( ir ) = dx * r ( ir ) end do ! ! if ( proj_nr == 1 ) then func_r (:) = 2.d0 * zona ** ( 3.d0 / 2.d0 ) * exp ( - zona * r (:)) else if ( proj_nr == 2 ) then func_r (:) = 1.d0 / sqrt ( 8.d0 ) * zona ** ( 3.d0 / 2.d0 ) * & ( 2.0d0 - zona * r (:)) * exp ( - zona * r (:) * 0.5d0 ) else if ( proj_nr == 3 ) then func_r (:) = sqrt ( 4.d0 / 2 7.d0 ) * zona ** ( 3.0d0 / 2.0d0 ) * & ( 1.d0 - 2.0d0 / 3.0d0 * zona * r (:) + 2.d0 * ( zona * r (:)) ** 2 / 2 7.d0 ) * exp ( - zona * r (:) / 3.0d0 ) else write ( * , * ) 'ERROR in intw2W90: this radial projection is not implemented' endif radial_l = ZERO do l = 0 , lmax ! JLB: Check which l-s are used in this projection if ( any ( coef ( l ** 2 + 1 : l ** 2 + 1 + 2 * l ) > 1.0d-8 ) ) then ! do iG = 1 , ngk aux = r * r * sphb ( l , p ( iG ) * r ) * func_r call simpson ( mesh_r , aux , rij , rad_int ) radial_l ( iG , l ) = rad_int * fpi / sqrt ( volume0 ) end do ! end if end do deallocate ( bes , func_r , r , rij , aux ) return end subroutine get_radial_part_numerical subroutine get_radial_part ( proj_nr , zona , k_plus_G_cart , guiding_function ) !-------------------------------------------------------------------------------- ! This subroutine computes the overlap between a given wavefunction ! wfc and a given guiding_function (assumed normalized) ! !             amn(band) =  < wfc(band) |  guiding_function > . ! ! The computation is done over all bands. ! ! The G-vectors are referenced by their indices in list_iG ! which refer to the global list gvec(1:3,1:nG). !-------------------------------------------------------------------------------- use intw_reading , only : nG implicit none !I/O variables integer , intent ( in ) :: proj_nr real ( dp ), intent ( in ) :: zona , k_plus_G_cart ( 3 , nG ) complex ( dp ), intent ( inout ) :: guiding_function ( nG ) !local variables integer :: iG real ( dp ) :: z , z2 , z4 , z6 , z52 , sqrt_z , pref real ( dp ) :: p ( nG ) z = zona z2 = z * z z4 = z2 * z2 z6 = z4 * z2 sqrt_z = sqrt ( z ) z52 = z2 * sqrt_z ! !find the norms ! do iG = 1 , nG ! p ( iG ) = sqrt ( k_plus_G_cart ( 1 , iG ) ** 2 & + k_plus_G_cart ( 2 , iG ) ** 2 & + k_plus_G_cart ( 3 , iG ) ** 2 ) ! enddo !iG ! ! the radial functions ! Their functional forms are obtained from analytical integrals ! done using MATHEMATICA (this is not a guarantee, however! always ! check for bugs...). ! if ( proj_nr == 1 ) then ! pref = 4.0_dp * z52 ! guiding_function = pref / ( p ** 2 + z2 ) ** 2 ! ! CHEAT ! there appears to be a BUG in pw2wannier, on line 2106. ! There, the numerical integration of r R_{nl}(r) j_l(kr) is done, ! BUT IT IS THE INTEGRAL OF r&#94;2 R_{nl}(r) j_l(kr) WHICH IS NEEDED. ! Below is the analytical expression for this WRONG integral; ! it yields better agreement between Amn computed by this code and ! pw2wannier. ! guiding_function=2.0_dp*z2*sqrt_z/(p**2+z2) ! elseif ( proj_nr == 2 ) then ! pref = 1 6.0_dp * sqrt ( 2.0_dp ) * z52 ! guiding_function = pref * ( 4.0_dp * p ** 2 - z2 ) / ( 4.0_dp * p ** 2 + z2 ) ** 3 ! elseif ( proj_nr == 3 ) then ! pref = 3 6.0_dp * sqrt ( 3.0_dp ) * z52 ! guiding_function = pref * ( 8 1.0_dp * p ** 4 - 3 0.0_dp * p ** 2 * z2 + z4 ) & / ( 9.0_dp * p ** 2 + z2 ) ** 4 ! elseif ( proj_nr == 4 ) then ! pref = 12 8.0_dp * z52 ! guiding_function = pref * ( 409 6.0_dp * p ** 6 - 179 2.0_dp * p ** 4 * z2 & + 11 2.0_dp * p ** 2 * z4 - z6 ) & / ( 1 6.0_dp * p ** 2 + z2 ) ** 5 ! else ! write ( * , * ) 'ERROR in intw2W90: this radial projection is not implemented' ! endif ! return end subroutine get_radial_part subroutine get_angular_part ( proj_l , proj_m , xaxis , zaxis , ngk , k_plus_G_cart , ylm ) !-------------------------------------------------------------------------- ! This subroutine computes appropriate spherical harmonic corresponding ! to ! !                   amn(band) =  < wfc(band) |  guiding_function > . ! ! The computation is done over all bands. !-------------------------------------------------------------------------- use intw_reading , only : nGk_max implicit none !I/O variables integer , intent ( in ) :: ngk , proj_l , proj_m real ( dp ), intent ( in ) :: xaxis ( 3 ), zaxis ( 3 ) real ( dp ), intent ( in ) :: k_plus_G_cart ( 3 , ngk ) real ( dp ), intent ( out ) :: ylm ( nGk_max ) !local variables integer :: iG real ( dp ) :: yaxis ( 3 ), q ( 3 , ngk ), norm_y ! produce the yaxis using z cross x. THEY REALLY SHOULD BE ORTHOGONAL. ! yaxis ( 1 ) = zaxis ( 2 ) * xaxis ( 3 ) - zaxis ( 3 ) * xaxis ( 2 ) yaxis ( 2 ) = - zaxis ( 1 ) * xaxis ( 3 ) + zaxis ( 3 ) * xaxis ( 1 ) yaxis ( 3 ) = zaxis ( 1 ) * xaxis ( 2 ) - zaxis ( 2 ) * xaxis ( 1 ) ! norm_y = sqrt ( yaxis ( 1 ) ** 2 + yaxis ( 2 ) ** 2 + yaxis ( 3 ) ** 2 ) ! yaxis = yaxis / norm_y ! ! project k_plus_G_cart onto these axes. ! do iG = 1 , ngk ! q ( 1 , iG ) = k_plus_G_cart ( 1 , iG ) * xaxis ( 1 ) & + k_plus_G_cart ( 2 , iG ) * xaxis ( 2 ) & + k_plus_G_cart ( 3 , iG ) * xaxis ( 3 ) ! q ( 2 , iG ) = k_plus_G_cart ( 1 , iG ) * yaxis ( 1 ) & + k_plus_G_cart ( 2 , iG ) * yaxis ( 2 ) & + k_plus_G_cart ( 3 , iG ) * yaxis ( 3 ) ! q ( 3 , iG ) = k_plus_G_cart ( 1 , iG ) * zaxis ( 1 ) & + k_plus_G_cart ( 2 , iG ) * zaxis ( 2 ) & + k_plus_G_cart ( 3 , iG ) * zaxis ( 3 ) ! enddo !iG ! call ylm_wannier ( ylm , proj_l , proj_m , q , ngk ) ! return end subroutine get_angular_part subroutine ylm_wannier ( ylm , l , mr , r , nr ) ! ! this routine returns in ylm(r) the values at the nr points r(1:3,1:nr) ! of the spherical harmonic identified  by indices (l,mr) ! in table 3.1 of the wannierf90 specification. ! ! No reference to the particular ylm ordering internal to quantum-espresso ! is assumed. ! ! If ordering in wannier90 code is changed or extended this should be the ! only place to be modified accordingly ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2003-2013 Quantum ESPRESSO and Wannier90 groups !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! use intw_useful_constants , only : pi , eps_8 implicit none !I/O variables integer , intent ( in ) :: l , mr , nr real ( dp ), intent ( in ) :: r ( 3 , nr ) real ( dp ), intent ( out ) :: ylm ( nr ) !local variables real ( dp ), external :: s , pz_func , px , py , dz2 , dxz , dyz , dx2my2 , dxy , & fz3 , fxz2 , fyz2 , fzx2my2 , fxyz , fxx2m3y2 , fy3x2my2 real ( dp ) :: rr , cost , phi integer :: ir real ( dp ) :: bs2 , bs3 , bs6 , bs12 bs2 = 1.d0 / sqrt ( 2.d0 ) bs3 = 1.d0 / sqrt ( 3.d0 ) bs6 = 1.d0 / sqrt ( 6.d0 ) bs12 = 1.d0 / sqrt ( 1 2.d0 ) ! if ( l > 3 . OR . l <- 5 ) then ! write ( * , * ) ' ylm_wannier: l out of range! ' stop ! endif ! if ( l >= 0 ) then ! if ( mr < 1 . OR . mr > 2 * l + 1 ) then ! write ( * , * ) ' ylm_wannier: m out of range! ' stop ! endif ! else ! if ( mr < 1 . OR . mr > abs ( l ) + 1 ) then ! write ( * , * ) ' ylm_wannier: m out of range! ' stop ! endif ! endif ! do ir = 1 , nr ! rr = sqrt ( r ( 1 , ir ) * r ( 1 , ir ) + r ( 2 , ir ) * r ( 2 , ir ) + r ( 3 , ir ) * r ( 3 , ir ) ) ! cost = r ( 3 , ir ) / ( rr + eps_8 ) ! ! beware the arc tan, it is defined modulo pi ! if ( r ( 1 , ir ) > eps_8 ) then ! phi = atan ( r ( 2 , ir ) / r ( 1 , ir ) ) ! elseif ( r ( 1 , ir ) < - eps_8 ) then ! phi = atan ( r ( 2 , ir ) / r ( 1 , ir ) ) + pi ! else ! phi = sign ( pi / 2.d0 , r ( 2 , ir ) ) ! endif ! ! if the norm of r is very small, just arbitrarily pick ! the angle to be theta = 0 , phi = 0 ! if ( rr < eps_8 ) then ! cost = 1.0_dp phi = 0.0_dp ! endif ! if ( l == 0 ) then ! s orbital ! ylm ( ir ) = s ( cost , phi ) ! endif ! if ( l == 1 ) then ! p orbitals ! if ( mr == 1 ) ylm ( ir ) = pz_func ( cost , phi ) if ( mr == 2 ) ylm ( ir ) = px ( cost , phi ) if ( mr == 3 ) ylm ( ir ) = py ( cost , phi ) ! endif ! if ( l == 2 ) then ! d orbitals ! if ( mr == 1 ) ylm ( ir ) = dz2 ( cost , phi ) if ( mr == 2 ) ylm ( ir ) = dxz ( cost , phi ) if ( mr == 3 ) ylm ( ir ) = dyz ( cost , phi ) if ( mr == 4 ) ylm ( ir ) = dx2my2 ( cost , phi ) if ( mr == 5 ) ylm ( ir ) = dxy ( cost , phi ) ! endif ! if ( l == 3 ) then ! f orbitals ! if ( mr == 1 ) ylm ( ir ) = fz3 ( cost , phi ) if ( mr == 2 ) ylm ( ir ) = fxz2 ( cost , phi ) if ( mr == 3 ) ylm ( ir ) = fyz2 ( cost , phi ) if ( mr == 4 ) ylm ( ir ) = fzx2my2 ( cost , phi ) if ( mr == 5 ) ylm ( ir ) = fxyz ( cost , phi ) if ( mr == 6 ) ylm ( ir ) = fxx2m3y2 ( cost , phi ) if ( mr == 7 ) ylm ( ir ) = fy3x2my2 ( cost , phi ) ! endif ! if ( l ==- 1 ) then ! sp hybrids ! if ( mr == 1 ) ylm ( ir ) = bs2 * ( s ( cost , phi ) + px ( cost , phi ) ) if ( mr == 2 ) ylm ( ir ) = bs2 * ( s ( cost , phi ) - px ( cost , phi ) ) ! endif ! if ( l ==- 2 ) then ! sp2 hybrids ! if ( mr == 1 ) ylm ( ir ) = bs3 * s ( cost , phi ) - bs6 * px ( cost , phi ) + bs2 * py ( cost , phi ) if ( mr == 2 ) ylm ( ir ) = bs3 * s ( cost , phi ) - bs6 * px ( cost , phi ) - bs2 * py ( cost , phi ) if ( mr == 3 ) ylm ( ir ) = bs3 * s ( cost , phi ) + 2.d0 * bs6 * px ( cost , phi ) ! endif ! if ( l ==- 3 ) then ! sp3 hybrids ! if ( mr == 1 ) ylm ( ir ) = 0.5d0 * ( s ( cost , phi ) + px ( cost , phi ) + py ( cost , phi ) + pz_func ( cost , phi ) ) if ( mr == 2 ) ylm ( ir ) = 0.5d0 * ( s ( cost , phi ) + px ( cost , phi ) - py ( cost , phi ) - pz_func ( cost , phi ) ) if ( mr == 3 ) ylm ( ir ) = 0.5d0 * ( s ( cost , phi ) - px ( cost , phi ) + py ( cost , phi ) - pz_func ( cost , phi ) ) if ( mr == 4 ) ylm ( ir ) = 0.5d0 * ( s ( cost , phi ) - px ( cost , phi ) - py ( cost , phi ) + pz_func ( cost , phi ) ) ! endif ! if ( l ==- 4 ) then ! sp3d hybrids ! if ( mr == 1 ) ylm ( ir ) = bs3 * s ( cost , phi ) - bs6 * px ( cost , phi ) + bs2 * py ( cost , phi ) if ( mr == 2 ) ylm ( ir ) = bs3 * s ( cost , phi ) - bs6 * px ( cost , phi ) - bs2 * py ( cost , phi ) if ( mr == 3 ) ylm ( ir ) = bs3 * s ( cost , phi ) + 2.d0 * bs6 * px ( cost , phi ) if ( mr == 4 ) ylm ( ir ) = bs2 * pz_func ( cost , phi ) + bs2 * dz2 ( cost , phi ) if ( mr == 5 ) ylm ( ir ) =- bs2 * pz_func ( cost , phi ) + bs2 * dz2 ( cost , phi ) ! endif ! if ( l ==- 5 ) then ! sp3d2 hybrids ! if ( mr == 1 ) ylm ( ir ) = bs6 * s ( cost , phi ) - bs2 * px ( cost , phi ) - bs12 * dz2 ( cost , phi ) + 0.5d0 * dx2my2 ( cost , phi ) if ( mr == 2 ) ylm ( ir ) = bs6 * s ( cost , phi ) + bs2 * px ( cost , phi ) - bs12 * dz2 ( cost , phi ) + 0.5d0 * dx2my2 ( cost , phi ) if ( mr == 3 ) ylm ( ir ) = bs6 * s ( cost , phi ) - bs2 * py ( cost , phi ) - bs12 * dz2 ( cost , phi ) - 0.5d0 * dx2my2 ( cost , phi ) if ( mr == 4 ) ylm ( ir ) = bs6 * s ( cost , phi ) + bs2 * py ( cost , phi ) - bs12 * dz2 ( cost , phi ) - 0.5d0 * dx2my2 ( cost , phi ) if ( mr == 5 ) ylm ( ir ) = bs6 * s ( cost , phi ) - bs2 * pz_func ( cost , phi ) + bs3 * dz2 ( cost , phi ) if ( mr == 6 ) ylm ( ir ) = bs6 * s ( cost , phi ) + bs2 * pz_func ( cost , phi ) + bs3 * dz2 ( cost , phi ) ! endif ! enddo !ir ! return end subroutine ylm_wannier subroutine projection_expansion ( l , mr , coef ) !-------------------------------------------------------------------------- ! Outputs expansion coefficients for hybrid projections, ! following wannier90 user guide table 3.2 !-------------------------------------------------------------------------- use intw_useful_constants , only : ZERO implicit none !I/O variables integer , intent ( in ) :: l , mr real ( dp ), intent ( out ) :: coef (:) ! !local variables integer :: lm real ( dp ) :: fac1 , fac2 , fac3 , fac4 , fac5 coef = ZERO ! ! Check if l and m are within what's implemented in wannier90 if ( l > 3 . or . l <- 5 ) then ! write ( * , * ) ' projection_expansion: l out of range! ' stop ! end if ! ! Compute coefficients ! if ( l >- 1 ) then ! single orbitals ! ! Double-check if l and mr make sense if ( mr < 1 . OR . mr > 2 * l + 1 ) then ! write ( * , * ) ' ylm_wannier: m out of range! ' stop ! endif ! lm = l ** 2 + mr coef ( lm ) = 1.d0 ! else ! hybrid orbitals ! ! Double check if l and mr make sense if ( mr < 1 . or . mr > abs ( l ) + 1 ) then ! write ( * , * ) ' ylm_wannier: m out of range! ' stop ! end if ! if ( l ==- 1 ) then !  sp hybrids ! fac1 = 1.d0 / sqrt ( 2.d0 ) ! if ( mr == 1 ) then ! sp-1 coef ( 1 ) = fac1 coef ( 3 ) = fac1 else if ( mr == 2 ) then ! sp-2 coef ( 1 ) = fac1 coef ( 3 ) = - fac1 end if ! else if ( l ==- 2 ) then !  sp2 hybrids ! fac1 = 1.d0 / sqrt ( 3.d0 ) fac2 = 1.d0 / sqrt ( 6.d0 ) fac3 = 1.d0 / sqrt ( 2.d0 ) fac4 = 2.d0 / sqrt ( 6.d0 ) ! if ( mr == 1 ) then ! sp2-1 coef ( 1 ) = fac1 coef ( 3 ) = - fac2 coef ( 4 ) = fac3 else if ( mr == 2 ) then ! sp2-2 coef ( 1 ) = fac1 coef ( 3 ) = - fac2 coef ( 4 ) = - fac3 else if ( mr == 3 ) then ! sp2-2 coef ( 1 ) = fac1 coef ( 3 ) = fac4 end if ! else if ( l ==- 3 ) then !  sp3 hybrids ! fac1 = 1.d0 / 2.d0 ! if ( mr == 1 ) then ! sp3-1 coef ( 1 ) = fac1 coef ( 2 ) = fac1 coef ( 3 ) = fac1 coef ( 4 ) = fac1 else if ( mr == 2 ) then ! sp3-2 coef ( 1 ) = fac1 coef ( 2 ) = - fac1 coef ( 3 ) = fac1 coef ( 4 ) = - fac1 else if ( mr == 3 ) then ! sp3-3 coef ( 1 ) = fac1 coef ( 2 ) = - fac1 coef ( 3 ) = - fac1 coef ( 4 ) = fac1 else if ( mr == 4 ) then ! sp3-4 coef ( 1 ) = fac1 coef ( 2 ) = fac1 coef ( 3 ) = - fac1 coef ( 4 ) = - fac1 end if ! else if ( l ==- 4 ) then !  sp3d hybrids ! fac1 = 1.d0 / sqrt ( 3.d0 ) fac2 = 1.d0 / sqrt ( 6.d0 ) fac3 = 1.d0 / sqrt ( 2.d0 ) fac4 = 2.d0 / sqrt ( 6.d0 ) ! if ( mr == 1 ) then ! sp3d-1 coef ( 1 ) = fac1 coef ( 3 ) = - fac2 coef ( 4 ) = fac3 else if ( mr == 2 ) then ! sp3d-2 coef ( 1 ) = fac1 coef ( 3 ) = - fac2 coef ( 4 ) = - fac3 else if ( mr == 3 ) then ! sp3d-3 coef ( 1 ) = fac1 coef ( 3 ) = fac4 else if ( mr == 4 ) then ! sp3d-4 coef ( 2 ) = fac3 coef ( 5 ) = fac3 else if ( mr == 5 ) then ! sp3d-5 coef ( 2 ) = - fac3 coef ( 5 ) = fac3 end if ! else if ( l ==- 5 ) then !  sp3d2 hybrids ! fac1 = 1.d0 / sqrt ( 6.d0 ) fac2 = 1.d0 / sqrt ( 2.d0 ) fac3 = 1.d0 / sqrt ( 1 2.d0 ) fac4 = 1.d0 / 2.d0 fac5 = 1.d0 / sqrt ( 3.d0 ) ! if ( mr == 1 ) then ! sp3d2-1 coef ( 1 ) = fac1 coef ( 3 ) = - fac2 coef ( 5 ) = - fac3 coef ( 8 ) = fac4 else if ( mr == 2 ) then ! sp3d2-2 coef ( 1 ) = fac1 coef ( 3 ) = fac2 coef ( 5 ) = - fac3 coef ( 8 ) = fac4 else if ( mr == 3 ) then ! sp3d2-3 coef ( 1 ) = fac1 coef ( 3 ) = - fac2 coef ( 5 ) = - fac3 coef ( 8 ) = - fac4 else if ( mr == 4 ) then ! sp3d2-4 coef ( 1 ) = fac1 coef ( 3 ) = fac2 coef ( 5 ) = - fac3 coef ( 8 ) = - fac4 else if ( mr == 5 ) then ! sp3d2-5 coef ( 1 ) = fac1 coef ( 2 ) = - fac2 coef ( 5 ) = fac5 else if ( mr == 6 ) then ! sp3d2-6 coef ( 1 ) = fac1 coef ( 2 ) = fac2 coef ( 5 ) = fac5 end if ! end if ! end if end subroutine !=================================================== ! MBR 18/04/24: currently unused!!! subroutine get_bvec_list ( bvec ) ! Reads the first k-vector and its neighbours shells from nnkp, and ! returns the list of the nnkp_nnkpts b-vectors used by W90 ! in fractional coordinates implicit none real ( dp ) , intent ( out ) :: bvec ( 3 , nnkp_nnkpts ) integer :: nn , ik , G ( 3 ) real ( dp ) :: kpoint ( 3 ), kpoint_plus_b ( 3 ) kpoint = nnkp_kpoints (:, 1 ) do nn = 1 , nnkp_nnkpts G = nnkp_list_G (:, nn , 1 ) ik = nnkp_list_ikpt_nn ( nn , 1 ) kpoint_plus_b = nnkp_kpoints (:, ik ) + real ( G , dp ) bvec (:, nn ) = kpoint_plus_b - kpoint end do return end subroutine get_bvec_list end module intw_intw2wannier ! This functions are originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2003-2013 Quantum ESPRESSO and Wannier90 groups !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ !======== l = 0 ===================================================================== function s ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: s , cost , phi s = 1.d0 / sqrt ( fpi ) return end function s !======== l = 1 ===================================================================== function pz_func ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: pz_func , cost , phi pz_func = sqrt ( 3.d0 / fpi ) * cost return end function pz_func function px ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: px , cost , phi , sint sint = sqrt ( abs ( 1.d0 - cost * cost )) px = sqrt ( 3.d0 / fpi ) * sint * cos ( phi ) return end function px function py ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: py , cost , phi , sint sint = sqrt ( abs ( 1.d0 - cost * cost )) py = sqrt ( 3.d0 / fpi ) * sint * sin ( phi ) return end function py !======== l = 2 ===================================================================== function dz2 ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: dz2 , cost , phi dz2 = sqrt ( 1.25d0 / fpi ) * ( 3.d0 * cost * cost - 1.d0 ) return end function dz2 function dxz ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: dxz , cost , phi , sint sint = sqrt ( abs ( 1.d0 - cost * cost )) dxz = sqrt ( 1 5.d0 / fpi ) * sint * cost * cos ( phi ) return end function dxz function dyz ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: dyz , cost , phi , sint sint = sqrt ( abs ( 1.d0 - cost * cost )) dyz = sqrt ( 1 5.d0 / fpi ) * sint * cost * sin ( phi ) return end function dyz function dx2my2 ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: dx2my2 , cost , phi , sint sint = sqrt ( abs ( 1.d0 - cost * cost )) dx2my2 = sqrt ( 3.75d0 / fpi ) * sint * sint * cos ( 2.d0 * phi ) return end function dx2my2 function dxy ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: dxy , cost , phi , sint sint = sqrt ( abs ( 1.d0 - cost * cost )) dxy = sqrt ( 3.75d0 / fpi ) * sint * sint * sin ( 2.d0 * phi ) return end function dxy !======== l = 3 ===================================================================== function fz3 ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: fz3 , cost , phi fz3 = 0.25d0 * sqrt ( 7.d0 / pi ) * ( 5.d0 * cost * cost - 3.d0 ) * cost return end function fz3 function fxz2 ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: fxz2 , cost , phi , sint sint = sqrt ( abs ( 1.d0 - cost * cost )) fxz2 = 0.25d0 * sqrt ( 1 0.5d0 / pi ) * ( 5.d0 * cost * cost - 1.d0 ) * sint * cos ( phi ) return end function fxz2 function fyz2 ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: fyz2 , cost , phi , sint sint = sqrt ( abs ( 1.d0 - cost * cost )) fyz2 = 0.25d0 * sqrt ( 1 0.5d0 / pi ) * ( 5.d0 * cost * cost - 1.d0 ) * sint * sin ( phi ) return end function fyz2 function fzx2my2 ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: fzx2my2 , cost , phi , sint sint = sqrt ( abs ( 1.d0 - cost * cost )) fzx2my2 = 0.25d0 * sqrt ( 105 d0 / pi ) * sint * sint * cost * cos ( 2.d0 * phi ) return end function fzx2my2 function fxyz ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: fxyz , cost , phi , sint sint = sqrt ( abs ( 1.d0 - cost * cost )) fxyz = 0.25d0 * sqrt ( 105 d0 / pi ) * sint * sint * cost * sin ( 2.d0 * phi ) return end function fxyz function fxx2m3y2 ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: fxx2m3y2 , cost , phi , sint sint = sqrt ( abs ( 1.d0 - cost * cost )) fxx2m3y2 = 0.25d0 * sqrt ( 1 7.5d0 / pi ) * sint * sint * sint * cos ( 3.d0 * phi ) return end function fxx2m3y2 function fy3x2my2 ( cost , phi ) use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi implicit none real ( dp ) :: fy3x2my2 , cost , phi , sint sint = sqrt ( abs ( 1.d0 - cost * cost )) fy3x2my2 = 0.25d0 * sqrt ( 1 7.5d0 / pi ) * sint * sint * sint * sin ( 3.d0 * phi ) return end function fy3x2my2","tags":"","url":"sourcefile/intw2wannier.f90.html"},{"title":"intw_pseudo_local.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_pseudo_local !! display: none !! !! This module contains variables and subroutines for obtaining the local !! part of the pseudo-potentials. !! use kinds , only : dp implicit none ! variables public :: vloc ! subroutines public :: init_local_PP , deallocate_local_PP , init_vlocq , & calculate_local_part_v , calculate_local_part_dv , & dvqpsi_local private real ( kind = dp ), allocatable :: vloc (:,:) ! Local potential in reciprocal space for each atomic type contains subroutine init_local_PP () ! use intw_reading , only : ntyp , nG implicit none real ( kind = dp ) :: q_cryst ( 3 ) if (. not . allocated ( vloc )) allocate ( vloc ( nG , ntyp )) ! q_cryst = ( / 0.0_dp , 0.0_dp , 0.0_dp / ) ! call init_vlocq ( q_cryst , vloc ) end subroutine init_local_PP subroutine deallocate_local_PP () implicit none deallocate ( vloc ) end subroutine deallocate_local_PP subroutine init_vlocq ( q_cryst , vlocq ) ! ! This subroutine is based on the phq_init subroutine distributed as part of ! the Quantum Espresso project: !   Copyright (C) 2001-2008 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! use intw_reading , only : ntyp , tpiba2 , nG , bg , volume0 use intw_fft , only : gvec_cart use intw_pseudo , only : upf ! implicit none ! real ( kind = dp ), intent ( in ) :: q_cryst ( 3 ) real ( kind = dp ), intent ( out ) :: vlocq ( nG , ntyp ) ! ! local variables real ( kind = dp ) :: q_cart ( 3 ) integer :: nt q_cart = matmul ( bg , q_cryst ) ! do nt = 1 , ntyp call setlocq ( q_cart , upf ( nt )% mesh , upf ( nt )% mesh , upf ( nt )% rab , upf ( nt )% r ,& upf ( nt )% vloc , upf ( nt )% zp , tpiba2 , nG , gvec_cart , volume0 , & vlocq (:, nt ) ) end do end subroutine init_vlocq subroutine calculate_local_part_v ( v_local ) !====================================================================== ! Add the local part of the PP (V_loc) to v_local                     ! !====================================================================== use intw_reading , only : nr1 , nr2 , nr3 , nG , ntyp use intw_fft , only : nl , strf use intw_useful_constants , only : cmplx_0 implicit none external :: cfftnd !I/O variables complex ( kind = dp ), intent ( inout ) :: v_local ( nr1 * nr2 * nr3 ) !local variables integer :: nt , ig complex ( kind = dp ) :: aux ( nr1 * nr2 * nr3 ) aux = cmplx_0 do nt = 1 , ntyp ! do ig = 1 , nG ! aux ( nl ( ig )) = aux ( nl ( ig )) + strf ( ig , nt ) * vloc ( ig , nt ) ! enddo ! ig ! end do ! nt ! call cfftnd ( 3 , ( / nr1 , nr2 , nr3 / ), 1 , aux ) ! v_local = v_local + aux end subroutine calculate_local_part_v subroutine calculate_local_part_dv ( q_cryst , dvq_local ) !====================================================================== ! We have dV_scf as input and we add to it the derivative of the PP   ! !====================================================================== use intw_reading , only : nat , nspin , nr1 , nr2 , nr3 , nG , tpiba , ityp , bg , tau , ntyp use intw_fft , only : nl , gvec_cart , phase use intw_useful_constants , only : cmplx_i , cmplx_0 , tpi implicit none external :: cfftnd !I/O variables real ( kind = dp ), intent ( in ) :: q_cryst ( 3 ) complex ( kind = dp ), intent ( inout ) :: dvq_local ( nr1 * nr2 * nr3 , 3 * nat , nspin , nspin ) !local variables complex ( kind = dp ) :: eigqts ( nat ) integer :: imode , na , nt , ipol , ig , ispin , ir complex ( kind = dp ) :: aux ( nr1 * nr2 * nr3 ) real ( kind = dp ) :: q_cart ( 3 ), vlocq ( nG , ntyp ) q_cart = matmul ( bg , q_cryst ) ! Compute local potential of the KB PP for q call init_vlocq ( q_cryst , vlocq ) do na = 1 , nat ! eigqts ( na ) = exp ( - cmplx_i * tpi * dot_product ( q_cart , tau (:, na ))) ! end do ! do imode = 1 , 3 * nat ! na = ( imode - 1 ) / 3 + 1 ipol = modulo ( imode - 1 , 3 ) + 1 nt = ityp ( na ) ! aux = cmplx_0 ! do ig = 1 , nG ! aux ( nl ( ig )) = aux ( nl ( ig )) - cmplx_i * tpiba * ( q_cart ( ipol ) + gvec_cart ( ipol , ig ) ) * & eigqts ( na ) * phase ( ig , na ) * vlocq ( ig , nt ) ! enddo !ig ! call cfftnd ( 3 , ( / nr1 , nr2 , nr3 / ), 1 , aux ) ! do ispin = 1 , nspin do ir = 1 , nr1 * nr2 * nr3 ! dvq_local ( ir , imode , ispin , ispin ) = dvq_local ( ir , imode , ispin , ispin ) + aux ( ir ) ! enddo !ir enddo !ispin ! enddo !imode end subroutine calculate_local_part_dv subroutine dvqpsi_local ( nbands , list_iGk , list_iGkq , wfc_k , dvq_local , dvpsi_local ) use intw_useful_constants , only : cmplx_0 use intw_reading , only : nat , nspin , nGk_max , nr1 , nr2 , nr3 use intw_fft , only : nl implicit none external :: cfftnd !I/O variables integer , intent ( in ) :: nbands , list_iGk ( nGk_max ), list_iGkq ( nGk_max ) complex ( kind = dp ), intent ( in ) :: dvq_local ( nr1 * nr2 * nr3 , 3 * nat , nspin , nspin ), wfc_k ( nGk_max , nbands , nspin ) complex ( kind = dp ), intent ( out ) :: dvpsi_local ( nGk_max , nbands , nspin , nspin , 3 * nat ) !local variables integer :: ibnd , ispin , jspin , ig , imode , ir complex ( kind = dp ) :: wfc_r ( nr1 * nr2 * nr3 , nspin , nspin ), wfc_r1 ( nr1 * nr2 * nr3 , nspin ) dvpsi_local = cmplx_0 ! do imode = 1 , 3 * nat ! do ibnd = 1 , nbands ! ! Fourier transform the wave function to real space wfc_r1 = cmplx_0 do ispin = 1 , nspin do ig = 1 , nGk_max ! if ( list_iGk ( ig ) == 0 ) exit wfc_r1 ( nl ( list_iGk ( ig )), ispin ) = wfc_k ( ig , ibnd , ispin ) ! enddo !ig ! call cfftnd ( 3 , ( / nr1 , nr2 , nr3 / ), 1 , wfc_r1 (:, ispin )) ! enddo !ispin ! ! Multiply the wave function and the potential in real space wfc_r = cmplx_0 do ispin = 1 , nspin do jspin = 1 , nspin ! do ir = 1 , nr1 * nr2 * nr3 ! wfc_r ( ir , ispin , jspin ) = dvq_local ( ir , imode , ispin , jspin ) * wfc_r1 ( ir , jspin ) ! enddo !ir ! enddo !jspin enddo !ispin ! ! do ispin = 1 , nspin do jspin = 1 , nspin ! call cfftnd ( 3 , ( / nr1 , nr2 , nr3 / ), - 1 , wfc_r (:, ispin , jspin )) ! do ig = 1 , nGk_max ! if ( list_iGkq ( ig ) == 0 ) exit ! dvpsi_local ( ig , ibnd , ispin , jspin , imode ) = dvpsi_local ( ig , ibnd , ispin , jspin , imode ) & + wfc_r ( nl ( list_iGkq ( ig )), ispin , jspin ) ! enddo !ig ! enddo !jspin enddo !ispin ! enddo !ibnd ! enddo !imode end subroutine dvqpsi_local subroutine setlocq ( q_cart , mesh , msh , rab , r , vloc_at , zp , tpiba2 , nG , g_cart , omega , vlocq ) !---------------------------------------------------------------------- ! ! This routine computes the Fourier transform of the local ! part of the pseudopotential in the q+G vectors. ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2001-2009 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! use kinds , only : dp use intw_useful_constants , only : TWO , fpi , pi use intw_utility , only : simpson , qe_erf , qe_erfc ! implicit none ! ! I/O variables ! integer , intent ( in ) :: nG , mesh , msh ! input: the number of G vectors ! input: the dimensions of the mesh ! input: mesh points for radial integration real ( kind = dp ), intent ( in ) :: q_cart ( 3 ), zp , rab ( mesh ), r ( mesh ), vloc_at ( mesh ), tpiba2 , omega , g_cart ( 3 , nG ) ! input: the q point ! input: valence pseudocharge ! input: the derivative of mesh points ! input: the mesh points ! input: the pseudo on the radial ! input: 2 pi / alat ! input: the volume of the unit cell ! input: the g_cart vectors real ( kind = dp ), intent ( out ) :: vlocq ( nG ) ! output: the fourier transform of the potential ! ! local variables ! real ( kind = dp ), parameter :: eps = 1.d-8 real ( kind = dp ) :: vlcp , vloc0 , fac , g2a , aux ( mesh ), aux1 ( mesh ), gx ! auxiliary variables ! gx = modulus of g_cart vectors integer :: ig , ir ! counters ! ! Pseudopotentials in numerical form (Vnl(lloc) contain the local part) ! in order to perform the Fourier transform, a term erf(r)/r is ! subtracted in real space and added again in G space ! ! first the G=0 term ! do ir = 1 , msh aux ( ir ) = r ( ir ) * ( r ( ir ) * vloc_at ( ir ) + TWO * zp ) enddo call simpson ( msh , aux , rab , vloc0 ) ! !   here the G<>0 terms, we first compute the part of the integrand func !   indipendent of |G| in real space ! do ir = 1 , msh aux1 ( ir ) = r ( ir ) * vloc_at ( ir ) + TWO * zp * qe_erf ( r ( ir )) enddo fac = TWO * zp / tpiba2 ! !    and here we perform the integral, after multiplying for the |G| !    dependent  part ! do ig = 1 , nG g2a = ( q_cart ( 1 ) + g_cart ( 1 , ig )) ** 2 + ( q_cart ( 2 ) + g_cart ( 2 , ig )) ** 2 + ( q_cart ( 3 ) + g_cart ( 3 , ig )) ** 2 if ( g2a < eps ) then vlocq ( ig ) = vloc0 else gx = sqrt ( g2a * tpiba2 ) do ir = 1 , msh aux ( ir ) = aux1 ( ir ) * sin ( gx * r ( ir )) / gx enddo call simpson ( msh , aux , rab , vlcp ) ! !     here we add the analytic fourier transform of the erf function ! vlocq ( ig ) = vlcp - fac * exp ( - g2a * tpiba2 * 0.25d0 ) / g2a endif enddo vlocq (:) = vlocq (:) * fpi / omega end subroutine setlocq subroutine setlocq_coul ( q_cart , zp , tpiba2 , nG , g_cart , omega , vlocq ) !---------------------------------------------------------------------- ! ! Fourier transform of the Coulomb potential - For all-electron ! calculations, in specific cases only, for testing purposes ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2001-2009 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! use kinds , only : dp use intw_useful_constants , only : fpi , TWO , eps_8 implicit none ! integer , intent ( in ) :: nG real ( kind = dp ), intent ( in ) :: q_cart ( 3 ), zp , tpiba2 , omega , g_cart ( 3 , nG ) real ( kind = dp ), intent ( out ) :: vlocq ( nG ) ! real ( kind = dp ) :: g2a integer :: ig do ig = 1 , nG g2a = ( q_cart ( 1 ) + g_cart ( 1 , ig )) ** 2 + ( q_cart ( 2 ) + g_cart ( 2 , ig )) ** 2 + ( q_cart ( 3 ) + g_cart ( 3 , ig )) ** 2 if ( g2a < eps_8 ) then vlocq ( ig ) = 0.d0 else vlocq ( ig ) = - fpi * TWO * zp / omega / tpiba2 / g2a endif enddo end subroutine setlocq_coul end module intw_pseudo_local","tags":"","url":"sourcefile/intw_pseudo_local.f90.html"},{"title":"ph_module.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_ph !! display: none !! !! This module contains the main variables related to phonon modes. !! use kinds , only : dp implicit none ! save ! variables public :: q_irr_cryst , u_irr , dvscf_cart , dvscf_irr , & nqmesh , qmesh , & QE_folder_nosym_q , QE_folder_sym_q , symlink_q ! ! subroutines public :: rot_gep , read_ph_information , readfc , mat_inv_four_t , read_allq_dvr , & get_dv , rot_dvq , func_by_gr , wsinit , & read_dynq , set_asr_frc , set_asr_dynq , rotate_dyn ! ! functions public :: wsweight , rot_k_index ! private ! ! real ( dp ), allocatable :: q_irr_cryst (:,:) ! coo. of irr. q points complex ( dp ), allocatable :: u_irr (:,:,:) ! displacement patterns for the irr.  q. complex ( dp ), allocatable :: dvscf_cart (:,:,:,:,:), dvscf_irr (:,:,:,:) integer :: nqmesh real ( dp ), allocatable :: qmesh (:,:) integer , allocatable :: QE_folder_nosym_q (:) integer , allocatable :: QE_folder_sym_q (:) integer , allocatable :: symlink_q (:,:) contains subroutine rot_gep ( s_index , imq , qpoint_irr , nbnd , nspin , nat , g_matin , g_matout ) use intw_symmetries , only : rtau_index , inverse_indices , rtau use intw_reading , only : bg , s , at use intw_useful_constants , only : tpi , cmplx_0 , cmplx_i implicit none ! input real ( dp ), intent ( in ) :: qpoint_irr ( 3 ) integer , intent ( in ) :: imq , nbnd , nspin , nat complex ( dp ), intent ( in ) :: g_matin ( nbnd , nbnd , nspin , nspin , 3 * nat ) complex ( dp ), intent ( out ) :: g_matout ( nbnd , nbnd , nspin , nspin , 3 * nat ) ! local integer :: s_index , s_inv_index , na integer :: rna complex ( dp ) :: phase ( nat ) integer :: kpol , jpol , lpol , ipol , ibnd , jbnd real ( dp ) :: s_cart ( 3 , 3 ), qpoint_irr_cart ( 3 ) qpoint_irr_cart = matmul ( bg , qpoint_irr ) g_matout = cmplx_0 s_inv_index = inverse_indices ( s_index ) do na = 1 , nat phase ( na ) = & exp ( - cmplx_i * tpi * dot_product ( qpoint_irr_cart (:), rtau (:, s_index , na )) ) enddo do ipol = 1 , 3 do jpol = 1 , 3 ! s_cart ( ipol , jpol ) = 0.d0 do kpol = 1 , 3 do lpol = 1 , 3 s_cart ( ipol , jpol ) = s_cart ( ipol , jpol ) + at ( ipol , kpol ) * & real ( s ( lpol , kpol , s_index ), dp ) * bg ( jpol , lpol ) enddo enddo ! enddo enddo do na = 1 , nat rna = rtau_index ( na , s_index ) do ibnd = 1 , nbnd do jbnd = 1 , nbnd ! do ipol = 1 , 3 do jpol = 1 , 3 g_matout ( ibnd , jbnd , 1 : nspin , 1 : nspin , ( rna - 1 ) * 3 + ipol ) = & g_matout ( ibnd , jbnd , 1 : nspin , 1 : nspin , ( rna - 1 ) * 3 + ipol ) & + phase ( rna ) * s_cart ( ipol , jpol ) * g_matin ( ibnd , jbnd , 1 : nspin , 1 : nspin , ( na - 1 ) * 3 + jpol ) enddo ! jpol enddo ! ipol ! enddo ! jbnd enddo ! ibnd enddo ! na if ( imq == 1 ) g_matout = conjg ( g_matout ) end subroutine rot_gep function rot_k_index ( s_index , k_index , nk1 , nk2 , nk3 , kmesh ) use intw_reading , only : s use intw_utility , only : find_k_1BZ_and_G , triple_to_joint_index_g implicit none integer , intent ( in ) :: s_index , k_index , nk1 , nk2 , nk3 real ( dp ), intent ( in ) :: kmesh ( 3 , nk1 * nk2 * nk3 ) integer :: rot_k_index real ( dp ) :: kpoint_1bz ( 3 ), kpoint_rot ( 3 ) integer :: GKQ_bz ( 3 ), i , j , k kpoint_rot = matmul ( s (:,:, s_index ), kmesh (:, k_index )) call find_k_1BZ_and_G ( kpoint_rot , nk1 , nk2 , nk3 , i , j , k , kpoint_1bz , GKQ_bz ) call triple_to_joint_index_g ( nk1 , nk2 , nk3 , rot_k_index , i , j , k ) end function rot_k_index subroutine read_ph_information () ! !This subroutine reads the information related to phonons from files. ! use intw_input_parameters , only : outdir , prefix , qlist , nqirr , nq1 , nq2 , nq3 use intw_reading , only : nat , bg use intw_matrix_vector , only : ainv use intw_utility , only : find_free_unit implicit none integer :: io_unit , ios character ( 256 ) :: datafile real ( dp ) :: qpoint ( 3 ) integer :: imode , jmode , iq character ( 8 ) :: dummy write ( * , \"(A)\" ) \"|   PH BZ division is:                              |\" write ( * , \"(3(A,I2),38X,A1)\" ) \"|   \" , nq1 , \" x\" , nq2 , \" x\" , nq3 , \"|\" write ( * , \"(A)\" ) \"|   Input n. of irreducible points:                 |\" write ( * , \"(A1,3X,I3,45X,A1)\" ) \"|\" , nqirr , \"|\" write ( * , \"(A)\" ) \"| - Reading irreducible q-point list...             |\" ! Read irreducible q list allocate ( q_irr_cryst ( 3 , nqirr )) io_unit = find_free_unit () open ( unit = io_unit , file = trim ( outdir ) // trim ( qlist ), status = \"old\" , iostat = ios ) if ( ios /= 0 ) stop \"ERROR: read_ph_information: error opening qlist.\" do iq = 1 , nqirr read ( io_unit , * ) dummy , qpoint ( 1 : 3 ) q_irr_cryst (:, iq ) = matmul ( ainv ( bg ), qpoint ) enddo close ( unit = io_unit ) write ( * , \"(A)\" ) \"| - Reading displacement patterns...                |\" io_unit = find_free_unit () datafile = trim ( outdir ) // trim ( prefix ) // \".save.intw/\" // \"irrq_patterns.dat\" open ( unit = io_unit , file = datafile , status = \"old\" , iostat = ios ) if ( ios /= 0 ) stop \"ERROR: read_ph_information: error opening irrq_patterns.\" ! Read displacement patters for each q. allocate ( u_irr ( 3 * nat , 3 * nat , nqirr )) do iq = 1 , nqirr read ( unit = io_unit , fmt =* ) dummy do imode = 1 , 3 * nat read ( unit = io_unit , fmt =* ) ( u_irr ( jmode , imode , iq ), jmode = 1 , 3 * nat ) end do end do ! iq close ( unit = io_unit ) end subroutine read_ph_information subroutine readfc ( flfrc , frc ) ! ! Read QE force constants file ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2001-2009 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! !  Modifications by INTW group, 2024: !   - Intent(in) variables specified explicitly. !   - Remove MPI parts. !   - Add some checks. ! use intw_reading , only : nat , ntyp , at , alat , amass , ityp , tau use intw_utility , only : find_free_unit use intw_useful_constants , only : cmplx_1 , eps_6 , Ry_to_Ha , pmass use intw_input_parameters , only : nq1 , nq2 , nq3 , apply_asr implicit none character ( 256 ), intent ( in ) :: flfrc complex ( dp ), intent ( out ) :: frc ( nq1 , nq2 , nq3 , 3 , 3 , nat , nat ) ! force constants ! local variables integer :: ntyp_fc , nat_fc integer :: nr1_fc , nr2_fc , nr3_fc , ibrav_fc , ityp_fc ( nat ) real ( dp ) :: alat_fc , celldm_fc ( 6 ), at_fc ( 3 , 3 ), amass_fc ( ntyp ), tau_fc ( 3 , nat ), zeu_fc ( 3 , 3 , nat ) logical :: has_zstar real ( dp ) :: epsil_fc ( 3 , 3 ) character ( 3 ) :: atm character ( 9 ) :: symm_type integer :: nt integer :: i , j , na , nb , m1 , m2 , m3 integer :: ibid , jbid , nabid , nbbid , m1bid , m2bid , m3bid integer :: io_unit , ios real ( dp ) :: frc_R ( nq1 , nq2 , nq3 , 3 , 3 , nat , nat ) io_unit = find_free_unit () open ( unit = io_unit , file = flfrc , status = 'old' , form = 'formatted' , iostat = ios ) if ( ios /= 0 ) stop 'ERROR: readfc: error opening flfrc' ! !  read cell data ! read ( io_unit , * ) ntyp_fc , nat_fc , ibrav_fc , ( celldm_fc ( i ), i = 1 , 6 ) if ( ibrav_fc == 0 ) then read ( io_unit , '(a)' ) symm_type read ( io_unit , * ) (( at_fc ( i , j ), i = 1 , 3 ), j = 1 , 3 ) end if ! alat_fc = celldm_fc ( 1 ) ! ! Some checks if ( nat_fc /= nat ) stop \"ERROR: readfc: Wrong number of atoms\" if ( ntyp_fc /= ntyp ) stop \"ERROR: readfc: Wrong number of species\" if ( ibrav_fc == 0 . and . any ( abs ( at_fc - at ) > eps_6 )) stop \"ERROR: readfc: Wrong lattice vectors\" if ( abs ( alat_fc - alat ) > eps_6 ) stop \"ERROR: readfc: Wrong lattice parameter\" ! ! !  read atomic types, positions and masses ! do nt = 1 , ntyp read ( io_unit , * ) i , atm , amass_fc ( nt ) end do ! do na = 1 , nat read ( io_unit , * ) i , ityp_fc ( na ), ( tau_fc ( j , na ), j = 1 , 3 ) end do ! ! More checks if ( any ( abs ( amass_fc / pmass * 2 - amass ) > eps_6 )) stop \"ERROR: readfc: Wrong atomic weights\" if ( any ( abs ( ityp_fc - ityp ) /= 0 )) stop \"ERROR: readfc: Wrong atomic types\" if ( any ( abs ( tau_fc - tau ) > eps_6 )) stop \"ERROR: readfc: Wrong atomic positions\" ! !  read macroscopic variable ! read ( io_unit , * ) has_zstar if ( has_zstar ) then read ( io_unit , * ) (( epsil_fc ( i , j ), j = 1 , 3 ), i = 1 , 3 ) do na = 1 , nat read ( io_unit , * ) read ( io_unit , * ) (( zeu_fc ( i , j , na ), j = 1 , 3 ), i = 1 , 3 ) end do endif ! read ( io_unit , * ) nr1_fc , nr2_fc , nr3_fc ! ! Even more checks if ( nr1_fc /= nq1 . or . nr2_fc /= nq2 . or . nr3_fc /= nq3 ) stop \"ERROR: readfc: Wrong supercell\" ! !  read real-space interatomic force constants ! frc (:,:,:,:,:,:,:) = 0.d0 do i = 1 , 3 do j = 1 , 3 do na = 1 , nat do nb = 1 , nat read ( io_unit , * ) ibid , jbid , nabid , nbbid read ( io_unit , * ) ((( m1bid , m2bid , m3bid , frc_R ( m1 , m2 , m3 , i , j , na , nb ), & m1 = 1 , nq1 ), m2 = 1 , nq2 ), m3 = 1 , nq3 ) ! in Ry/Bohr&#94;2 end do end do end do end do ! close ( unit = io_unit ) ! frc_R = frc_R * Ry_to_Ha ! Transform to a.u. ! ! MBR 21/05/2024 ! Instead of that set_asr module, use only the \"simple\" method ! (worked in the routine as real) if ( apply_asr ) then write ( * , * ) ' Applying ASR (simple) to force constant matrix' call set_asr_frc ( nq1 , nq2 , nq3 , nat , frc_R ) end if ! frc = frc_R * cmplx_1 ! make it complex end subroutine readfc !==================================================================== ! MBR 21/05/24 ! Apply ASR \"simple\" method: !   set_asr_frc --> to the real-space force constant matrix !                   (real elements) !   set_asr_dynr --> to the dynamical matrices after doing dynq_to_dynr !==================================================================== subroutine set_asr_frc ( n1 , n2 , n3 , nat , frc_R ) implicit none integer , intent ( in ) :: n1 , n2 , n3 , nat real ( dp ), intent ( inout ) :: frc_R ( n1 , n2 , n3 , 3 , 3 , nat , nat ) ! Internal integer :: i , j , iat , jat , i1 , i2 , i3 real ( dp ) :: suma do i = 1 , 3 ! coords. do j = 1 , 3 ! do iat = 1 , nat ! atom ! suma = 0.0_dp do jat = 1 , nat ! atom do i1 = 1 , n1 ! lattice vectors do i2 = 1 , n2 do i3 = 1 , n3 suma = suma + frc_R ( i1 , i2 , i3 , i , j , iat , jat ) end do end do end do ! lattice vectors ! end do ! jat atom ! frc_R ( 1 , 1 , 1 , i , j , iat , iat ) = frc_R ( 1 , 1 , 1 , i , j , iat , iat ) - suma ! end do ! iat atom ! end do end do ! coords. end subroutine set_asr_frc subroutine set_asr_dynq ( nq , iq , nat , dynq ) ! ! iq is the q=0 index in the mesh ! use intw_useful_constants , only : cmplx_1 implicit none integer , intent ( in ) :: nq , iq , nat complex ( dp ), intent ( inout ) :: dynq ( 3 * nat , 3 * nat , nq ) ! Internal integer :: i , j , iat , jat complex ( dp ) :: suma complex ( dp ) :: dynq_aux ( 3 * nat , 3 * nat , nq ) dynq_aux = dynq do i = 1 , 3 ! coords. do j = 1 , 3 ! do iat = 1 , nat ! atom ! suma = 0.0_dp do jat = 1 , nat ! atom ! sum over cells suma = suma + dynq (( iat - 1 ) * 3 + i , ( jat - 1 ) * 3 + j , iq ) end do ! jat atom ! ! option 1 : apply only to q=0: ! dynq_aux((iat-1)*3+i, (iat-1)*3+j, iq) = dynq((iat-1)*3+i, (iat-1)*3+j, iq) - suma ! option 2 : generalize to all q: dynq_aux (( iat - 1 ) * 3 + i , ( iat - 1 ) * 3 + j , :) = dynq (( iat - 1 ) * 3 + i , ( iat - 1 ) * 3 + j , :) - suma ! end do ! iat atom ! end do end do ! coords. dynq = dynq_aux end subroutine set_asr_dynq subroutine read_dynq ( dynq ) ! ! Read dynamical matrices of irreducible q-points from ! prefix.dyn_q(iq)_sym files in prefix.save.intw and store ! into dynq for all q-points by using symmetries to get ! dynamical matrices of the non-irreducible q-points ! use intw_reading , only : nat , lmag use intw_useful_constants , only : cmplx_i , tpi , Ry_to_Ha use intw_utility , only : find_free_unit , & triple_to_joint_index_g , find_k_1BZ_and_G use intw_input_parameters , only : outdir , prefix , nqirr , nq1 , nq2 , nq3 , & apply_asr implicit none ! I/O complex ( dp ), intent ( out ) :: dynq ( 3 * nat , 3 * nat , nqmesh ) ! Local ! I/O variables character ( 4 ) :: iq_str character ( 256 ) :: dynq_file , intwdir integer :: dynq_unit , ierr ! q-point variables real ( dp ) :: qirr_cryst ( 3 ), qirr_1BZ ( 3 ) integer :: Gq ( 3 ), i , j , k , iqirr2iq logical :: iq_done ( nqmesh ) ! Symmetry variables integer :: isym , tr ! Dynamical matrix variables complex ( dp ) :: dynq_irr ( 3 , 3 , nat , nat ), dynRq_irr ( 3 , 3 , nat , nat ) ! Loop variables integer :: iqirr , iq , ia , ja iq_done = . false . ! INTW directory intwdir = trim ( outdir ) // trim ( prefix ) // \".save.intw/\" do iqirr = 1 , nqirr ! ! open file if ( iqirr < 10 ) write ( iq_str , \"(i1)\" ) iqirr if ( 10 <= iqirr . and . iqirr < 100 ) write ( iq_str , \"(i2)\" ) iqirr if ( 100 <= iqirr . and . iqirr < 1000 ) write ( iq_str , \"(i3)\" ) iqirr dynq_unit = find_free_unit () dynq_file = trim ( intwdir ) // trim ( prefix ) // \".dyn_q\" // trim ( adjustl ( iq_str )) open ( unit = dynq_unit , iostat = ierr , file = dynq_file , form = 'formatted' , status = 'old' ) if ( ierr /= 0 ) then write ( * , * ) 'Error opening .dyn_q file in ' , trim ( intwdir ), ' . Stopping.' stop end if ! ! ! Read irreducible q-point read ( dynq_unit , '(11x,3(f14.9))' ) qirr_cryst ! ! Find index of irreducible q point in q-mesh call find_k_1BZ_and_G ( qirr_cryst , nq1 , nq2 , nq3 , i , j , k , qirr_1BZ , Gq ) call triple_to_joint_index_g ( nq1 , nq2 , nq3 , iqirr2iq , i , j , k ) ! ! ! And read dynamical matrix for the irreducible q-point do ia = 1 , nat do ja = 1 , nat ! ! Cartesian 3x3 block of this atom pair in dynq matrix do i = 1 , 3 read ( dynq_unit , * ) ( dynq_irr ( i , j , ia , ja ), j = 1 , 3 ) enddo ! end do ! ja end do ! ia ! ! ! Loop over symmetry equivalent q-points do iq = 1 , nqmesh ! if ( QE_folder_sym_q ( iq ) /= QE_folder_sym_q ( iqirr2iq )) cycle ! ! Check for consistency if ( QE_folder_sym_q ( iq ) /= iqirr ) stop \"ERROR: read_dynq\" ! ! Find symmetry operation isym = symlink_q ( iq , 1 ) tr = symlink_q ( iq , 2 ) ! ! Rotate dynamical matrix call rotate_dyn ( isym , qirr_cryst , dynq_irr (:,:,:,:), dynRq_irr ) ! ! Apply TR if ( (. not . lmag ) . and . tr == 1 ) dynRq_irr = conjg ( dynRq_irr ) ! For magnetic symmetries TR is applied by rotate_dyn ! do ia = 1 , nat do ja = 1 , nat ! ! Cartesian 3x3 block of this atom pair dynq (( ia - 1 ) * 3 + 1 : ia * 3 , ( ja - 1 ) * 3 + 1 : ja * 3 , iq ) = dynRq_irr (:,:, ia , ja ) ! enddo ! ja enddo ! ia ! iq_done ( iq ) = . true . ! end do ! iq ! close ( dynq_unit ) ! end do ! iqirr ! ! ! Check that all the qpoints in the full mesh have been read do iq = 1 , nqmesh if ( . not . iq_done ( iq ) ) then write ( * , * ) \"ERROR: read_dynq: Failed to read dynq for iq=\" , iq stop end if end do ! ! ! Apply ASR to q=0 matrix: ! \\sum_{ja} dynq( ia, i, ja, j, q=0) = 0 if ( apply_asr ) then write ( * , '(A)' ) '|   Applying ASR to all q vector indices            |' iq = 1 ! q=0 index in mesh call set_asr_dynq ( nqmesh , iq , nat , dynq ) end if end subroutine read_dynq subroutine rotate_dyn ( isym , q_cryst , dynq , dynRq ) ! ! Rotate dynamical matrix to the symmetry equivalent q point ! use intw_reading , only : nat , at , bg , lmag , s , TR use intw_useful_constants , only : eps_6 , cmplx_0 , cmplx_i , cmplx_1 , tpi use intw_utility , only : triple_to_joint_index_g , find_k_1BZ_and_G use intw_symmetries , only : rtau_index , rtau use intw_matrix_vector , only : ainv , det implicit none ! I/O integer , intent ( in ) :: isym ! Index of the symmetry operation used real ( dp ), intent ( in ) :: q_cryst ( 3 ) ! q point of the input dynamical matrix complex ( dp ), intent ( in ) :: dynq ( 3 , 3 , nat , nat ) ! input dynamical matrix complex ( dp ), intent ( out ) :: dynRq ( 3 , 3 , nat , nat ) ! dynamical matrix of the symmetry equivalent q point ! Local real ( dp ) :: q_cart ( 3 ), Rq_cart ( 3 ), s_cryst ( 3 , 3 ), s_cart ( 3 , 3 ) integer :: ia , ja , Sia , Sja complex ( dp ) :: phase ! Get the rotation matrix of the symmetry operation s_cryst = dble ( s (:,:, isym )) s_cart = transpose ( matmul ( at , matmul ( transpose ( s_cryst ), ainv ( at )))) ! Rotate the Q point q_cart = matmul ( bg , q_cryst ) Rq_cart = matmul ( s_cart , q_cart ) ! Rotate the dynamical matrix dynRq = cmplx_0 do ia = 1 , nat do ja = 1 , nat ! Sia = rtau_index ( ia , isym ) Sja = rtau_index ( ja , isym ) ! phase = exp ( - tpi * cmplx_i * dot_product ( Rq_cart , rtau (:, isym , ia ) - rtau (:, isym , ja ))) ! dynRq (:,:, Sia , Sja ) = phase * matmul ( s_cart , matmul ( dynq (:,:, ia , ja ), ainv ( s_cart ))) ! enddo enddo ! Apply TR if the magnetic symmetry requires it if ( lmag . and . TR ( isym )) dynRq = conjg ( dynRq ) end subroutine rotate_dyn subroutine mat_inv_four_t ( q_cryst , nkk1 , nkk2 , nkk3 , in_mat , out_mat ) ! ! This subroutine is based on the matdyn code distributed as part of ! the Quantum Espresso project and has been adapted to INTW: ! !   Copyright (C) 2001-2004 PWSCF group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! use intw_reading , only : tau , at , bg , nat use intw_useful_constants , only : tpi , cmplx_0 , cmplx_i , Ry_to_eV implicit none real ( dp ), intent ( in ) :: q_cryst ( 3 ) integer , intent ( in ) :: nkk1 , nkk2 , nkk3 complex ( dp ), intent ( in ) :: in_mat ( nkk1 , nkk2 , nkk3 , 3 , 3 , nat , nat ) ! FC matrix complex ( dp ), intent ( out ) :: out_mat ( 3 * nat , 3 * nat ) ! Dynamical matrix (without the mass factor) real ( dp ) :: q_cart ( 3 ) integer :: i , j integer :: na , nb real ( dp ) :: r ( 3 ), r_ws ( 3 ), weight , atw ( 3 , 3 ) real ( dp ) :: rws_aux ( 0 : 3 , 200 ) real ( dp ), allocatable :: rws (:,:) integer :: n1 , n2 , n3 , m1 , m2 , m3 , nrws real ( dp ) :: arg , total_weight integer , parameter :: nrwsx = 200 q_cart = matmul ( bg , q_cryst ) out_mat (:,:) = cmplx_0 atw (:, 1 ) = at (:, 1 ) * dble ( nkk1 ) atw (:, 2 ) = at (:, 2 ) * dble ( nkk2 ) atw (:, 3 ) = at (:, 3 ) * dble ( nkk3 ) call wsinit ( rws_aux , nrwsx , nrws , atw ) allocate ( rws ( 0 : 3 , nrws ) ) do i = 0 , 3 do j = 1 , nrws rws ( i , j ) = rws_aux ( i , j ) enddo enddo do na = 1 , nat do nb = 1 , nat ! total_weight = 0.0d0 do n1 = - 16 , 16 ! TODO we will need a wider range if the q-grid is very fine do n2 = - 16 , 16 do n3 = - 16 , 16 ! do i = 1 , 3 r ( i ) = n1 * at ( i , 1 ) + n2 * at ( i , 2 ) + n3 * at ( i , 3 ) r_ws ( i ) = r ( i ) + tau ( i , na ) - tau ( i , nb ) end do weight = wsweight ( r_ws , rws , nrws ) if ( weight > 0.0 ) then ! m1 = mod ( n1 + 1 , nkk1 ) if ( m1 <= 0 ) m1 = m1 + nkk1 m2 = mod ( n2 + 1 , nkk2 ) if ( m2 <= 0 ) m2 = m2 + nkk2 m3 = mod ( n3 + 1 , nkk3 ) if ( m3 <= 0 ) m3 = m3 + nkk3 ! arg = tpi * ( q_cart ( 1 ) * r ( 1 ) + q_cart ( 2 ) * r ( 2 ) + q_cart ( 3 ) * r ( 3 )) do i = 1 , 3 do j = 1 , 3 out_mat (( na - 1 ) * 3 + i , ( nb - 1 ) * 3 + j ) = out_mat (( na - 1 ) * 3 + i , ( nb - 1 ) * 3 + j ) & + in_mat ( m1 , m2 , m3 , i , j , na , nb ) * exp ( - cmplx_i * arg ) * weight end do end do end if ! total_weight = total_weight + weight ! end do end do end do ! if ( abs ( total_weight - nkk1 * nkk2 * nkk3 ) > 1.0d-8 ) then write ( * , * ) 'ERROR in mat_inv_fourier' write ( * , * ) 'total weight for R sumation:' , total_weight stop end if ! end do end do out_mat = 0.5d0 * ( out_mat + conjg ( transpose ( out_mat ))) deallocate ( rws ) end subroutine mat_inv_four_t subroutine read_allq_dvr () use intw_utility , only : find_free_unit use intw_reading , only : nr1 , nr2 , nr3 , lspin , nspin , lmag , nat use intw_useful_constants , only : I2 , sig_x , sig_y , sig_z , cmplx_0 use intw_input_parameters , only : outdir , prefix , nqirr implicit none ! local variables integer :: iq , record_length , mode , ios , jspin character ( 4 ) :: num integer :: nr ( 3 ), io_unit , ir , ispin , imode , jmode character ( 256 ) :: dv_name nr ( 1 ) = nr1 nr ( 2 ) = nr2 nr ( 3 ) = nr3 ! if ( lmag ) then allocate ( dvscf_irr ( nr1 * nr2 * nr3 , nqirr , 3 * nat , nspin ** 2 )) else allocate ( dvscf_irr ( nr1 * nr2 * nr3 , nqirr , 3 * nat , 1 )) endif allocate ( dvscf_cart ( nr1 * nr2 * nr3 , nqirr , 3 * nat , nspin , nspin )) ! dvscf_irr = cmplx_0 dvscf_cart = cmplx_0 ! inquire ( iolength = record_length ) dvscf_irr ( 1 : nr1 * nr2 * nr3 , 1 , 1 , 1 ) ! do iq = 1 , nqirr ! if ( iq <= 9 ) then write ( num , '(I1.1)' ) iq elseif ( iq >= 10 . and . iq <= 99 ) then write ( num , '(I2.2)' ) iq elseif ( iq >= 100 . and . iq <= 999 ) then write ( num , '(I3.3)' ) iq else write ( num , '(I4.4)' ) iq endif ! io_unit = find_free_unit () ! dv_name = trim ( prefix ) // \".dvscf_q\" // trim ( num ) ! open ( unit = io_unit , file = trim ( outdir ) // trim ( prefix ) // \".save.intw/\" // trim ( dv_name ), iostat = ios , & form = 'unformatted' , status = 'old' , access = 'direct' , recl = record_length ) if ( ios /= 0 ) stop \"ERROR: read_allq_dvr: error opening dv_name.\" ! write ( unit =* , fmt = \"(a,i2,a3)\" ) \"|   Reading file \" // & dv_name ( 1 : max ( 25 , len ( trim ( dv_name )))) // \" (ios \" , ios , \") |\" ! do mode = 1 , 3 * nat if ( lmag ) then read ( io_unit , rec = mode , iostat = ios ) ( dvscf_irr ( 1 : nr1 * nr2 * nr3 , iq , mode , ispin ), ispin = 1 , nspin ** 2 ) else read ( io_unit , rec = mode , iostat = ios ) dvscf_irr ( 1 : nr1 * nr2 * nr3 , iq , mode , 1 ) endif enddo ! mode ! ! Below not \"transpose(conjg(u_irr(:,:,iq))\", instead only \"conjg(u_irr(:,:,iq))\" because u_irr is already transpose! ! if ( lspin ) then ! if ( lmag ) then ! do ir = 1 , nr1 * nr2 * nr3 do imode = 1 , 3 * nat do jmode = 1 , 3 * nat do ispin = 1 , nspin do jspin = 1 , nspin ! dvscf_cart ( ir , iq , imode , ispin , jspin ) = dvscf_cart ( ir , iq , imode , ispin , jspin ) + & conjg ( u_irr ( imode , jmode , iq )) * dvscf_irr ( ir , iq , jmode , 1 ) * I2 ( ispin , jspin ) + & conjg ( u_irr ( imode , jmode , iq )) * dvscf_irr ( ir , iq , jmode , 2 ) * sig_x ( ispin , jspin ) + & conjg ( u_irr ( imode , jmode , iq )) * dvscf_irr ( ir , iq , jmode , 3 ) * sig_y ( ispin , jspin ) + & conjg ( u_irr ( imode , jmode , iq )) * dvscf_irr ( ir , iq , jmode , 4 ) * sig_z ( ispin , jspin ) enddo ! jspin enddo ! ispin enddo ! jmode enddo ! imode enddo ! ir ! else ! do ir = 1 , nr1 * nr2 * nr3 do imode = 1 , 3 * nat do jmode = 1 , 3 * nat ! dvscf_cart ( ir , iq , imode ,:,:) = dvscf_cart ( ir , iq , imode ,:,:) + & conjg ( u_irr ( imode , jmode , iq )) * dvscf_irr ( ir , iq , jmode , 1 ) * I2 (:,:) ! enddo ! jmode enddo ! imode enddo ! ir ! endif ! lmag ! else ! do ir = 1 , nr1 * nr2 * nr3 do imode = 1 , 3 * nat do jmode = 1 , 3 * nat ! dvscf_cart ( ir , iq , imode , 1 , 1 ) = dvscf_cart ( ir , iq , imode , 1 , 1 ) + & conjg ( u_irr ( imode , jmode , iq )) * dvscf_irr ( ir , iq , jmode , 1 ) ! enddo ! jmode enddo ! imode enddo ! ir ! end if ! lspin ! close ( io_unit ) ! enddo ! iq end subroutine read_allq_dvr subroutine get_dv ( qpoint_cryst , dv ) use intw_utility , only : triple_to_joint_index_g , find_k_1BZ_and_G use intw_reading , only : s , nr1 , nr2 , nr3 , nat , lspin , nspin use intw_useful_constants , only : I2 , sig_x , sig_y , sig_z , cmplx_0 use intw_input_parameters , only : nq1 , nq2 , nq3 use intw_matrix_vector , only : cmplx_trace implicit none ! I/O variables real ( dp ), intent ( in ) :: qpoint_cryst ( 3 ) complex ( dp ), intent ( out ) :: dv ( nr1 * nr2 * nr3 , 3 * nat , nspin , nspin ) ! local variables complex ( dp ) :: dvr ( nr1 * nr2 * nr3 , 3 * nat , nspin , nspin ) complex ( dp ) :: vr ( nspin , nspin ) complex ( dp ) :: mrx ( nspin , nspin ), mry ( nspin , nspin ), mrz ( nspin , nspin ) integer :: i , j , k real ( dp ) :: qpoint_1bz ( 3 ), q_irr_cryst_rot ( 3 ) integer :: q_index , q_index_irr , s_index , imq , ir , imode integer :: GKQ_bz ( 3 ), GKQ ( 3 ) dv = cmplx_0 ! ! We find the associated of qpoint in 1BZ (it usually is itself!) ! call find_k_1BZ_and_G ( qpoint_cryst , nq1 , nq2 , nq3 , i , j , k , qpoint_1bz , GKQ_bz ) call triple_to_joint_index_g ( nq1 , nq2 , nq3 , q_index , i , j , k ) ! ! We search the irr q related with qpoint and the sym.op. which gives ! qpoint from irr q ! q_index_irr = QE_folder_sym_q ( q_index ) s_index = symlink_q ( q_index , 1 ) imq = symlink_q ( q_index , 2 ) ! ! We rotate irr q using the symm.op. (s_index + imq) ! q_irr_cryst_rot = matmul ( s (:,:, s_index ), q_irr_cryst (:, q_index_irr )) if ( imq == 1 ) q_irr_cryst_rot = - q_irr_cryst_rot ! ! We define the lattice vector relating q1BZ and qrot ! GKQ = nint ( qpoint_cryst - q_irr_cryst_rot ) ! if ( sum ( abs ( qpoint_cryst - q_irr_cryst_rot - dble ( GKQ ))) > 1E-4 ) then write ( * , * ) \"ERROR: get_dv: qpoint not recovered by symmetry\" stop end if ! ! We rotate dV_cart of q_irr for finding dV_cart of q_rot ! call rot_dvq ( q_irr_cryst ( 1 : 3 , q_index_irr ), nr1 , nr2 , nr3 , s_index , & dvscf_cart ( 1 : nr1 * nr2 * nr3 , q_index_irr , 1 : 3 * nat , 1 : nspin , 1 : nspin ), dvr ) ! dv = dvr ! if ( imq == 1 ) then ! TR YES ! if ( lspin ) then ! do ir = 1 , nr1 * nr2 * nr3 do imode = 1 , 3 * nat ! vr = 0.5d0 * cmplx_trace ( matmul ( I2 , dvr ( ir , imode ,:,:))) mrx = 0.5d0 * cmplx_trace ( matmul ( sig_x , dvr ( ir , imode ,:,:))) mry = 0.5d0 * cmplx_trace ( matmul ( sig_y , dvr ( ir , imode ,:,:))) mrz = 0.5d0 * cmplx_trace ( matmul ( sig_z , dvr ( ir , imode ,:,:))) ! dv ( ir , imode ,:,:) = conjg ( vr (:,:)) * I2 - ( conjg ( mrx (:,:)) * sig_x & + conjg ( mry (:,:)) * sig_y & + conjg ( mrz (:,:)) * sig_z ) ! enddo ! imode enddo ! ir ! else ! dv = conjg ( dvr ) ! endif ! lspin ! endif ! TR ! ! with this we add to dV the phase for being associated to q1BZ from qrot ! call func_by_gr ( nr1 , nr2 , nr3 , 3 * nat , - dble ( GKQ ), dv ) end subroutine get_dv subroutine rot_dvq ( qpoint_irr_cryst , nr1 , nr2 , nr3 , s_index , dv_in , dv_out ) use intw_symmetries , only : rtau_index , spin_symmetry_matrices use intw_utility , only : triple_to_joint_index_r use intw_reading , only : s , ftau , nspin , lmag , at , bg , tau , nat use intw_useful_constants , only : cmplx_i , cmplx_0 , tpi use intw_matrix_vector , only : cmplx_ainv , ainv implicit none ! I/O variables real ( dp ), intent ( in ) :: qpoint_irr_cryst ( 3 ) integer , intent ( in ) :: nr1 , nr2 , nr3 , s_index complex ( dp ), intent ( in ) :: dv_in ( nr1 * nr2 * nr3 , 3 * nat , nspin , nspin ) complex ( dp ), intent ( out ) :: dv_out ( nr1 * nr2 * nr3 , 3 * nat , nspin , nspin ) ! local variables integer :: ir , ispin , jspin , i , j , k , ri , rj , rk , rri , rrj , rrk integer :: ipol , jpol , lpol , kpol , na , rna integer :: r_index , rr_index , imode real ( dp ) :: s_cart ( 3 , 3 ) real ( dp ) :: qpoint_irr_cart ( 3 ), qpoint_irr_cart_rot ( 3 ) complex ( dp ) :: dv_aux ( nr1 * nr2 * nr3 , 3 * nat , nspin , nspin ), phase ( nat ) ! ! q irr cryst -> cart ! qpoint_irr_cart = matmul ( bg , qpoint_irr_cryst ) ! ! We define our sym op. ! do ipol = 1 , 3 do jpol = 1 , 3 ! s_cart ( ipol , jpol ) = 0.d0 ! do kpol = 1 , 3 do lpol = 1 , 3 ! s_cart ( ipol , jpol ) = s_cart ( ipol , jpol ) + & at ( ipol , kpol ) * real ( s ( lpol , kpol , s_index ), dp ) * bg ( jpol , lpol ) ! enddo ! lpol enddo ! kpol ! enddo ! jpol enddo ! ipol ! ! We rotate q irr. q rot cryst -> cart ! qpoint_irr_cart_rot = matmul ( ainv ( s_cart ), qpoint_irr_cart ) ! ! phase of q irr related to the atoms. We must remove this phase and add the one related ! to q rot ! do na = 1 , nat phase ( na ) = exp ( cmplx_i * tpi * dot_product ( qpoint_irr_cart (:), tau (:, na ))) enddo ! na ! ! dV_Sq(r,na,alpha) = dV_q(Sr,Sna,Salpha) ! dv_out = cmplx_0 do ispin = 1 , nspin do jspin = 1 , nspin ! do k = 1 , nr3 do j = 1 , nr2 do i = 1 , nr1 ! ri = s ( 1 , 1 , s_index ) * ( i - 1 ) + s ( 2 , 1 , s_index ) * ( j - 1 ) + s ( 3 , 1 , s_index ) * ( k - 1 ) - nint ( ftau ( 1 , s_index ) * nr1 ) ! rj = s ( 1 , 2 , s_index ) * ( i - 1 ) + s ( 2 , 2 , s_index ) * ( j - 1 ) + s ( 3 , 2 , s_index ) * ( k - 1 ) - nint ( ftau ( 2 , s_index ) * nr2 ) ! rk = s ( 1 , 3 , s_index ) * ( i - 1 ) + s ( 2 , 3 , s_index ) * ( j - 1 ) + s ( 3 , 3 , s_index ) * ( k - 1 ) - nint ( ftau ( 3 , s_index ) * nr3 ) ! rri = mod ( ri , nr1 ) + 1 rrj = mod ( rj , nr2 ) + 1 rrk = mod ( rk , nr3 ) + 1 ! if ( rrk < 1 ) rrk = rrk + nr3 if ( rrj < 1 ) rrj = rrj + nr2 if ( rri < 1 ) rri = rri + nr1 ! call triple_to_joint_index_r ( nr1 , nr2 , nr3 , r_index , i , j , k ) call triple_to_joint_index_r ( nr1 , nr2 , nr3 , rr_index , rri , rrj , rrk ) ! do na = 1 , nat ! rna = rtau_index ( na , s_index ) ! do ipol = 1 , 3 do jpol = 1 , 3 ! dv_out ( r_index , ( na - 1 ) * 3 + ipol , ispin , jspin ) = dv_out ( r_index , ( na - 1 ) * 3 + ipol , ispin , jspin ) & + phase ( rna ) * s_cart ( jpol , ipol ) * dv_in ( rr_index , ( rna - 1 ) * 3 + jpol , ispin , jspin ) ! enddo ! jpol enddo ! ipol ! enddo ! na ! enddo ! i enddo ! j enddo ! k ! enddo ! jspin enddo ! ispin ! do na = 1 , nat phase ( na ) = exp ( - cmplx_i * tpi * dot_product ( qpoint_irr_cart_rot (:), tau (:, na ))) enddo ! na ! do ir = 1 , nr1 * nr2 * nr3 ! do ispin = 1 , nspin do jspin = 1 , nspin ! do na = 1 , nat do ipol = 1 , 3 ! dv_out ( ir , ( na - 1 ) * 3 + ipol , ispin , jspin ) = dv_out ( ir , ( na - 1 ) * 3 + ipol , ispin , jspin ) * phase ( na ) ! enddo ! ipol enddo ! na ! enddo ! jspin enddo ! ispin ! enddo ! ir ! ! Rotate the spin using spin symmetry matrices (could be done also using quaternion properties) ! if ( lmag ) then ! dv_aux = dv_out dv_out = cmplx_0 ! do ir = 1 , nr1 * nr2 * nr3 do imode = 1 , 3 * nat ! dv_out ( ir , imode ,:,:) = matmul ( cmplx_ainv ( spin_symmetry_matrices (:,:, s_index )), & matmul ( dv_aux ( ir , imode ,:,:), spin_symmetry_matrices (:,:, s_index ))) ! enddo ! imode enddo ! ir ! endif ! lmag end subroutine rot_dvq subroutine func_by_gr ( nr1 , nr2 , nr3 , nmode , q , dvr ) use intw_reading , only : nspin use intw_useful_constants , only : cmplx_i , cmplx_0 , tpi use intw_utility , only : joint_to_triple_index_r implicit none ! I/O variables integer , intent ( in ) :: nr1 , nr2 , nr3 , nmode complex ( dp ), intent ( inout ) :: dvr ( nr1 * nr2 * nr3 , nmode , nspin , nspin ) real ( dp ), intent ( in ) :: q ( 3 ) ! local variables integer :: ir , i , j , k , ispin , jspin , imode real ( dp ) :: phase do ir = 1 , nr1 * nr2 * nr3 ! call joint_to_triple_index_r ( nr1 , nr2 , nr3 , ir , i , j , k ) ! phase = tpi * ( q ( 1 ) * real ( i - 1 , dp ) / nr1 + q ( 2 ) * real ( j - 1 , dp ) / nr2 + q ( 3 ) * real ( k - 1 , dp ) / nr3 ) ! do imode = 1 , nmode do ispin = 1 , nspin do jspin = 1 , nspin ! dvr ( ir , imode , ispin , jspin ) = dvr ( ir , imode , ispin , jspin ) * exp ( cmplx_i * phase ) ! enddo ! jspin enddo ! ispin enddo ! imode ! enddo ! ir end subroutine func_by_gr subroutine wsinit ( rws , nrwsx , nrws , atw ) ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2001 PWSCF group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! implicit none integer :: i , ii , ir , jr , kr , nrws , nrwsx real ( dp ) :: rws ( 0 : 3 , nrwsx ), atw ( 3 , 3 ) integer , parameter :: nx = 2 real ( dp ), parameter :: eps = 1.0d-6 ii = 1 do ir = - nx , nx do jr = - nx , nx do kr = - nx , nx ! do i = 1 , 3 rws ( i , ii ) = atw ( i , 1 ) * ir + atw ( i , 2 ) * jr + atw ( i , 3 ) * kr end do ! rws ( 0 , ii ) = rws ( 1 , ii ) * rws ( 1 , ii ) + rws ( 2 , ii ) * rws ( 2 , ii ) + rws ( 3 , ii ) * rws ( 3 , ii ) rws ( 0 , ii ) = 0.5d0 * rws ( 0 , ii ) ! if ( rws ( 0 , ii ) > eps ) ii = ii + 1 if ( ii > nrwsx ) write ( * , * ) 'ERROR in wsinit' ! end do end do end do ! nrws = ii - 1 end subroutine wsinit function wsweight ( r , rws , nrws ) ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2001 PWSCF group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! implicit none integer :: ir , nreq , nrws real ( dp ) :: r ( 3 ), rrt , ck , rws ( 0 : 3 , nrws ), wsweight real ( dp ), parameter :: eps = 1.0d-6 wsweight = 0.d0 nreq = 1 do ir = 1 , nrws rrt = r ( 1 ) * rws ( 1 , ir ) + r ( 2 ) * rws ( 2 , ir ) + r ( 3 ) * rws ( 3 , ir ) ck = rrt - rws ( 0 , ir ) if ( ck > eps ) return if ( abs ( ck ) < eps ) nreq = nreq + 1 end do wsweight = 1.d0 / dble ( nreq ) end function wsweight end module intw_ph","tags":"","url":"sourcefile/ph_module.f90.html"},{"title":"ep_melements.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! program ep_melements !! display: none !! !! Compute electron-phonon matrix elements in a regular k- and q-mesh. !! !! ### Details !! !! This program calculates the electron-phonon matrix elements for !! a given mesh of k- and q-points. It reads wave functions, !! pseudopotentials, and phonon data, then computes the matrix elements !! by integrating over the Brillouin zone. !! !! The program can handle custom band selections or all available bands. !! !! #### Input parameters !! !! ```{.txt} !! &input !!     outdir                = 'directory' !!     prefix                = 'prefix' !!     nk1                   = integer !!     nk2                   = integer !!     nk3                   = integer !!     TR_symmetry           = T or F !!     use_exclude_bands     = 'none', 'wannier' or 'custom' !!     include_bands_initial = integer !!     include_bands_final   = integer !! / !! &ph !!     qlist = 'file' !!     nq1   = integer !!     nq2   = integer !!     nq3   = integer !!     nqirr = integer !! / !! &elphon !!     ep_mat_file      = 'file' !!     ep_bands         = 'intw' or 'custom' !!     ep_bands_initial = integer !!     ep_bands_final   = integer !! / !! ``` !! !! See [[intw_input_parameters]] module for the description of each parameter. !! use kinds , only : dp use intw_version , only : print_intw_version use intw_input_parameters , only : nk1 , nk2 , nk3 , & nq1 , nq2 , nq3 , nqirr , outdir , & ep_mat_file , & read_input , & ep_bands , ep_bands_initial , ep_bands_final use intw_reading , only : nkpoints_QE , kpoints_QE , nspin , lspin , nsym , & s , nGk_max , nat , tau , & nr1 , nr2 , nr3 , num_bands_intw , & read_parameters_data_file , & get_gvec , & read_kpoints_data_file , & set_num_bands use intw_pseudo , only : read_all_pseudo use intw_pseudo_local , only : calculate_local_part_dv , dvqpsi_local use intw_pseudo_non_local , only : init_KB_PP , & multiply_psi_by_dvKB use intw_utility , only : get_timing , print_threads , print_date_time , & find_free_unit , generate_kmesh , & conmesurate_and_coarser use intw_matrix_vector , only : ainv use intw_useful_constants , only : cmplx_0 , cmplx_1 use intw_symmetries , only : full_mesh , IBZ , QE_folder_nosym , QE_folder_sym , symlink , & symtable , rtau_index , rtau , rtau_cryst , rot_atoms , & find_size_of_irreducible_k_set , & allocate_symmetry_related_k , & find_inverse_symmetry_matrices_indices , & allocate_and_build_spin_symmetry_matrices , & set_symmetry_relations , multable use intw_fft , only : generate_nl , & allocate_fft use intw_ph , only : nqmesh , qmesh , QE_folder_nosym_q , QE_folder_sym_q , & symlink_q , q_irr_cryst , & read_ph_information , & read_allq_dvr , & get_dv use intw_allwfcs , only : allocate_and_get_all_irreducible_wfc , & get_psi_general_k_all_wfc !================================================================================ ! Declare the variables !================================================================================ implicit none !k point related variables integer :: ik , kmesh_nkirr , nkmesh real ( dp ), allocatable :: kmesh (:,:) real ( dp ) :: kpoint ( 3 ) !q point related variables real ( dp ) :: qpoint ( 3 ) integer :: iq , iq_global , iq_do , qmesh_nqirr logical :: full_mesh_q , IBZ_q character ( len = 4 ) :: iq_loc !wave function realted variables integer :: nGk , nGkq integer , allocatable :: list_igk (:) integer , allocatable :: list_igkq (:) complex ( dp ), allocatable :: wfc_k (:,:,:) complex ( dp ), allocatable :: wfc_kq (:,:,:) !phonon related variables complex ( dp ), allocatable :: dvq_local (:,:,:,:) !ep related variables integer :: num_bands_ep complex ( dp ), allocatable :: dvpsi (:,:,:,:,:) complex ( dp ), allocatable :: ep_mat_el (:,:,:,:,:,:) integer :: ep_unit , record_length , ierr !local/aux variables real ( dp ) :: time1 , time2 integer :: ibnd , jbnd , ispin , jspin , imode logical :: read_status complex ( dp ), external :: zdotc 20 format ( A ) 30 format ( A , F8 . 2 , 6 X , A ) ! ! !================================================================================ ! Beginning !================================================================================ ! call get_timing ( time1 ) ! write ( * , 20 ) '=====================================================' write ( * , 20 ) '|                program ep_melements               |' write ( * , 20 ) '|         ---------------------------------         |' call print_intw_version () call print_threads () call print_date_time ( \"Start of execution\" ) write ( * , 20 ) '=====================================================' ! ! !================================================================================ ! Read the necessary information from standard input file !================================================================================ ! call read_input ( read_status ) ! if ( read_status ) stop ! ! !================================================================================ ! Check if the k-mesh and q-mesh are conmesurate !================================================================================ ! if (. not . conmesurate_and_coarser ( nk1 , nk2 , nk3 , nq1 , nq2 , nq3 )) then write ( * , 20 ) '**********************************************************' write ( * , 20 ) '*ERROR                                                  ' write ( * , 20 ) '*   the electron k and phonon q are not                 ' write ( * , 20 ) '*   conmesurate and the k grid does not contain         ' write ( * , 20 ) '*   the phonon q grid                                   ' write ( * , 20 ) '**********************************************************' stop endif ! ! !================================================================================ ! Read the parameters from the SCF calculation !================================================================================ ! write ( * , 20 ) '| - Reading calculation parameters...               |' ! call read_parameters_data_file () ! ! !================================================================================ ! Set the number of wave functions !================================================================================ ! call set_num_bands () ! ! Select bands for which ep elements will be calculated ! if ( trim ( ep_bands ) . eq . 'custom' ) then num_bands_ep = ep_bands_final - ep_bands_initial + 1 write ( * , * ) ' ep_bands == custom chosen.' write ( * , * ) ' ep elements to be calculated for bands ' , ep_bands_initial , & ' to ' , ep_bands_final , ' of the num_bands_intw list' else ! all available bands num_bands_ep = num_bands_intw end if ! !================================================================================ ! Print spin information !================================================================================ ! if ( lspin ) then write ( * , 20 ) '| - Spin-polarized calculation nspin = 2            |' else write ( * , 20 ) '| - Paramagnetic calculation nspin = 1              |' endif ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Set symmetry arrays !================================================================================ ! write ( * , 20 ) '| - Setting symmetry arrays...                      |' ! ! Set the rotation table for each atom and symmetry allocate ( rtau_index ( nat , nsym )) allocate ( rtau ( 3 , nsym , nat )) allocate ( rtau_cryst ( 3 , nsym , nat )) ! call rot_atoms ( nat , nsym , tau ) ! ! Compute the indices of the inverse rotation matrices call find_inverse_symmetry_matrices_indices () ! ! Calculate the multiplication talble for symmetry operations allocate ( symtable ( nsym , nsym )) call multable ( nsym , s , symtable ) ! ! Set up spin_symmetry_matrices, needed to rotate wave functions and indueced potential for non-colinear calculations call allocate_and_build_spin_symmetry_matrices ( nsym ) ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Set up the gvec array and all FFT variables !================================================================================ ! write ( * , 20 ) '| - Reading G vectors...                            |' ! call get_gvec () ! ! Allocate useful variables call allocate_fft () ! ! Generate some important indices for FFT call generate_nl () ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Read PPs !================================================================================ ! write ( * , 20 ) '| - Reading pseudopotentials...                     |' ! call read_all_pseudo () ! write ( * , 20 ) '|                    PPs are OK                     |' ! ! Allocate and set PP variables call init_KB_PP () ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Read the kpoints from the calculation !================================================================================ ! write ( * , 20 ) '| - Reading k-points...                             |' ! allocate ( kpoints_QE ( 3 , nkpoints_QE )) ! call read_kpoints_data_file ( kpoints_QE ) ! ! !================================================================================ ! Build the wave function's k-mesh !================================================================================ ! write ( * , 20 ) '| - Building k-mesh...                              |' ! nkmesh = nk1 * nk2 * nk3 allocate ( kmesh ( 3 , nkmesh )) call generate_kmesh ( kmesh , nk1 , nk2 , nk3 ) ! ! Find the size of the irreducible set of k-points (IBZ) call find_size_of_irreducible_k_set ( nk1 , nk2 , nk3 , kmesh_nkirr ) ! ! !================================================================================ ! Set symmetry relations between irreducible k-points and full k-mesh !================================================================================ ! ! Allocate arrays call allocate_symmetry_related_k ( nk1 , nk2 , nk3 ) ! ! Fill the symmetry arrays call set_symmetry_relations ( nk1 , nk2 , nk3 , nkpoints_QE , kpoints_QE , & QE_folder_nosym , QE_folder_sym , symlink , & full_mesh , IBZ ) ! ! !================================================================================ ! Check that the number of kpoints corresponds to either a full mesh or the IBZ !================================================================================ ! if ( full_mesh . and . IBZ ) then write ( * , 20 ) '| - The kpoints present in the QE folders           |' write ( * , 20 ) '|   are consistent with a full 1BZ and a            |' write ( * , 20 ) '|   IBZ has also been found.                        |' write ( * , 20 ) '|         ---------------------------------         |' else if ( IBZ ) then write ( * , 20 ) '| - The kpoints present in the QE folders           |' write ( * , 20 ) '|   are consistent with an IBZ.                     |' write ( * , 20 ) '|         ---------------------------------         |' else write ( * , 20 ) '**********************************************************' write ( * , 20 ) '* The kpoints present in the QE folders are not consistent' write ( * , 20 ) '* with the parameters of the input file!                 ' write ( * , 20 ) '**********************************************************' write ( * , 20 ) '* debug information:                                *' write ( * , * ) '*        nkpoints_QE = ' , nkpoints_QE write ( * , * ) '*        nkmesh      = ' , nkmesh write ( * , * ) '*        kmesh_nkirr = ' , kmesh_nkirr stop end if ! ! !================================================================================ ! Read phonon information !================================================================================ ! write ( * , 20 ) '| - Reading q-points...                             |' ! ! Read q-points and irreducible patterns call read_ph_information () ! ! !================================================================================ ! Build the phonon q-mesh !================================================================================ ! write ( * , 20 ) '| - Building q-mesh...                              |' ! nqmesh = nq1 * nq2 * nq3 allocate ( qmesh ( 3 , nqmesh )) ! call generate_kmesh ( qmesh , nq1 , nq2 , nq3 ) ! ! Find the size of the irreducible set of q-points (IBZ) call find_size_of_irreducible_k_set ( nq1 , nq2 , nq3 , qmesh_nqirr ) ! ! !================================================================================ ! Symmetry relations between irreducible q-points and full q-mesh !================================================================================ ! allocate ( QE_folder_nosym_q ( nqmesh )) allocate ( QE_folder_sym_q ( nqmesh )) allocate ( symlink_q ( nqmesh , 2 )) ! call set_symmetry_relations ( nq1 , nq2 , nq3 , nqirr , q_irr_cryst , & QE_folder_nosym_q , QE_folder_sym_q , symlink_q , & full_mesh_q , IBZ_q ) ! ! !================================================================================ ! Check that the number of kpoints corresponds to either a full mesh or the IBZ !================================================================================ ! if ( full_mesh_q . and . IBZ_q ) then write ( * , 20 ) '| - The qpoints present in the QE folders           |' write ( * , 20 ) '|   are consistent with a full 1BZ and a            |' write ( * , 20 ) '|   IBZ has also been found.                        |' write ( * , 20 ) '|         ---------------------------------         |' else if ( IBZ_q ) then write ( * , 20 ) '| - The qpoints present in the QE folders           |' write ( * , 20 ) '|   are consistent with an IBZ.                     |' write ( * , 20 ) '|         ---------------------------------         |' else write ( * , 20 ) '**********************************************************' write ( * , 20 ) '* The qpoints present in the QE folders are not consistent' write ( * , 20 ) '* with the parameters of the input file!                 ' write ( * , 20 ) '**********************************************************' write ( * , 20 ) '* debug information:                                *' write ( * , * ) '*        nqpoints_QE = ' , nqirr write ( * , * ) '*        nqmesh      = ' , nqmesh write ( * , * ) '*        qmesh_nqirr = ' , qmesh_nqirr stop end if ! ! !================================================================================ ! Read all wave functions !================================================================================ ! write ( * , 20 ) '| - Reading wave functions...                       |' ! call allocate_and_get_all_irreducible_wfc () ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Read the induced potentials !================================================================================ ! write ( * , 20 ) '| - Reading induced potentials...                   |' ! call read_allq_dvr () ! write ( * , 20 ) '=====================================================' ! ! !================================================================================ ! Compute matrix elements !================================================================================ ! write ( * , 20 ) '| - Computing matrix elements...                    |' ! ! Allocate wfc related variables allocate ( list_igk ( nGk_max )) allocate ( list_igkq ( nGk_max )) allocate ( wfc_k ( nGk_max , num_bands_intw , nspin )) allocate ( wfc_kq ( nGk_max , num_bands_intw , nspin )) ! ! We will calculate num_bands_ep bands if ep_bands=custom ! indexed 1:num_bands_ep (ep_bands_initial to ep_bands_final) ! ! Allocate induced potential related variables allocate ( dvq_local ( nr1 * nr2 * nr3 , 3 * nat , nspin , nspin )) allocate ( dvpsi ( nGk_max , num_bands_ep , nspin , nspin , 3 * nat )) ! ! Allocate matrix elements variable allocate ( ep_mat_el ( nkmesh , num_bands_ep , num_bands_ep , nspin , nspin , 3 * nat )) inquire ( iolength = record_length ) ep_mat_el ! iq_global = 0 ! !$omp parallel do & !$omp default(none) & !$omp shared(nkmesh, kmesh) & !$omp shared(num_bands_intw, num_bands_ep, ep_bands, ep_bands_initial, ep_bands_final) & !$omp shared(nat, nspin, nGk_max) & !$omp shared(nqmesh, iq_global, qmesh) & !$omp shared(record_length, outdir, ep_mat_file) & !$omp private(iq, qpoint, ik, kpoint) & !$omp private(nGk, nGkq, list_iGk, list_iGkq, wfc_k, wfc_kq) & !$omp private(ep_unit, ierr, iq_loc) & !$omp private(ibnd, jbnd, ispin, jspin, imode) & !$omp private(dvq_local, dvpsi, ep_mat_el) do iq_do = 1 , nqmesh ! !$omp critical iq_global = iq_global + 1 iq = iq_global qpoint = qmesh (:, iq ) write ( * , \"(a,i4,a,a)\" ) \"|                    qpoint \" , iq , \"                    |\" write ( * , \"(a,3f10.5,a)\" ) \"|         q =\" , qpoint , \"         |\" ! if ( iq < 10 ) write ( iq_loc , \"(i1)\" ) iq if ( 10 <= iq . and . iq < 100 ) write ( iq_loc , \"(i2)\" ) iq if ( 100 <= iq . and . iq < 1000 ) write ( iq_loc , \"(i3)\" ) iq ! ep_unit = find_free_unit () open ( unit = ep_unit , iostat = ierr , & file = trim ( outdir ) // trim ( ep_mat_file ) // trim ( '_' ) // adjustl ( iq_loc ), & form = 'unformatted' , status = 'unknown' , access = 'direct' , recl = record_length ) if ( ierr /= 0 ) stop 'Error opening ep_mat_file' !$omp end critical ! ep_mat_el = cmplx_0 ! ! Get induced potential for q dvq_local = cmplx_0 call get_dv ( qpoint , dvq_local ) ! ! Add local part of the KB-PP to the induced potential call calculate_local_part_dv ( qpoint , dvq_local ) ! !$omp parallel do & !$omp default(none) & !$omp shared(nkmesh, kmesh) & !$omp shared(qpoint, dvq_local, ep_mat_el) & !$omp shared(num_bands_intw, num_bands_ep, ep_bands, ep_bands_initial, ep_bands_final) & !$omp shared(nat, nspin, nGk_max) & !$omp private(ik, kpoint) & !$omp private(nGk, nGkq, list_iGk, list_iGkq, wfc_k, wfc_kq) & !$omp private(ibnd, jbnd, ispin, jspin, imode) & !$omp private(dvpsi) do ik = 1 , nkmesh ! kpoint = kmesh (:, ik ) ! ! Get wave functions for k and k+q call get_psi_general_k_all_wfc ( kpoint , nGk , list_iGk , wfc_k ) call get_psi_general_k_all_wfc ( kpoint + qpoint , nGkq , list_iGkq , wfc_kq ) ! ! Multiply induced potential + local part of KB-PP with wave function: ! dvpsi: dv_q&#94;local x | psi_k > (G) ! if ( trim ( ep_bands ) . eq . 'intw' ) then call dvqpsi_local ( num_bands_intw , list_iGk , list_iGkq , wfc_k , dvq_local , dvpsi ) else if ( trim ( ep_bands ) . eq . 'custom' ) then call dvqpsi_local ( num_bands_ep , list_iGk , list_iGkq , & wfc_k (:, ep_bands_initial : ep_bands_final ,:), dvq_local , dvpsi ) end if ! ! Add non-local part of KB-PP multiplied with the wave function: ! dvpsi: --> dvpsi + dq&#94;mode [ KB projectors ] x | psi_k > (G) !            local + non-local ! if ( trim ( ep_bands ) . eq . 'intw' ) then call multiply_psi_by_dvKB ( kpoint , qpoint , list_iGk , list_iGkq , num_bands_intw , wfc_k , dvpsi ) else if ( trim ( ep_bands ) . eq . 'custom' ) then call multiply_psi_by_dvKB ( kpoint , qpoint , list_iGk , list_iGkq , & num_bands_ep , wfc_k (:, ep_bands_initial : ep_bands_final ,:), dvpsi ) end if ! do imode = 1 , 3 * nat ! This are Cartesian modes, not real phonon modes ! ! Compute matrix elements: ! ep_mat_el: < psi_{k+q} | x dvpsi do jspin = 1 , nspin do ispin = 1 , nspin do jbnd = 1 , num_bands_ep do ibnd = 1 , num_bands_ep ! ep_mat_el ( ik , ibnd , jbnd , ispin , jspin , imode ) = zdotc ( nGk_max , wfc_kq (:, ibnd , ispin ), 1 , dvpsi (:, jbnd , ispin , jspin , imode ), 1 ) ! enddo !ibnd (intw or custom) enddo !jbnd (intw or custom) enddo !is enddo !js ! enddo !imode ! enddo !ik !$omp end parallel do ! write ( unit = ep_unit , rec = 1 , iostat = ierr ) ep_mat_el (:,:,:,:,:,:) ! close ( unit = ep_unit ) ! #ifdef DEBUG ! Write the matrix elements to a formatted file to compare with QE matrix elements write ( 123400 + iq , \"(3f10.6)\" ) qpoint write ( 123400 + iq , \"(i4)\" ) nkmesh do ik = 1 , nkmesh kpoint = kmesh (:, ik ) write ( 123400 + iq , \"(i4,3f10.6)\" ) ik , kpoint write ( 123400 + iq , \"(i4,3f10.6)\" ) 2 * ( ik - 1 ) + 2 , kpoint + qpoint enddo write ( 123400 + iq , \"(4i4,2f20.15)\" )(((( ik , ibnd , jbnd , imode , sum ( ep_mat_el ( ik , ibnd , jbnd ,:,:, imode )), ibnd = 1 , num_bands_intw ), jbnd = 1 , num_bands_intw ), ik = 1 , nkmesh ), imode = 1 , 3 * nat ) #endif ! enddo !iq !$omp end parallel do ! ! !================================================================================ ! Finish !================================================================================ ! call get_timing ( time2 ) ! write ( * , 20 ) '|                      ALL DONE                     |' write ( * , 30 ) '|     Total time: ' , time2 - time1 , ' seconds            |' call print_date_time ( 'End of execution  ' ) write ( * , 20 ) '=====================================================' end program ep_melements","tags":"","url":"sourcefile/ep_melements.f90.html"},{"title":"ep_interp_on_trFS_wannier.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! program ep_on_trFS_wannier !! display: none !! !! Compute electron-phonon matrix elements on a triangulated Fermi !! surface using Wannier interpolation. !! !! ### Details !! !! This utility reads the electron-phonon matrix elements calculated by the utility !! [[ep_melements]] of INTW and interpolates them on a triangulated Fermi surface, !! following the method of: !! F. Giustino et al, Phys. Rev. B 76, 165108 (2007) !! Finally, interpolated matrix elements are saved to file. !! !! MBR 24/04/2024 !! !! #### Input parameters !! !! ```{.txt} !! &input !!     outdir                = 'directory' !!     prefix                = 'prefix' !!     nk1                   = integer !!     nk2                   = integer !!     nk3                   = integer !!     TR_symmetry           = T or F !!     use_exclude_bands     = 'none', 'wannier' or 'custom' !!     include_bands_initial = integer !!     include_bands_final   = integer !! / !! &ph !!     qlist           = 'file' !!     nq1             = integer !!     nq2             = integer !!     nq3             = integer !!     nqirr           = integer !! / !! &elphon !!     ep_mat_file         = 'file' !!     ep_bands            = 'intw' or 'custom' !!     ep_bands_initial    = integer !!     ep_bands_final      = integer !!     ep_interp_method    = 'wannier' !!     ep_interp_bands     = 'intw_bands' or 'ef_crossing' !!     nfs_sheets_initial  = integer !!     nfs_sheets_final    = integer !! / !! ``` !! !! See [[intw_input_parameters]] module for the description of each parameter. !! #ifdef _OPENMP use omp_lib , only : omp_get_num_threads , omp_get_thread_num #endif use kinds , only : dp use intw_version , only : print_intw_version use intw_useful_constants , only : cmplx_0 , cmplx_i , Ha_to_eV , tpi use intw_utility , only : get_timing , print_threads , print_date_time , find_free_unit , & find_k_1BZ_and_G , triple_to_joint_index_g , & generate_kmesh , cryst_to_cart use intw_matrix_vector , only : area_vec use intw_w90_setup , only : nrpts , & allocate_and_read_ham_r , allocate_and_read_u_mesh , & wann_rotate_matrix , wann_IFT_1index , wann_FT_1index_1k , & interpolate_1k use intw_input_parameters , only : nk1 , nk2 , nk3 , outdir , prefix , read_input , & nq1 , nq2 , nq3 , & ep_bands , ep_bands_initial , ep_bands_final , & use_exclude_bands , & ep_interp_method , ep_interp_bands , nfs_sheets_initial , nfs_sheets_final , & ep_mat_file use intw_reading , only : read_parameters_data_file , set_num_bands , & nat , nspin , lspin , num_bands_intw , num_wann_intw , at use intw_intw2wannier , only : nnkp_kpoints use intw_ph , only : nqmesh , qmesh , read_ph_information use intw_ph_interpolate , only : allocate_and_build_ws_irvec_q , & irvec_q , nrpts_q , ndegen_q , & wann_IFT_1index_q implicit none ! FS triangulation integer :: nfs_sheets_tot ! number of FS sheets considered integer :: nkpt_tr_tot , nkpt_tr_ibz_tot ! total number of kpoints in the FS and in the irreducible BZ wedge integer , allocatable :: nfs_sheet (:), & ! band indices of the FS sheets (from num_bands_intw set) nkpt_tr (:), & ! number of kpoints in each FS sheet nkpt_tr_ibz (:), & ! number of kpoints in each FS sheet irreducible BZ wedge nface_tr (:) ! number of faces in each FS sheet real ( dp ), allocatable :: kpts_tr (:,:), & ! list of all kpoints kpts_tr_area (:) ! area of each kpoint in the FS integer , allocatable :: ikibz_2_ik (:), & ! index of the ikibz kpoint inside the irreducible BZ wedge in the list of all kpoints ik_2_ish (:), & ! FS sheet index of kpts_tr(:,ik) ik_2_iks (:) ! index of kpts_tr(:,ik) in its FS sheet kpoints list ! Part I logical :: read_status character ( 5 ) :: ish_loc , comment character ( 100 ) :: file_off integer :: unit_off real ( dp ) :: k1 ( 3 ), k2 ( 3 ), k3 ( 3 ), kwei ! Part II character ( 4 ) :: iq_loc integer :: record_lengh , ierr , ep_unit integer :: ikq , irq integer :: nkmesh , Gkq_1bz ( 3 ) integer , allocatable :: kqmap (:,:) real ( dp ) :: kpoint ( 3 ), qpoint ( 3 ), kqpoint ( 3 ), kq_1bz ( 3 ) real ( dp ), allocatable :: kmesh (:,:), kqmesh (:,:,:) real ( dp ), allocatable :: eig_kint (:), eig_kqint (:) complex ( dp ) :: facq complex ( dp ), allocatable :: u_kint (:,:), u_kqint (:,:), u_kint_all (:,:,:) complex ( dp ), allocatable :: gmatkqk_wann (:,:,:,:), gmatL_wann (:,:,:,:,:,:,:), gmat_aux (:,:,:,:), & gmat_int (:,:), gmat_int_rot (:,:), gmat_aux1 (:,:,:), gep_int (:,:) complex ( dp ), allocatable :: ep_mat_el_coarse (:,:,:,:,:,:,:) integer :: i_start , i_end #ifdef _OPENMP integer :: n , n_remaining integer :: thread_id , thread_num #endif ! Part III logical :: have_ep character ( 256 ) :: file_ep integer :: unit_ep real ( dp ) :: kpoint_p ( 3 ) complex ( dp ), allocatable :: aep_mat_el (:,:,:,:,:) ! loop variables and indices integer :: ik , ikp , ikibz , ikibz_global , ikibz_do , iks , iksp integer :: ish , ishp , ib , ibp integer :: ik1 , ik2 , ik3 integer :: iface , iedge integer :: is , js integer :: ir integer :: iat integer :: iq ! timing real ( dp ) :: time1 , time2 20 format ( A ) 30 format ( A , F8 . 2 , 6 X , A ) !================================================================================ ! Beginning !================================================================================ call get_timing ( time1 ) write ( * , 20 ) '=====================================================' write ( * , 20 ) '|            program ep_on_triFS_wannier            |' write ( * , 20 ) '|       Wannier interpolation of e-p elements       |' write ( * , 20 ) '|               on the triangulated FS              |' write ( * , 20 ) '|         ---------------------------------         |' call print_intw_version () call print_threads () call print_date_time ( \"Start of execution\" ) write ( * , 20 ) '=====================================================' !================================================================================ ! Read the input file !================================================================================ call read_input ( read_status ) if ( read_status ) stop if ( ep_interp_method /= 'wannier' ) then write ( * , * ) 'ep_interp_method /= wannier in input. Stopping.' stop end if if ( use_exclude_bands /= \"wannier\" ) then write ( * , * ) 'use_exclude_bands /= wannier in input. Stopping.' stop end if !================================================================================ ! Read the parameters from the SCF calculation !================================================================================ write ( * , 20 ) '| - Reading calculation parameters...               |' call read_parameters_data_file () !================================================================================ ! Set the number of bands !================================================================================ ! this will read num_wann_intw and num_bands_intw dimensions call set_num_bands () !================================================================================ ! Print spin information !================================================================================ if ( lspin ) then write ( * , 20 ) '| - Spin-polarized calculation nspin = 2            |' else write ( * , 20 ) '| - Paramagnetic calculation nspin = 1              |' endif write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Choose Fermi surface sheets according to ep_interp_bands !================================================================================ if ( ep_interp_bands == 'intw_bands' ) then nfs_sheets_tot = num_bands_intw allocate ( nfs_sheet ( nfs_sheets_tot )) do ib = 1 , num_bands_intw nfs_sheet ( ib ) = ib end do else if ( ep_interp_bands == 'ef_crossing' ) then nfs_sheets_tot = nfs_sheets_final - nfs_sheets_initial + 1 allocate ( nfs_sheet ( nfs_sheets_tot )) do ib = 1 , nfs_sheets_tot nfs_sheet ( ib ) = nfs_sheets_initial + ib - 1 end do end if !================================================================================ ! Control: for the Wannier interpolation we need all coarse ep elements in the ! ep_bands == 'intw' set (otherwise we cannot rotate with the U matrices). ! Therefore, check if we will have all the elements, even though custom_bands ! was set. !================================================================================ if ( ep_bands == 'custom' . and . & ( ( ep_bands_initial /= 1 ) . or . ( ep_bands_final /= num_bands_intw ) ) ) then write ( * , * ) 'Coarse ep elements where calculated in the' , & ep_bands_initial , ' to' , ep_bands_final , ' band subset only.' write ( * , * ) 'This means that we cannot Wannier interpolate. Stopping.' stop end if !================================ Part I ==================================== !================================================================================ ! Read .off files !================================================================================ write ( * , 20 ) '=====================================================' write ( * , 20 ) '| - Reading .off files...                           |' allocate ( nkpt_tr ( nfs_sheets_tot ), nface_tr ( nfs_sheets_tot )) allocate ( nkpt_tr_ibz ( nfs_sheets_tot )) ! open all sheet files just to see dimensions of kpoint lists do ish = 1 , nfs_sheets_tot if ( ish < 10 ) write ( ish_loc , \"(i1)\" ) nfs_sheet ( ish ) if ( 10 <= ish . and . ish < 100 ) write ( ish_loc , \"(i2)\" ) nfs_sheet ( ish ) file_off = trim ( outdir ) // trim ( prefix ) // trim ( '.' ) // trim ( adjustl ( ish_loc )) // trim ( '_FS_tri.off' ) write ( * , '(A)' ) '|     ' // file_off ( 1 : max ( 45 , len ( trim ( file_off )))) // ' |' unit_off = find_free_unit () open ( unit_off , file = file_off , status = 'old' ) read ( unit_off , * ) comment read ( unit_off , * ) nkpt_tr ( ish ), nface_tr ( ish ), iedge ! number of vertices and faces (ignore edges) close ( unit_off ) ! open the IBZ off file and search for dimension nkpt_tr_ibz(ish). ! Its vertices coincide with the first nkpt_tr_ibz(ish) vertices of the full off vertex list. file_off = trim ( outdir ) // trim ( prefix ) // trim ( '.' ) // trim ( adjustl ( ish_loc )) // trim ( '_IBZ_FS_tri.off' ) unit_off = find_free_unit () open ( unit_off , file = file_off , status = 'old' ) read ( unit_off , * ) comment read ( unit_off , * ) nkpt_tr_ibz ( ish ), iface , iedge ! number of vertices (ignore faces and edges) close ( unit_off ) end do ! total number of k-points to be calculated nkpt_tr_tot = sum ( nkpt_tr ) nkpt_tr_ibz_tot = sum ( nkpt_tr_ibz ) write ( * , 20 ) '|   Number of k-points (total vertices):            |' write ( * , '(A1,3X,I6,42X,A1)' ) '|' , nkpt_tr_tot , '|' write ( * , 20 ) '|   Number of k-points in IBZ (total vertices):     |' write ( * , '(A1,3X,I6,42X,A1)' ) '|' , nkpt_tr_ibz_tot , '|' write ( * , 20 ) '|   Number of faces (total triangles):              |' write ( * , '(A1,3X,I6,42X,A1)' ) '|' , sum ( nface_tr ), '|' allocate ( kpts_tr ( 3 , nkpt_tr_tot ), kpts_tr_area ( nkpt_tr_tot )) allocate ( ikibz_2_ik ( nkpt_tr_ibz_tot )) allocate ( ik_2_ish ( nkpt_tr_tot )) allocate ( ik_2_iks ( nkpt_tr_tot )) ikibz_2_ik = - 10 ik_2_ish = - 10 ik_2_iks = - 10 ! open .off files again to read k-points do ish = 1 , nfs_sheets_tot if ( ish < 10 ) write ( ish_loc , \"(i1)\" ) nfs_sheet ( ish ) if ( 10 <= ish . and . ish < 100 ) write ( ish_loc , \"(i2)\" ) nfs_sheet ( ish ) ! .off file for this sheet file_off = trim ( outdir ) // trim ( prefix ) // trim ( '.' ) // trim ( adjustl ( ish_loc )) // trim ( '_FS_tri.off' ) unit_off = find_free_unit () open ( unit_off , file = file_off , status = 'old' ) read ( unit_off , * ) comment read ( unit_off , * ) ik , iface , iedge ! number vertices, faces and edges (I will ignore edges) ! read(unit_off,'(/)') ! DUDA... This will depend on how the line break is written in the file, I think... if ( ( ik /= nkpt_tr ( ish )) . or . ( iface /= nface_tr ( ish )) ) then write ( * , * ) 'Error reading ' , file_off , '. Stopping.' stop end if ! read vertices do iks = 1 , nkpt_tr ( ish ) ik = iks + sum ( nkpt_tr (: ish - 1 )) ik_2_ish ( ik ) = ish ik_2_iks ( ik ) = iks if ( iks <= nkpt_tr_ibz ( ish )) then ! kpoint is in the irreducible BZ wedge ikibz = iks + sum ( nkpt_tr_ibz (: ish - 1 )) ikibz_2_ik ( ikibz ) = ik endif read ( unit_off , * ) kpts_tr (:, ik ) ! units in the trFS.off file are cartesian 2pi/alat (\"tpiba\" for QE) end do ! Read (triangular) faces on this sheet. ! Each face contributes with 1/3 of its area to the effective area of each of its vertices. ! Calculate the are on the go and add the contribution to each vertex, storing for global indices (i.e. ik). do iface = 1 , nface_tr ( ish ) read ( unit_off , * ) ik , ik1 , ik2 , ik3 ! indices ik of the vertices of the face, indexed from 0 if ( ik /= 3 ) then write ( * , * ) 'Error reading ' , file_off , 'Only triangles allowed. Stopping.' stop end if ik1 = ik1 + 1 ik2 = ik2 + 1 ik3 = ik3 + 1 ! now, ik of the vertices of the face, indexed from 1 ik1 = ik1 + sum ( nkpt_tr (: ish - 1 )) ik2 = ik2 + sum ( nkpt_tr (: ish - 1 )) ik3 = ik3 + sum ( nkpt_tr (: ish - 1 )) ! now, ik in the global ik list ! triangle vertex vectors (cartesian 2pi/alat) k1 = kpts_tr (:, ik1 ) k2 = kpts_tr (:, ik2 ) k3 = kpts_tr (:, ik3 ) ! get spanned area and add contribution to each vertex ! function copied from FSH/modules/geometry.f90 kwei = area_vec ( k2 - k1 , k3 - k1 ) / 3.0_dp kpts_tr_area ( ik1 ) = kpts_tr_area ( ik1 ) + kwei kpts_tr_area ( ik2 ) = kpts_tr_area ( ik2 ) + kwei kpts_tr_area ( ik3 ) = kpts_tr_area ( ik3 ) + kwei end do close ( unit_off ) end do if ( any ( ikibz_2_ik == - 10 )) stop \"ERROR ikibz_2_ik\" if ( any ( ik_2_ish == - 10 )) stop \"ERROR ik_2_ib\" if ( any ( ik_2_iks == - 10 )) stop \"ERROR ik_2_iks\" write ( * , 20 ) '|   .... reading done                               |' write ( * , 20 ) '|   Total FS area:                                  |' write ( * , '(A1,3X,F12.6,A19,17X,A1)' ) '|' , sum ( kpts_tr_area ), ' (2 x pi / alat)&#94;2 ' , '|' write ( * , 20 ) '|                                                   |' write ( * , 20 ) '| ---------------- Part I completed --------------- |' write ( * , 20 ) '|                                                   |' write ( * , 20 ) '=====================================================' !================================ Part II ==================================== !================================================================================ ! Read u_mesh file from w902intw !================================================================================ write ( * , 20 ) '| - Reading Wannier U matrix...                     |' call allocate_and_read_u_mesh () !================================================================================ ! Read ham_r file from w902intw, to be used in band interpolation ! (theis also allocates and reads the irvec list) !================================================================================ write ( * , 20 ) '| - Reading Wannier H(R)...                         |' call allocate_and_read_ham_r () write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Read phonon information !================================================================================ write ( * , 20 ) '| - Reading phonon info...                          |' ! Read irreducible q-points and irreducible patterns call read_ph_information () !================================================================================ ! Generate coarse meshes !================================================================================ write ( * , 20 ) '| - Building coarse k-mesh...                       |' nkmesh = nk1 * nk2 * nk3 allocate ( kmesh ( 3 , nkmesh )) call generate_kmesh ( kmesh , nk1 , nk2 , nk3 ) write ( * , 20 ) '| - Building coarse q-mesh...                       |' nqmesh = nq1 * nq2 * nq3 allocate ( qmesh ( 3 , nqmesh )) call generate_kmesh ( qmesh , nq1 , nq2 , nq3 ) ! DUDA kmesh is equal to nnkp_kpoints, but I do not know if this is general ! if not, we have to use kmesh explicitly in the (I)FTs ! do ik=1,nkmesh !   write(*,'(i3,3f7.3)') ik, kmesh(:,ik)-nnkp_kpoints(:,ik) ! end do ! k+q mesh and index correspondence allocate ( kqmesh ( 3 , nqmesh , nkmesh )) allocate ( kqmap ( nqmesh , nkmesh )) do iq = 1 , nqmesh qpoint = qmesh (:, iq ) do ik = 1 , nkmesh kpoint = kmesh (:, ik ) ! nnkp_kpoints(:,ik) is equivalent kqpoint = kpoint + qpoint kqmesh (:, iq , ik ) = kqpoint ! elements k+q,k are: ep_mat_el_coarse(iq,ik,:,:,is,js,imode) ! locate (k+q)-point index ikq in the kmesh call find_k_1BZ_and_G ( kqpoint , nk1 , nk2 , nk3 , ik1 , ik2 , ik3 , kq_1bz , Gkq_1bz ) call triple_to_joint_index_g ( nk1 , nk2 , nk3 , ikq , ik1 , ik2 , ik3 ) kqmap ( iq , ik ) = ikq end do end do write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Read ep mat elements !================================================================================ write ( * , 20 ) '| - Reading ep_mat files...                         |' allocate ( ep_mat_el_coarse ( nqmesh , nkmesh , num_bands_intw , num_bands_intw , nspin , nspin , 3 * nat )) inquire ( iolength = record_lengh ) ep_mat_el_coarse ( 1 ,:,:,:,:,:,:) do iq = 1 , nqmesh ep_unit = find_free_unit () if ( iq < 10 ) write ( iq_loc , \"(i1)\" ) iq if ( 10 <= iq . and . iq < 100 ) write ( iq_loc , \"(i2)\" ) iq if ( 100 <= iq . and . iq < 1000 ) write ( iq_loc , \"(i3)\" ) iq open ( unit = ep_unit , file = trim ( ep_mat_file ) // trim ( '_' ) // adjustl ( iq_loc ), & status = 'old' , form = 'unformatted' , access = 'direct' , recl = record_lengh ) read ( unit = ep_unit , rec = 1 , iostat = ierr ) ep_mat_el_coarse ( iq ,:,:,:,:,:,:) close ( unit = ep_unit ) end do write ( * , 20 ) '|                       ...done                     |' write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Get the WS vectors for the coarse q-mesh Wannier interpolation !================================================================================ write ( * , 20 ) '| - Building WS mesh...                             |' call allocate_and_build_ws_irvec_q () !================================================================================ ! ep elements in real space ! For each nspin,nspin,3*nat: !    1. rotate matrix g(k+q,k,m,n) to wannier gauge with u_mesh !    2. For k+q and k indices, inverse Fourier index by index. !       Note, k and q are fouriered on different grids. !================================================================================ write ( * , 20 ) '| - Fourier transform ep mat elements...            |' write ( * , '(A42,I4,A7)' ) '|   Number of WS vectors for k transform: ' , nrpts , '      |' write ( * , '(A42,I4,A7)' ) '|   Number of WS vectors for q transform: ' , nrpts_q , '      |' allocate ( gmatkqk_wann ( num_wann_intw , num_wann_intw , nqmesh , nkmesh )) allocate ( gmat_aux ( num_wann_intw , num_wann_intw , nqmesh , nrpts )) allocate ( gmatL_wann ( 3 * nat , num_wann_intw , num_wann_intw , nspin , nspin , nrpts_q , nrpts )) gmatL_wann = cmplx_0 do iat = 1 , 3 * nat do is = 1 , nspin do js = 1 , nspin ! 1. ! rotate U&#94;dagger(k+q) * gmat * U(k) gmatkqk_wann = cmplx_0 !$omp parallel do & !$omp default(none) & !$omp shared(is, js, iat) & !$omp shared(nqmesh, nkmesh, kqmap) & !$omp shared(ep_mat_el_coarse, gmatkqk_wann) & !$omp private(ik, ikq) do iq = 1 , nqmesh !$omp parallel do & !$omp default(none) & !$omp shared(is, js, iat) & !$omp shared(iq, nkmesh, kqmap) & !$omp shared(ep_mat_el_coarse, gmatkqk_wann) & !$omp private(ikq) do ik = 1 , nkmesh ikq = kqmap ( iq , ik ) call wann_rotate_matrix ( ikq , ik , ep_mat_el_coarse ( iq , ik ,:,:, is , js , iat ), gmatkqk_wann (:,:, iq , ik )) end do !$omp end parallel do end do !$omp end parallel do ! 2. ! Inverse Fourier over k-index, using kmesh and irvec grids gmat_aux = cmplx_0 !$omp parallel & !$omp default(none) & !$omp shared(nqmesh, nkmesh, kmesh) & !$omp shared(gmatkqk_wann, gmat_aux) & !$omp shared(thread_num, n, n_remaining) & !$omp private(thread_id, i_start, i_end) ! ! Calculate the range of iterations for this thread. ! If nqmesh is a multiple of thread_num, each thread ! will run n iterations. ! Otherwise, the first n_remaining threads will run ! an extra iteration. ! #ifdef _OPENMP !$omp single thread_num = omp_get_num_threads () n = int ( nqmesh / thread_num ) ! Number of iterations for each thread n_remaining = mod ( nqmesh , thread_num ) ! Remainig iterations that need to be distributed !$omp end single ! thread_id = omp_get_thread_num () i_start = n * thread_id + min ( thread_id , n_remaining ) + 1 i_end = n * ( thread_id + 1 ) + min ( thread_id + 1 , n_remaining ) #else i_start = 1 i_end = nqmesh #endif ! !$omp parallel do & !$omp default(none) & !$omp shared(nqmesh, nkmesh, kmesh) & !$omp shared(gmatkqk_wann, gmat_aux) & !$omp shared(i_start, i_end) do iq = i_start , i_end call wann_IFT_1index ( nkmesh , kmesh , gmatkqk_wann (:,:, iq ,:), gmat_aux (:,:, iq ,:)) end do !$omp end parallel do !$omp end parallel ! 3. ! Inverse Fourier over q-index, using qmesh and irvec_q grids !$omp parallel & !$omp default(none) & !$omp shared(iat, is, js) & !$omp shared(nrpts, nqmesh, qmesh) & !$omp shared(gmat_aux, gmatL_wann) & !$omp shared(thread_num, n, n_remaining) & !$omp private(thread_id, i_start, i_end) ! ! Calculate the range of iterations for this thread. ! If nrpts is a multiple of thread_num, each thread ! will run n iterations. ! Otherwise, the first n_remaining threads will run ! an extra iteration. ! #ifdef _OPENMP !$omp single thread_num = omp_get_num_threads () n = int ( nrpts / thread_num ) ! Number of iterations for each thread n_remaining = mod ( nrpts , thread_num ) ! Remainig iterations that need to be distributed !$omp end single ! thread_id = omp_get_thread_num () i_start = n * thread_id + min ( thread_id , n_remaining ) + 1 i_end = n * ( thread_id + 1 ) + min ( thread_id + 1 , n_remaining ) #else i_start = 1 i_end = nrpts #endif ! !$omp parallel do & !$omp default(none) & !$omp shared(iat, is, js) & !$omp shared(nrpts, nqmesh, qmesh) & !$omp shared(gmat_aux, gmatL_wann) & !$omp shared(i_start, i_end) do ir = i_start , i_end call wann_IFT_1index_q ( nqmesh , qmesh , gmat_aux (:,:,:, ir ), gmatL_wann ( iat ,:,:, is , js ,:, ir )) end do !$omp end parallel do !$omp end parallel end do ! spin end do ! spin write ( * , '(A38,I4,10X,A1)' ) '|     IFT on WS done for displacement ' , iat , '|' end do ! iat deallocate ( ep_mat_el_coarse ) deallocate ( gmat_aux , gmatkqk_wann ) write ( * , 20 ) '|                                                   |' write ( * , 20 ) '| --------------- Part II completed --------------- |' write ( * , 20 ) '|                                                   |' write ( * , 20 ) '=====================================================' !=============================== Part III ===================================== !================================================================================ ! Interpolate bands !================================================================================ write ( * , 20 ) '| - Interpolating Wannier U matrix...               |' ! interpolated bands in nkpt_tr_tot vertices ! u_kint_all, contains the rotation matrices (row is bloch and column is wannier, ! i.e. the \"orbital weights\" for each band is in the columns) ! band arrays allocate ( eig_kint ( num_wann_intw ), eig_kqint ( num_wann_intw )) allocate ( u_kint ( num_wann_intw , num_wann_intw ), u_kqint ( num_wann_intw , num_wann_intw )) allocate ( u_kint_all ( num_wann_intw , num_wann_intw , nkpt_tr_tot )) do ik = 1 , nkpt_tr_tot ! this is cartesians x 2pi/alat. Transform to crystal before interpolation kpoint = kpts_tr (:, ik ) call cryst_to_cart ( 1 , kpoint , at , - 1 ) call interpolate_1k ( kpoint , eig_kint , u_kint ) ! eig_kint = eig_kint * 2.0_dp / Ha_to_eV u_kint_all (:,:, ik ) = u_kint end do deallocate ( eig_kint ) !================================================================================ ! Interpolate elements ! Loop over k'=k+q, k electrons. Get interpolated ep elements and write out !================================================================================ write ( * , 20 ) '| - Interpolating e-p elements...                   |' ! the interpolation grid is formed by the triangulated FS points ! In principle, in the trianglulated k-point list up to nkpt_tr_tot ! the index carries the information about the band implicitly. ! We will retrieve U rotation matrices and eigenvalues on the ! full num_wann_intw list for those k-points, as the w90_setup ! routines give that info, but then we will intepolate the ep element only ! for the bands index at Fermi given by nfs_sheet(). ! ep arrays allocate ( gmat_aux1 ( num_wann_intw , num_wann_intw , nrpts )) allocate ( gmat_int ( num_wann_intw , num_wann_intw )) allocate ( gmat_int_rot ( num_wann_intw , num_wann_intw )) allocate ( gep_int ( num_wann_intw , num_wann_intw )) allocate ( aep_mat_el ( nkpt_tr_tot , nkpt_tr_ibz_tot , nspin , nspin , 3 * nat )) file_ep = trim ( outdir ) // trim ( prefix ) // trim ( '_ep_interp.dat' ) inquire ( file = file_ep , exist = have_ep ) if (. not . have_ep ) then ! calculate interpolated ep elements and write to file_ep ikibz_global = 0 !$omp parallel do & !$omp default(none) & !$omp shared(at, nat, nspin) & !$omp shared(kpts_tr, nkpt_tr_tot, nkpt_tr_ibz_tot, nfs_sheet) & !$omp shared(ikibz_2_ik, ik_2_iks, ik_2_ish) & !$omp shared(ndegen_q, irvec_q, nrpts_q, gmatL_wann) & !$omp shared(u_kint_all) & !$omp shared(aep_mat_el) & !$omp shared(ikibz_global) & !$omp private(ikibz, ik, iks, ish, ib, kpoint) & !$omp private(ikp, iksp, ishp, ibp, kpoint_p, qpoint) & !$omp private(gmat_aux1, gmat_int, gmat_int_rot) & !$omp private(u_kint, u_kqint) & !$omp private(irq, facq) & !$omp private(iat, is, js) do ikibz_do = 1 , nkpt_tr_ibz_tot !$omp critical ikibz_global = ikibz_global + 1 ikibz = ikibz_global ! ikibz is the k-index over kpoints in the irreducible BZ wedge ik = ikibz_2_ik ( ikibz ) ! ik is the corresponding k-index over kpoints in the full BZ kpts_tr list iks = ik_2_iks ( ik ) ! iks is the corresponding k-index over the kpoints in the FS sheet ! ish = ik_2_ish ( ik ) ! FS sheet index for k ib = nfs_sheet ( ish ) ! band index for k write ( * , '(A14,I4,A1,I4,A6,I5,A19)' ) '|     ik_IBZ: ' , ikibz , \"/\" , nkpt_tr_ibz_tot , ' (ik: ' , ik , \")                 |\" kpoint = kpts_tr (:, ik ) ! this is cartesians x 2pi/alat. Transform to cryst. call cryst_to_cart ( 1 , kpoint , at , - 1 ) ! interpolated bands in k and k' calculated above ! u_kint_all contains the rotation matrices (row is band and column is wannier, ! i.e. the \"orbital weights\" for each band is in the columns) u_kint = transpose ( conjg ( u_kint_all (:,:, ik ))) ! we will need \"dagger\" below for U(k+q) g U&#94;dagger(k) !$omp end critical !$omp parallel do & !$omp default(none) & !$omp shared(at, nat, nspin) & !$omp shared(ik_2_iks, ik_2_ish, nfs_sheet) & !$omp shared(kpts_tr, nkpt_tr_tot) & !$omp shared(ndegen_q, irvec_q, nrpts_q, gmatL_wann) & !$omp shared(u_kint_all, u_kint) & !$omp shared(aep_mat_el) & !$omp shared(ikibz, ib, kpoint) & !$omp private(iksp, ishp, ibp, kpoint_p, qpoint) & !$omp private(gmat_aux1, gmat_int, gmat_int_rot) & !$omp private(u_kqint) & !$omp private(irq, facq) & !$omp private(iat, is, js) do ikp = 1 , nkpt_tr_tot iksp = ik_2_iks ( ikp ) ! iksp is the corresponding k-index over the kpoints in the FS sheet ! ishp = ik_2_ish ( ikp ) ! FS sheet index for k ibp = nfs_sheet ( ishp ) ! band index for k' kpoint_p = kpts_tr (:, ikp ) ! this is cartesians x 2pi/alat. Transform to cryst. call cryst_to_cart ( 1 , kpoint_p , at , - 1 ) ! interpolated bands in k and k' calculated above ! u_kint_all contains the rotation matrices (row is band and column is wannier, ! i.e. the \"orbital weights\" for each band is in the columns) u_kqint = u_kint_all (:,:, ikp ) qpoint = kpoint_p - kpoint ! In the loop over atoms and directions below, I will ! interpolate matrix elements for each displacement. ! 1. interpolate irvec_q on this qpoint and store in gmat_aux1(:,:,nrpts) ! 2. interpolate irvec on kpoint and store in gmat_int. ! 3. Rotate Wannier as gmat_int_rot = U(k+q) * gmat_int * U(k)&#94;dagger ! 4. The ibp,ib elements are the ep element needed (in canonical atom displacement coordinates) ! TODO some of these can be done out of the 3nat and spin loops to go faster do js = 1 , nspin do is = 1 , nspin do iat = 1 , 3 * nat gmat_aux1 = cmplx_0 gmat_int = cmplx_0 gmat_int_rot = cmplx_0 do irq = 1 , nrpts_q facq = exp ( cmplx_i * tpi * dot_product ( qpoint (:), irvec_q (:, irq ))) / real ( ndegen_q ( irq ), dp ) ! TODO DUDA the spin order in gmatL_wann is correct??? gmat_aux1 (:,:,:) = gmat_aux1 (:,:,:) + facq * gmatL_wann ( iat ,:,:, js , is , irq ,:) end do call wann_FT_1index_1k ( kpoint , gmat_aux1 (:,:,:), gmat_int (:,:)) gmat_int_rot (:,:) = matmul ( u_kqint , matmul ( gmat_int , u_kint )) aep_mat_el ( ikp , ikibz , js , is , iat ) = gmat_int_rot ( ibp , ib ) ! TODO DUDA exclude bands ?? (ver junto al comentario JLB en w90_setup) end do end do end do ! spins end do ! k' !$omp end parallel do end do ! k deallocate ( gmat_aux1 , gmat_int , gmat_int_rot , gep_int ) ! Save interpolated matrix elements unit_ep = find_free_unit () open ( unit_ep , file = file_ep , status = 'unknown' ) write ( unit_ep , * ) '# ik(irr)   jk(full)    is js   g(canonical modes)' ! do ikibz = 1 , nkpt_tr_ibz_tot ! ik = ikibz_2_ik ( ikibz ) ! ik is the corresponding k-index over kpoints in the full BZ kpts_tr list iks = ik_2_iks ( ik ) ! iks is the corresponding k-index over the kpoints in the FS sheet ish = ik_2_ish ( ik ) ! FS sheet index for k ib = nfs_sheet ( ish ) ! band index for k ! do ikp = 1 , nkpt_tr_tot ! iksp = ik_2_iks ( ikp ) ! iksp is the corresponding k-index over the kpoints in the FS sheet ishp = ik_2_ish ( ikp ) ! FS sheet index for k ibp = nfs_sheet ( ishp ) ! band index for k' ! do js = 1 , nspin do is = 1 , nspin write ( unit_ep , fmt = \"(6i6,100e16.6)\" ) ibp , iksp , ikp , ib , iks , ikibz , & ( aep_mat_el ( ikp , ikibz , js , is , iat ), iat = 1 , 3 * nat ) end do end do ! end do ! k' ! end do ! k ! close ( unit_ep ) write ( * , 20 ) '| - e-p elements interpolated and written to file:  |' write ( * , 20 ) \"|   \" // file_ep ( 1 : max ( 47 , len ( trim ( file_ep )))) // \" |\" else ! have_ep--> read interpolated matrix elements write ( * , 20 ) '| - interpolated e-p file already exists. Check!    |' write ( * , 20 ) \"|   \" // file_ep ( 1 : max ( 47 , len ( trim ( file_ep )))) // \" |\" end if write ( * , 20 ) '|                                                   |' write ( * , 20 ) '|  -------------- Part III completed -------------- |' write ( * , 20 ) '|                                                   |' write ( * , 20 ) '=====================================================' !================================================================================ ! Finish !================================================================================ call get_timing ( time2 ) write ( * , 20 ) '|                      ALL DONE                     |' write ( * , 30 ) '|     Total time: ' , time2 - time1 , ' seconds            |' call print_date_time ( 'End of execution  ' ) write ( * , 20 ) '=====================================================' end program ep_on_trFS_wannier","tags":"","url":"sourcefile/ep_interp_on_trfs_wannier.f90.html"},{"title":"fft_interp.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_fft_interp !! display: none !! !! @note !! 29/11/2024: This module is not used anywhere and it is not tested, so it could be removed. !! use kinds , only : dp ! implicit none ! ! subroutines public :: fft_interp_3d_real ! private contains subroutine fft_interp_3d_real ( nr1 , nr2 , nr3 , nr1s , nr2s , nr3s , ecut , fr , frs ) ! ! This subroutine interpolates a real function (charge density, ...) from a ! (nr1,nr2,nr3) coarse FFT grid to a (nr1s,nr2s,nr3s) finer grid using ! Fourier interpolation. ! ! module variables use intw_useful_constants , only : cmplx_0 use intw_reading , only : bg , tpiba2 ! implicit none ! external :: cfftnd ! ! input variables integer , intent ( in ) :: nr1 , nr2 , nr3 ,& nr1s , nr2s , nr3s ! real space discretization real ( kind = dp ), intent ( in ) :: fr ( nr1 * nr2 * nr3 ) ! original function real ( kind = dp ), intent ( in ) :: ecut ! ! output variables real ( kind = dp ), intent ( out ) :: frs ( nr1s * nr2s * nr3s ) ! interpolated function ! ! local variables integer , allocatable :: nl (:), nls (:) ! map between origin centered G's and FFT G's complex ( kind = dp ), allocatable :: fg (:) complex ( kind = dp ), allocatable :: fft_dummy (:) integer :: nri1 , nrj2 , nrk3 integer :: i , j , k , ig real ( kind = dp ) :: G ( 3 ) integer , allocatable :: gvec (:,:) ! origin centered G vectors integer :: n1 , n2 , n3 integer :: ind ( nr1 , nr2 , nr3 ), inds ( nr1s , nr2s , nr3s ) ! (i,j,k) 3D --> it 1D mappings integer :: nG , cnt ! ! ! Initialize 3D --> 1D mappings ! cnt = 0 do k = 1 , nr3 do j = 1 , nr2 do i = 1 , nr1 cnt = cnt + 1 ind ( i , j , k ) = cnt ! 3D --> 1D enddo enddo enddo ! cnt = 0 do k = 1 , nr3s do j = 1 , nr2s do i = 1 , nr1s cnt = cnt + 1 inds ( i , j , k ) = cnt ! 3D --> 1D enddo enddo enddo ! ! ! Count G vectors inside Ecut ! nri1 = int ( nr1 / 2.0_dp ) nrj2 = int ( nr2 / 2.0_dp ) nrk3 = int ( nr3 / 2.0_dp ) ! nG = 0 do i = - nri1 , nri1 do j = - nrj2 , nrj2 do k = - nrk3 , nrk3 ! G = i * bg (:, 1 ) + j * bg (:, 2 ) + k * bg (:, 3 ) if ( G ( 1 ) ** 2 + G ( 2 ) ** 2 + G ( 3 ) ** 2 <= ecut / tpiba2 ) then nG = nG + 1 end if ! enddo enddo enddo ! ! ! Initialize G vectors ! allocate ( gvec ( 3 , nG ) ) ! ig = 0 do i = - nri1 , nri1 do j = - nrj2 , nrj2 do k = - nrk3 , nrk3 ! G = i * bg (:, 1 ) + j * bg (:, 2 ) + k * bg (:, 3 ) if ( G ( 1 ) ** 2 + G ( 2 ) ** 2 + G ( 3 ) ** 2 <= ecut / tpiba2 ) then ig = ig + 1 gvec (:, ig ) = ( / i , j , k / ) endif ! enddo enddo enddo ! ! ! Initialize G vector mappings ! allocate ( nl ( nG ), nls ( nG ) ) allocate ( fg ( nG ) ) ! do ig = 1 , nG ! n1 = modulo (( gvec ( 1 , ig )), nr1 ) + 1 n2 = modulo (( gvec ( 2 , ig )), nr2 ) + 1 n3 = modulo (( gvec ( 3 , ig )), nr3 ) + 1 nl ( ig ) = ind ( n1 , n2 , n3 ) ! n1 = modulo (( gvec ( 1 , ig )), nr1s ) + 1 n2 = modulo (( gvec ( 2 , ig )), nr2s ) + 1 n3 = modulo (( gvec ( 3 , ig )), nr3s ) + 1 nls ( ig ) = inds ( n1 , n2 , n3 ) ! enddo ! ! ! Fourier transform fr to G space ! allocate ( fft_dummy ( nr1 * nr2 * nr3 ) ) ! fft_dummy = cmplx ( fr , 0.0_dp , kind = dp ) ! call cfftnd ( 3 , ( / nr1 , nr2 , nr3 / ), - 1 , fft_dummy ) ! do ig = 1 , nG fg ( ig ) = fft_dummy ( nl ( ig )) enddo ! deallocate ( fft_dummy ) ! ! ! Obtain Fourier transform of frs from fg ! allocate ( fft_dummy ( nr1s * nr2s * nr3s ) ) ! fft_dummy = cmplx_0 ! do ig = 1 , nG fft_dummy ( nls ( ig )) = fg ( ig ) enddo ! if ( mod ( nr1 , 2 ) == 0 . and . nr1 /= nr1s ) then do j = 1 , nr2s do k = 1 , nr3s fft_dummy ( inds ( nr1 / 2 + 1 , j , k )) = 0.0_dp enddo enddo endif ! if ( mod ( nr2 , 2 ) == 0 . and . nr2 /= nr2s ) then do i = 1 , nr1s do k = 1 , nr3s fft_dummy ( inds ( i , nr2 / 2 + 1 , k )) = 0.0_dp enddo enddo endif ! if ( mod ( nr3 , 2 ) == 0 . and . nr3 /= nr3s ) then do i = 1 , nr1s do j = 1 , nr2s fft_dummy ( inds ( i , j , nr3 / 2 + 1 )) = 0.0_dp enddo enddo endif ! ! ! Fourier transform frs to real space ! call cfftnd ( 3 , ( / nr1s , nr2s , nr3s / ), + 1 , fft_dummy ) ! frs = real ( fft_dummy ) ! end subroutine fft_interp_3d_real end module intw_fft_interp","tags":"","url":"sourcefile/fft_interp.f90.html"},{"title":"matrix_vector.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_matrix_vector !! display: none !! !! This module contains functions and subroutines for matrix !! and vector operations. !! use kinds , only : dp public :: norma , cross , area_vec public :: ainv , det , minor_matrix public :: cmplx_ainv , cmplx_det , cmplx_minor_matrix , cmplx_trace private contains function norma ( v ) implicit none real ( kind = dp ), intent ( in ) :: v (:) real ( kind = dp ) :: norma norma = norm2 ( v ) ! norma = dot_product(v, v) end function norma function cross ( a , b ) implicit none real ( kind = dp ), dimension ( 3 ) :: cross real ( kind = dp ), dimension ( 3 ), intent ( in ) :: a , b CROSS ( 1 ) = A ( 2 ) * B ( 3 ) - A ( 3 ) * B ( 2 ) CROSS ( 2 ) = A ( 3 ) * B ( 1 ) - A ( 1 ) * B ( 3 ) CROSS ( 3 ) = A ( 1 ) * B ( 2 ) - A ( 2 ) * B ( 1 ) end function cross function area_vec ( v1 , v2 ) implicit none real ( kind = dp ), dimension ( 3 ), intent ( in ) :: v1 , v2 real ( kind = dp ) :: area_vec area_vec = ( v1 ( 2 ) * v2 ( 3 ) - v1 ( 3 ) * v2 ( 2 )) ** 2 + & ( v1 ( 3 ) * v2 ( 1 ) - v1 ( 1 ) * v2 ( 3 )) ** 2 + & ( v1 ( 1 ) * v2 ( 2 ) - v1 ( 2 ) * v2 ( 1 )) ** 2 area_vec = sqrt ( area_vec ) * 0.5_dp end function area_vec function ainv ( A ) use intw_useful_constants , only : eps_14 implicit none real ( kind = dp ), intent ( in ) :: A (:,:) real ( kind = dp ) :: ainv ( size ( A , dim = 1 ), size ( A , dim = 2 )) real ( kind = dp ) :: determinant real ( kind = dp ) :: cofactor ( size ( A , dim = 1 ), size ( A , dim = 2 )) integer :: N , M , i , j N = size ( A , dim = 1 ) M = size ( A , dim = 2 ) if ( N /= M ) stop \"ERROR: ainv: A must be a square matrix\" determinant = det ( A ) if ( abs ( determinant ) < eps_14 ) stop \"ERROR IN CALCULATING MATRIX INVERSE\" do i = 1 , N do j = 1 , M cofactor ( i , j ) = ( - 1 ) ** ( i + j ) * det ( minor_matrix ( A , i , j )) enddo end do ainv = transpose ( cofactor ) / determinant end function ainv recursive function det ( A ) result ( d ) implicit none real ( kind = dp ), intent ( in ) :: A (:,:) real ( kind = dp ) :: d integer :: N , M , i N = size ( A , dim = 1 ) M = size ( A , dim = 2 ) if ( N /= M ) stop \"ERROR: det: A must be a square matrix\" if ( N == 1 ) then d = A ( 1 , 1 ) else if ( N > 1 ) then d = 0.0_dp do i = 1 , N d = d + ( - 1 ) ** ( i + 1 ) * A ( 1 , i ) * det ( minor_matrix ( A , 1 , i )) enddo else stop \"ERROR: det: Wrong size\" end if end function det function minor_matrix ( A , ROW , COL ) implicit none real ( kind = dp ), intent ( in ) :: A (:,:) integer , intent ( in ) :: ROW , COL real ( kind = dp ) :: minor_matrix ( size ( A , dim = 1 ) - 1 , size ( A , dim = 2 ) - 1 ) integer :: N , M , i , ii , j , jj N = size ( A , dim = 1 ) M = size ( A , dim = 2 ) ii = 0 do i = 1 , N if ( i == ROW ) cycle ii = ii + 1 jj = 0 do j = 1 , N if ( j == COL ) cycle jj = jj + 1 minor_matrix ( ii , jj ) = A ( i , j ) end do end do end function minor_matrix function cmplx_ainv ( A ) use intw_useful_constants , only : cmplx_0 , eps_14 implicit none complex ( kind = dp ), intent ( in ) :: A (:,:) complex ( kind = dp ) :: cmplx_ainv ( size ( A , dim = 1 ), size ( A , dim = 2 )) complex ( kind = dp ) :: determinant complex ( kind = dp ) :: cofactor ( size ( A , dim = 1 ), size ( A , dim = 2 )) integer :: N , M , i , j N = size ( A , dim = 1 ) M = size ( A , dim = 2 ) if ( N /= M ) stop \"ERROR: cmplx_ainv: A must be a square matrix\" determinant = cmplx_det ( A ) if ( abs ( determinant ) < eps_14 ) stop \"ERROR IN CALCULATING MATRIX INVERSE\" do i = 1 , N do j = 1 , M cofactor ( i , j ) = ( - 1 ) ** ( i + j ) * cmplx_det ( cmplx_minor_matrix ( A , i , j )) enddo end do cmplx_ainv = transpose ( cofactor ) / determinant end function cmplx_ainv recursive function cmplx_det ( A ) result ( d ) use intw_useful_constants , only : cmplx_0 implicit none complex ( kind = dp ), intent ( in ) :: A (:,:) complex ( kind = dp ) :: d integer :: N , M , i N = size ( A , dim = 1 ) M = size ( A , dim = 2 ) if ( N /= M ) stop \"ERROR: cmplx_det: A must be a square matrix\" if ( N == 1 ) then d = A ( 1 , 1 ) else if ( N > 1 ) then d = cmplx_0 do i = 1 , N d = d + ( - 1 ) ** ( 1 + i ) * A ( 1 , i ) * cmplx_det ( cmplx_minor_matrix ( A , 1 , i )) enddo else stop \"ERROR: cmplx_det: Wrong size\" end if end function cmplx_det function cmplx_minor_matrix ( A , ROW , COL ) implicit none complex ( kind = dp ), intent ( in ) :: A (:,:) integer , intent ( in ) :: ROW , COL complex ( kind = dp ) :: cmplx_minor_matrix ( size ( A , dim = 1 ) - 1 , size ( A , dim = 2 ) - 1 ) integer :: N , M , i , ii , j , jj N = size ( A , dim = 1 ) M = size ( A , dim = 2 ) ii = 0 do i = 1 , N if ( i == ROW ) cycle ii = ii + 1 jj = 0 do j = 1 , N if ( j == COL ) cycle jj = jj + 1 cmplx_minor_matrix ( ii , jj ) = A ( i , j ) end do end do end function cmplx_minor_matrix function cmplx_trace ( A ) use intw_useful_constants , only : cmplx_0 implicit none complex ( kind = dp ), intent ( in ) :: A (:,:) complex ( kind = dp ) :: cmplx_trace integer :: N , M , i N = size ( A , dim = 1 ) M = size ( A , dim = 2 ) if ( N /= M ) stop \"ERROR: cmplx_trace: A must be a square matrix\" cmplx_trace = cmplx_0 do i = 1 , N cmplx_trace = cmplx_trace + A ( i , i ) enddo end function cmplx_trace end module intw_matrix_vector","tags":"","url":"sourcefile/matrix_vector.f90.html"},{"title":"intw_pseudo.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_pseudo !! display: none !! !! This module contains the pseudo-potentials in intwpseudo type, !! and the subroutine read_all_pseudo for reading them from the PP files. !! use kinds , only : dp implicit none save ! variables public :: nt_max , intwpseudo , upf ! subroutines public :: read_all_pseudo private integer , parameter :: nt_max = 99 ! Max number of different atomic types ! NOTE: Haritz 14/03/2024: ! In QE the maximum number of atomic types is 10, however, I didn't find any limit in SIESTA. ! In intw we just set a limit of 2 digits due to the PP filename format (see read_all_pseudo below). type intwpseudo character ( len = 2 ) :: psd = ' ' ! Element label character ( len = 6 ) :: rel = ' ' ! relativistic: {no|scalar|full} logical :: nlcc ! Non linear core corrections real ( kind = dp ) :: zp ! z valence logical :: has_so ! If .true. includes spin-orbit ! integer :: mesh ! Number of points in the radial mesh real ( kind = dp ), dimension (:), allocatable :: r ! r(mesh)  radial grid real ( kind = dp ), dimension (:), allocatable :: rab ! rab(mesh) dr(i)/di ! real ( kind = dp ) :: rcloc ! vloc = v_ae for r > rcloc integer :: lloc ! l of channel used to generate local potential real ( kind = dp ), dimension (:), allocatable :: vloc ! vloc(mesh) local atomic potential ! integer :: nbeta ! Number of beta projectors integer :: lmax ! Max l component in beta integer , dimension (:), allocatable :: kbeta ! kbeta(nbeta): number of grid points used for betas ! this defines the cutoff radius for each of them. integer :: kkbeta ! Max number of grid points used for betas integer , dimension (:), allocatable :: lll ! lll(nbeta) l of each projector real ( kind = dp ), dimension (:), allocatable :: jjj ! jjj(nbeta) j=l+1/2 or l-1/2 of beta real ( kind = dp ), dimension (:,:), allocatable :: beta ! beta(mesh,nbeta) projectors real ( kind = dp ), dimension (:,:), allocatable :: dion ! dion(nbeta,nbeta) atomic D_{mu,nu} end type intwpseudo type ( intwpseudo ), dimension (:), allocatable :: upf contains !--------------------------------------------------------------------- subroutine read_all_pseudo () ! use intw_utility , only : find_free_unit use intw_reading , only : ntyp use intw_input_parameters , only : outdir , prefix ! implicit none ! !     Local variables ! integer :: ios , nr , nt , nb , ir , nb1 integer :: io_unit , ierr character ( 256 ) :: file_pseudo character ( 256 ) :: dum character ( 1 ) :: tag1 character ( 2 ) :: tag2 allocate ( upf ( ntyp )) ! ierr = 0 do nt = 1 , ntyp if ( nt >= 1 . and . nt <= 9 ) then write ( tag1 , \"(i1)\" ) nt write ( * , \"(a)\" ) \"|     \" // tag1 // \"-KBPP.txt\" // \" ..                                 |\" file_pseudo = trim ( outdir ) // trim ( prefix ) // \".save.intw/\" // tag1 // \"-KBPP.txt\" else if ( nt >= 10 . and . nt <= nt_max ) then write ( tag2 , \"(i2)\" ) nt write ( * , \"(a)\" ) \"|     \" // tag2 // \"-KBPP.txt\" // \" ..                               |\" file_pseudo = trim ( outdir ) // trim ( prefix ) // \".save.intw/\" // tag2 // \"-KBPP.txt\" else stop \"ERROR: read_all_pseudo: ntyp > nt_max\" end if io_unit = find_free_unit () open ( unit = io_unit , file = file_pseudo , status = 'old' , form = 'formatted' , iostat = ios ) read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum read ( unit = io_unit , fmt =* , iostat = ierr ) upf ( nt )% psd write ( * , \"(a)\" ) \"|                 .. for the specie \" // trim ( upf ( nt )% psd ) // \"              |\" read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum read ( unit = io_unit , fmt =* , iostat = ierr ) upf ( nt )% rel read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum read ( unit = io_unit , fmt =* , iostat = ierr ) upf ( nt )% has_so read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum read ( unit = io_unit , fmt =* , iostat = ierr ) upf ( nt )% nlcc read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum read ( unit = io_unit , fmt =* , iostat = ierr ) upf ( nt )% zp read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum read ( unit = io_unit , fmt =* , iostat = ierr ) upf ( nt )% lloc read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum read ( unit = io_unit , fmt =* , iostat = ierr ) upf ( nt )% lmax read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum read ( unit = io_unit , fmt =* , iostat = ierr ) upf ( nt )% nbeta allocate ( upf ( nt )% kbeta ( upf ( nt )% nbeta )) read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum read ( unit = io_unit , fmt =* , iostat = ierr ) upf ( nt )% kbeta upf ( nt )% kkbeta = maxval ( upf ( nt )% kbeta (:) ) allocate ( upf ( nt )% lll ( upf ( nt )% nbeta )) read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum read ( unit = io_unit , fmt =* , iostat = ierr ) upf ( nt )% lll allocate ( upf ( nt )% jjj ( upf ( nt )% nbeta )) read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum if ( upf ( nt )% has_so ) then read ( unit = io_unit , fmt =* , iostat = ierr ) upf ( nt )% jjj else read ( unit = io_unit , fmt =* , iostat = ierr ) dum end if read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum read ( unit = io_unit , fmt =* , iostat = ierr ) upf ( nt )% mesh read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum read ( unit = io_unit , fmt =* , iostat = ierr ) upf ( nt )% rcloc allocate ( upf ( nt )% dion ( upf ( nt )% nbeta , upf ( nt )% nbeta )) read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum do nb = 1 , upf ( nt )% nbeta read ( unit = io_unit , fmt =* , iostat = ierr ) ( upf ( nt )% dion ( nb , nb1 ), nb1 = 1 , upf ( nt )% nbeta ) end do nr = upf ( nt )% mesh nb = upf ( nt )% nbeta allocate ( upf ( nt )% r ( nr ), upf ( nt )% rab ( nr ), upf ( nt )% vloc ( nr )) allocate ( upf ( nt )% beta ( nr , nb )) read ( unit = io_unit , fmt = \"(a)\" , iostat = ierr ) dum do ir = 1 , nr read ( unit = io_unit , fmt =* , iostat = ierr ) & upf ( nt )% r ( ir ), upf ( nt )% rab ( ir ), upf ( nt )% vloc ( ir ), ( upf ( nt )% beta ( ir , nb ), nb = 1 , upf ( nt )% nbeta ) end do if ( ierr /= 0 ) then write ( unit =* , fmt =* ) \"ERROR reading PP, \" , file_pseudo stop end if ! close ( io_unit ) end do !nt end subroutine read_all_pseudo end module intw_pseudo","tags":"","url":"sourcefile/intw_pseudo.f90.html"},{"title":"cfftnd.f90 – INTW","text":"Source Code ! ! This file is originally distributed as part of the exciting code: !   Copyright (C) 2005 J. K. Dewhurst !   Distributed under the terms of the GNU General Public License. !   See the LICENSE and COPYING files in the original exciting source for license details. !   For the original source visit: https://exciting-code.org/ ! module fftpack5 integer , parameter :: prec = kind ( 1.d0 ) end module subroutine cfftnd ( nd , n , sgn , c ) !* ! DESCRIPTION: !  In-place fast Fourier transform for complex arrays in $n_d$ dimensions. The !  forward transform is scaled by one over the size of the array. Uses a !  modified version of the FFTPACK5 library. ! ! INPUT/OUTPUT PARAMETERS: !   nd  : number of dimensions (in,integer) !   n   : mesh size (in,integer(nd)) !   sgn : FFT direction, -1: forward, 1: backward (in,integer) !   c   : array to transform (inout,complex(n(1)*n(2)*...*n(nd))) ! !  Copyright (C) 2005 J. K. Dewhurst !  Distributed under the terms of the GNU General Public License. !  See the file COPYING for license details. ! ! ``` ! Notes by ASIER ! sgn=+1 Means         Fourier Transform, i.e. Sum_{r=1,N} Exp[+I*k*r] u_r ! sgn=-1 Means Inverse Fourier Transform, i.e. Sum_{k=1,N} Exp[-I*k*r] u_k/N ! ``` ! use fftpack5 implicit none ! arguments integer , intent ( in ) :: nd integer , intent ( in ) :: n ( nd ) integer , intent ( in ) :: sgn complex ( prec ), intent ( inout ) :: c ( * ) ! local variables integer i , j , k , l , p , q , iw , iw1 , ni integer lensav , lenwrk ! allocatable arrays real ( prec ), allocatable :: wsave (:) real ( prec ), allocatable :: work (:) if ( nd . le . 0 ) then write ( * , * ) write ( * , '(\"Error(cfftnd): invalid number of dimensions : \",I8)' ) nd write ( * , * ) stop end if p = 1 lensav = 1 do i = 1 , nd if ( n ( i ). le . 0 ) then write ( * , * ) write ( * , '(\"Error(cfftnd): invalid n : \",I8)' ) n ( i ) write ( * , '(\" for dimension \",I4)' ) i write ( * , * ) stop end if p = p * n ( i ) lensav = max ( lensav , 2 * n ( i ) + int ( log ( real ( n ( i ), prec ))) + 4 ) end do lenwrk = 2 * p allocate ( wsave ( lensav )) allocate ( work ( lenwrk )) if ( sgn . gt . 0 ) then q = 1 do i = 1 , nd ni = n ( i ) if ( ni . gt . 1 ) then iw = ni + ni + 1 iw1 = iw + 1 p = p / ni call cfftmi ( ni , wsave , lensav ) j = 1 k = q * ni do l = 1 , p call cmfm1b ( q , 1 , ni , q , c ( j ), work , wsave , wsave ( iw ), wsave ( iw1 )) j = j + k end do q = k end if end do else q = 1 do i = 1 , nd ni = n ( i ) if ( ni . gt . 1 ) then iw = ni + ni + 1 iw1 = iw + 1 p = p / ni call cfftmi ( ni , wsave , lensav ) j = 1 k = q * ni do l = 1 , p call cmfm1f ( q , 1 , ni , q , c ( j ), work , wsave , wsave ( iw ), wsave ( iw1 )) j = j + k end do q = k end if end do end if deallocate ( wsave , work ) return end subroutine subroutine cfftmi ( n , wsave , lensav ) !******************************************************************************* ! !! CFFTMI: initialization for CFFTMB and CFFTMF. ! !  Discussion: ! !    CFFTMI initializes array WSAVE for use in its companion routines !    CFFTMB and CFFTMF.  CFFTMI must be called before the first call !    to CFFTMB or CFFTMF, and after whenever the value of integer N changes. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Modified: ! !    24 March 2005 ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! !    Input, integer N, the length of each sequence to be transformed. !    The transform is most efficient when N is a product of small primes. ! !    Input, integer LENSAV, the dimension of the WSAVE array.  LENSAV must be !    at least 2*N + INT(LOG(REAL(N))) + 4. ! !    Output, real WSAVE(LENSAV), containing the prime factors of N and !    also containing certain trigonometric values which will be used in !    routines CFFTMB or CFFTMF. ! ! use fftpack5 implicit none integer lensav integer iw1 integer n real ( prec ) wsave ( lensav ) if ( n == 1 ) then return end if iw1 = n + n + 1 call mcfti1 ( n , wsave , wsave ( iw1 ), wsave ( iw1 + 1 ) ) return end subroutine mcfti1 ( n , wa , fnf , fac ) !******************************************************************************* ! !! MCFTI1 is an FFTPACK5 auxiliary routine. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none real ( prec ) fac ( * ) real ( prec ) fnf integer ido integer ip integer iw integer k1 integer l1 integer l2 integer n integer nf real ( prec ) wa ( * ) ! !  Get the factorization of N. ! call factor ( n , nf , fac ) fnf = real ( nf , prec ) iw = 1 l1 = 1 ! !  Set up the trigonometric tables. ! do k1 = 1 , nf ip = int ( fac ( k1 ) ) l2 = l1 * ip ido = n / l2 call tables ( ido , ip , wa ( iw ) ) iw = iw + ( ip - 1 ) * ( ido + ido ) l1 = l2 end do return end subroutine factor ( n , nf , fac ) !******************************************************************************* ! !! FACTOR determines the factors of an integer. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Modified: ! !    28 March 2005 ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! !    Input, integer N, the number for which factorization and other information !    is needed. ! !    Output, integer NF, the number of factors. ! !    Output, real FAC(*), a list of factors of N. ! use fftpack5 implicit none real ( prec ) fac ( * ) integer j integer n integer nf integer nl integer nq integer nr integer ntry nl = n nf = 0 j = 0 do while ( 1 < nl ) j = j + 1 if ( j == 1 ) then ntry = 4 else if ( j == 2 ) then ntry = 2 else if ( j == 3 ) then ntry = 3 else if ( j == 4 ) then ntry = 5 else ntry = ntry + 2 end if do nq = nl / ntry nr = nl - ntry * nq if ( nr /= 0 ) then exit end if nf = nf + 1 fac ( nf ) = ntry nl = nq end do end do return end subroutine tables ( ido , ip , wa ) !******************************************************************************* ! !! TABLES computes trigonometric tables needed by the FFT routines. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none integer ido integer ip real ( prec ) arg1 real ( prec ) arg2 real ( prec ) arg3 real ( prec ) arg4 real ( prec ) argz integer i integer j real ( prec ) tpi real ( prec ) wa ( ido , ip - 1 , 2 ) tpi = 8.0E+00_prec * atan ( 1.0E+00_prec ) argz = tpi / real ( ip , prec ) arg1 = tpi / real ( ido * ip , prec ) do j = 2 , ip arg2 = real ( j - 1 , prec ) * arg1 do i = 1 , ido arg3 = real ( i - 1 , prec ) * arg2 wa ( i , j - 1 , 1 ) = cos ( arg3 ) wa ( i , j - 1 , 2 ) = sin ( arg3 ) end do if ( 5 < ip ) then arg4 = real ( j - 1 , prec ) * argz wa ( 1 , j - 1 , 1 ) = cos ( arg4 ) wa ( 1 , j - 1 , 2 ) = sin ( arg4 ) end if end do return end subroutine cmfm1b ( lot , jump , n , inc , c , ch , wa , fnf , fac ) !******************************************************************************* ! !! CMFM1B is an FFTPACK5 auxiliary routine. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none complex ( prec ) c ( * ) real ( prec ) ch ( * ) real ( prec ) fac ( * ) real ( prec ) fnf integer ido integer inc integer ip integer iw integer jump integer k1 integer l1 integer l2 integer lid integer lot integer n integer na integer nbr integer nf real ( prec ) wa ( * ) nf = int ( fnf ) na = 0 l1 = 1 iw = 1 do k1 = 1 , nf ip = int ( fac ( k1 ) ) l2 = ip * l1 ido = n / l2 lid = l1 * ido nbr = 1 + na + 2 * min ( ip - 2 , 4 ) if ( nbr == 1 ) then call cmf2kb ( lot , ido , l1 , na , c , jump , inc , ch , 1 , lot , wa ( iw ) ) else if ( nbr == 2 ) then call cmf2kb ( lot , ido , l1 , na , ch , 1 , lot , c , jump , inc , wa ( iw ) ) else if ( nbr == 3 ) then call cmf3kb ( lot , ido , l1 , na , c , jump , inc , ch , 1 , lot , wa ( iw ) ) else if ( nbr == 4 ) then call cmf3kb ( lot , ido , l1 , na , ch , 1 , lot , c , jump , inc , wa ( iw ) ) else if ( nbr == 5 ) then call cmf4kb ( lot , ido , l1 , na , c , jump , inc , ch , 1 , lot , wa ( iw ) ) else if ( nbr == 6 ) then call cmf4kb ( lot , ido , l1 , na , ch , 1 , lot , c , jump , inc , wa ( iw ) ) else if ( nbr == 7 ) then call cmf5kb ( lot , ido , l1 , na , c , jump , inc , ch , 1 , lot , wa ( iw ) ) else if ( nbr == 8 ) then call cmf5kb ( lot , ido , l1 , na , ch , 1 , lot , c , jump , inc , wa ( iw ) ) else if ( nbr == 9 ) then call cmfgkb ( lot , ido , ip , l1 , lid , na , c , c , jump , inc , ch , ch , & 1 , lot , wa ( iw ) ) else if ( nbr == 10 ) then call cmfgkb ( lot , ido , ip , l1 , lid , na , ch , ch , 1 , lot , c , c , & jump , inc , wa ( iw ) ) end if l1 = l2 iw = iw + ( ip - 1 ) * ( ido + ido ) if ( ip <= 5 ) then na = 1 - na end if end do return end subroutine cmfm1f ( lot , jump , n , inc , c , ch , wa , fnf , fac ) !******************************************************************************* ! !! CMFM1F is an FFTPACK5 auxiliary routine. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none complex ( prec ) c ( * ) real ( prec ) ch ( * ) real ( prec ) fac ( * ) real ( prec ) fnf integer ido integer inc integer ip integer iw integer jump integer k1 integer l1 integer l2 integer lid integer lot integer n integer na integer nbr integer nf real ( prec ) wa ( * ) nf = int ( fnf ) na = 0 l1 = 1 iw = 1 do k1 = 1 , nf ip = int ( fac ( k1 ) ) l2 = ip * l1 ido = n / l2 lid = l1 * ido nbr = 1 + na + 2 * min ( ip - 2 , 4 ) if ( nbr == 1 ) then call cmf2kf ( lot , ido , l1 , na , c , jump , inc , ch , 1 , lot , wa ( iw ) ) else if ( nbr == 2 ) then call cmf2kf ( lot , ido , l1 , na , ch , 1 , lot , c , jump , inc , wa ( iw ) ) else if ( nbr == 3 ) then call cmf3kf ( lot , ido , l1 , na , c , jump , inc , ch , 1 , lot , wa ( iw ) ) else if ( nbr == 4 ) then call cmf3kf ( lot , ido , l1 , na , ch , 1 , lot , c , jump , inc , wa ( iw ) ) else if ( nbr == 5 ) then call cmf4kf ( lot , ido , l1 , na , c , jump , inc , ch , 1 , lot , wa ( iw ) ) else if ( nbr == 6 ) then call cmf4kf ( lot , ido , l1 , na , ch , 1 , lot , c , jump , inc , wa ( iw ) ) else if ( nbr == 7 ) then call cmf5kf ( lot , ido , l1 , na , c , jump , inc , ch , 1 , lot , wa ( iw ) ) else if ( nbr == 8 ) then call cmf5kf ( lot , ido , l1 , na , ch , 1 , lot , c , jump , inc , wa ( iw ) ) else if ( nbr == 9 ) then call cmfgkf ( lot , ido , ip , l1 , lid , na , c , c , jump , inc , ch , ch , & 1 , lot , wa ( iw ) ) else if ( nbr == 10 ) then call cmfgkf ( lot , ido , ip , l1 , lid , na , ch , ch , 1 , lot , c , c , & jump , inc , wa ( iw ) ) end if l1 = l2 iw = iw + ( ip - 1 ) * ( ido + ido ) if ( ip <= 5 ) then na = 1 - na end if end do return end subroutine cmf2kb ( lot , ido , l1 , na , cc , im1 , in1 , ch , im2 , in2 , wa ) !******************************************************************************* ! !! CMF2KB is an FFTPACK5 auxiliary routine. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none integer ido integer in1 integer in2 integer l1 real ( prec ) cc ( 2 , in1 , l1 , ido , 2 ) real ( prec ) ch ( 2 , in2 , l1 , 2 , ido ) real ( prec ) chold1 real ( prec ) chold2 integer i integer im1 integer im2 integer k integer lot integer m1 integer m1d integer m2 integer m2s integer na real ( prec ) ti2 real ( prec ) tr2 real ( prec ) wa ( ido , 1 , 2 ) m1d = ( lot - 1 ) * im1 + 1 m2s = 1 - im2 if ( 1 < ido . or . na == 1 ) then do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch ( 1 , m2 , k , 1 , 1 ) = cc ( 1 , m1 , k , 1 , 1 ) + cc ( 1 , m1 , k , 1 , 2 ) ch ( 1 , m2 , k , 2 , 1 ) = cc ( 1 , m1 , k , 1 , 1 ) - cc ( 1 , m1 , k , 1 , 2 ) ch ( 2 , m2 , k , 1 , 1 ) = cc ( 2 , m1 , k , 1 , 1 ) + cc ( 2 , m1 , k , 1 , 2 ) ch ( 2 , m2 , k , 2 , 1 ) = cc ( 2 , m1 , k , 1 , 1 ) - cc ( 2 , m1 , k , 1 , 2 ) end do end do do i = 2 , ido do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch ( 1 , m2 , k , 1 , i ) = cc ( 1 , m1 , k , i , 1 ) + cc ( 1 , m1 , k , i , 2 ) tr2 = cc ( 1 , m1 , k , i , 1 ) - cc ( 1 , m1 , k , i , 2 ) ch ( 2 , m2 , k , 1 , i ) = cc ( 2 , m1 , k , i , 1 ) + cc ( 2 , m1 , k , i , 2 ) ti2 = cc ( 2 , m1 , k , i , 1 ) - cc ( 2 , m1 , k , i , 2 ) ch ( 2 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * ti2 + wa ( i , 1 , 2 ) * tr2 ch ( 1 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * tr2 - wa ( i , 1 , 2 ) * ti2 end do end do end do else do k = 1 , l1 do m1 = 1 , m1d , im1 chold1 = cc ( 1 , m1 , k , 1 , 1 ) + cc ( 1 , m1 , k , 1 , 2 ) cc ( 1 , m1 , k , 1 , 2 ) = cc ( 1 , m1 , k , 1 , 1 ) - cc ( 1 , m1 , k , 1 , 2 ) cc ( 1 , m1 , k , 1 , 1 ) = chold1 chold2 = cc ( 2 , m1 , k , 1 , 1 ) + cc ( 2 , m1 , k , 1 , 2 ) cc ( 2 , m1 , k , 1 , 2 ) = cc ( 2 , m1 , k , 1 , 1 ) - cc ( 2 , m1 , k , 1 , 2 ) cc ( 2 , m1 , k , 1 , 1 ) = chold2 end do end do end if return end subroutine cmf2kf ( lot , ido , l1 , na , cc , im1 , in1 , ch , im2 , in2 , wa ) !******************************************************************************* ! !! CMF2KF is an FFTPACK5 auxiliary routine. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none integer ido integer in1 integer in2 integer l1 real ( prec ) cc ( 2 , in1 , l1 , ido , 2 ) real ( prec ) ch ( 2 , in2 , l1 , 2 , ido ) real ( prec ) chold1 real ( prec ) chold2 integer i integer im1 integer im2 integer k integer lot integer m1 integer m1d integer m2 integer m2s integer na real ( prec ) sn real ( prec ) ti2 real ( prec ) tr2 real ( prec ) wa ( ido , 1 , 2 ) m1d = ( lot - 1 ) * im1 + 1 m2s = 1 - im2 if ( 1 < ido ) then do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch ( 1 , m2 , k , 1 , 1 ) = cc ( 1 , m1 , k , 1 , 1 ) + cc ( 1 , m1 , k , 1 , 2 ) ch ( 1 , m2 , k , 2 , 1 ) = cc ( 1 , m1 , k , 1 , 1 ) - cc ( 1 , m1 , k , 1 , 2 ) ch ( 2 , m2 , k , 1 , 1 ) = cc ( 2 , m1 , k , 1 , 1 ) + cc ( 2 , m1 , k , 1 , 2 ) ch ( 2 , m2 , k , 2 , 1 ) = cc ( 2 , m1 , k , 1 , 1 ) - cc ( 2 , m1 , k , 1 , 2 ) end do end do do i = 2 , ido do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch ( 1 , m2 , k , 1 , i ) = cc ( 1 , m1 , k , i , 1 ) + cc ( 1 , m1 , k , i , 2 ) tr2 = cc ( 1 , m1 , k , i , 1 ) - cc ( 1 , m1 , k , i , 2 ) ch ( 2 , m2 , k , 1 , i ) = cc ( 2 , m1 , k , i , 1 ) + cc ( 2 , m1 , k , i , 2 ) ti2 = cc ( 2 , m1 , k , i , 1 ) - cc ( 2 , m1 , k , i , 2 ) ch ( 2 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * ti2 - wa ( i , 1 , 2 ) * tr2 ch ( 1 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * tr2 + wa ( i , 1 , 2 ) * ti2 end do end do end do else if ( na == 1 ) then sn = 1.0E+00_prec / real ( 2 * l1 , prec ) do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch ( 1 , m2 , k , 1 , 1 ) = sn * ( cc ( 1 , m1 , k , 1 , 1 ) + cc ( 1 , m1 , k , 1 , 2 ) ) ch ( 1 , m2 , k , 2 , 1 ) = sn * ( cc ( 1 , m1 , k , 1 , 1 ) - cc ( 1 , m1 , k , 1 , 2 ) ) ch ( 2 , m2 , k , 1 , 1 ) = sn * ( cc ( 2 , m1 , k , 1 , 1 ) + cc ( 2 , m1 , k , 1 , 2 ) ) ch ( 2 , m2 , k , 2 , 1 ) = sn * ( cc ( 2 , m1 , k , 1 , 1 ) - cc ( 2 , m1 , k , 1 , 2 ) ) end do end do else sn = 1.0E+00_prec / real ( 2 * l1 , prec ) do k = 1 , l1 do m1 = 1 , m1d , im1 chold1 = sn * ( cc ( 1 , m1 , k , 1 , 1 ) + cc ( 1 , m1 , k , 1 , 2 ) ) cc ( 1 , m1 , k , 1 , 2 ) = sn * ( cc ( 1 , m1 , k , 1 , 1 ) - cc ( 1 , m1 , k , 1 , 2 ) ) cc ( 1 , m1 , k , 1 , 1 ) = chold1 chold2 = sn * ( cc ( 2 , m1 , k , 1 , 1 ) + cc ( 2 , m1 , k , 1 , 2 ) ) cc ( 2 , m1 , k , 1 , 2 ) = sn * ( cc ( 2 , m1 , k , 1 , 1 ) - cc ( 2 , m1 , k , 1 , 2 ) ) cc ( 2 , m1 , k , 1 , 1 ) = chold2 end do end do end if return end subroutine cmf3kb ( lot , ido , l1 , na , cc , im1 , in1 , ch , im2 , in2 , wa ) !******************************************************************************* ! !! CMF3KB is an FFTPACK5 auxiliary routine. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none integer ido integer in1 integer in2 integer l1 real ( prec ) cc ( 2 , in1 , l1 , ido , 3 ) real ( prec ) ch ( 2 , in2 , l1 , 3 , ido ) real ( prec ) ci2 real ( prec ) ci3 real ( prec ) cr2 real ( prec ) cr3 real ( prec ) di2 real ( prec ) di3 real ( prec ) dr2 real ( prec ) dr3 integer i integer im1 integer im2 integer k integer lot integer m1 integer m1d integer m2 integer m2s integer na real ( prec ), parameter :: taui = 0.866025403784439E+00_prec real ( prec ), parameter :: taur = - 0.5E+00_prec real ( prec ) ti2 real ( prec ) tr2 real ( prec ) wa ( ido , 2 , 2 ) m1d = ( lot - 1 ) * im1 + 1 m2s = 1 - im2 if ( 1 < ido . or . na == 1 ) then do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 tr2 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 3 ) cr2 = cc ( 1 , m1 , k , 1 , 1 ) + taur * tr2 ch ( 1 , m2 , k , 1 , 1 ) = cc ( 1 , m1 , k , 1 , 1 ) + tr2 ti2 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 3 ) ci2 = cc ( 2 , m1 , k , 1 , 1 ) + taur * ti2 ch ( 2 , m2 , k , 1 , 1 ) = cc ( 2 , m1 , k , 1 , 1 ) + ti2 cr3 = taui * ( cc ( 1 , m1 , k , 1 , 2 ) - cc ( 1 , m1 , k , 1 , 3 )) ci3 = taui * ( cc ( 2 , m1 , k , 1 , 2 ) - cc ( 2 , m1 , k , 1 , 3 )) ch ( 1 , m2 , k , 2 , 1 ) = cr2 - ci3 ch ( 1 , m2 , k , 3 , 1 ) = cr2 + ci3 ch ( 2 , m2 , k , 2 , 1 ) = ci2 + cr3 ch ( 2 , m2 , k , 3 , 1 ) = ci2 - cr3 end do end do do i = 2 , ido do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 tr2 = cc ( 1 , m1 , k , i , 2 ) + cc ( 1 , m1 , k , i , 3 ) cr2 = cc ( 1 , m1 , k , i , 1 ) + taur * tr2 ch ( 1 , m2 , k , 1 , i ) = cc ( 1 , m1 , k , i , 1 ) + tr2 ti2 = cc ( 2 , m1 , k , i , 2 ) + cc ( 2 , m1 , k , i , 3 ) ci2 = cc ( 2 , m1 , k , i , 1 ) + taur * ti2 ch ( 2 , m2 , k , 1 , i ) = cc ( 2 , m1 , k , i , 1 ) + ti2 cr3 = taui * ( cc ( 1 , m1 , k , i , 2 ) - cc ( 1 , m1 , k , i , 3 )) ci3 = taui * ( cc ( 2 , m1 , k , i , 2 ) - cc ( 2 , m1 , k , i , 3 )) dr2 = cr2 - ci3 dr3 = cr2 + ci3 di2 = ci2 + cr3 di3 = ci2 - cr3 ch ( 2 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * di2 + wa ( i , 1 , 2 ) * dr2 ch ( 1 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * dr2 - wa ( i , 1 , 2 ) * di2 ch ( 2 , m2 , k , 3 , i ) = wa ( i , 2 , 1 ) * di3 + wa ( i , 2 , 2 ) * dr3 ch ( 1 , m2 , k , 3 , i ) = wa ( i , 2 , 1 ) * dr3 - wa ( i , 2 , 2 ) * di3 end do end do end do else do k = 1 , l1 do m1 = 1 , m1d , im1 tr2 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 3 ) cr2 = cc ( 1 , m1 , k , 1 , 1 ) + taur * tr2 cc ( 1 , m1 , k , 1 , 1 ) = cc ( 1 , m1 , k , 1 , 1 ) + tr2 ti2 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 3 ) ci2 = cc ( 2 , m1 , k , 1 , 1 ) + taur * ti2 cc ( 2 , m1 , k , 1 , 1 ) = cc ( 2 , m1 , k , 1 , 1 ) + ti2 cr3 = taui * ( cc ( 1 , m1 , k , 1 , 2 ) - cc ( 1 , m1 , k , 1 , 3 )) ci3 = taui * ( cc ( 2 , m1 , k , 1 , 2 ) - cc ( 2 , m1 , k , 1 , 3 )) cc ( 1 , m1 , k , 1 , 2 ) = cr2 - ci3 cc ( 1 , m1 , k , 1 , 3 ) = cr2 + ci3 cc ( 2 , m1 , k , 1 , 2 ) = ci2 + cr3 cc ( 2 , m1 , k , 1 , 3 ) = ci2 - cr3 end do end do end if return end subroutine cmf3kf ( lot , ido , l1 , na , cc , im1 , in1 , ch , im2 , in2 , wa ) !******************************************************************************* ! !! CMF3KF is an FFTPACK5 auxiliary routine. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none integer ido integer in1 integer in2 integer l1 real ( prec ) cc ( 2 , in1 , l1 , ido , 3 ) real ( prec ) ch ( 2 , in2 , l1 , 3 , ido ) real ( prec ) ci2 real ( prec ) ci3 real ( prec ) cr2 real ( prec ) cr3 real ( prec ) di2 real ( prec ) di3 real ( prec ) dr2 real ( prec ) dr3 integer i integer im1 integer im2 integer k integer lot integer m1 integer m1d integer m2 integer m2s integer na real ( prec ) sn real ( prec ), parameter :: taui = - 0.866025403784439E+00_prec real ( prec ), parameter :: taur = - 0.5E+00_prec real ( prec ) ti2 real ( prec ) tr2 real ( prec ) wa ( ido , 2 , 2 ) m1d = ( lot - 1 ) * im1 + 1 m2s = 1 - im2 if ( 1 < ido ) then do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 tr2 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 3 ) cr2 = cc ( 1 , m1 , k , 1 , 1 ) + taur * tr2 ch ( 1 , m2 , k , 1 , 1 ) = cc ( 1 , m1 , k , 1 , 1 ) + tr2 ti2 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 3 ) ci2 = cc ( 2 , m1 , k , 1 , 1 ) + taur * ti2 ch ( 2 , m2 , k , 1 , 1 ) = cc ( 2 , m1 , k , 1 , 1 ) + ti2 cr3 = taui * ( cc ( 1 , m1 , k , 1 , 2 ) - cc ( 1 , m1 , k , 1 , 3 )) ci3 = taui * ( cc ( 2 , m1 , k , 1 , 2 ) - cc ( 2 , m1 , k , 1 , 3 )) ch ( 1 , m2 , k , 2 , 1 ) = cr2 - ci3 ch ( 1 , m2 , k , 3 , 1 ) = cr2 + ci3 ch ( 2 , m2 , k , 2 , 1 ) = ci2 + cr3 ch ( 2 , m2 , k , 3 , 1 ) = ci2 - cr3 end do end do do i = 2 , ido do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 tr2 = cc ( 1 , m1 , k , i , 2 ) + cc ( 1 , m1 , k , i , 3 ) cr2 = cc ( 1 , m1 , k , i , 1 ) + taur * tr2 ch ( 1 , m2 , k , 1 , i ) = cc ( 1 , m1 , k , i , 1 ) + tr2 ti2 = cc ( 2 , m1 , k , i , 2 ) + cc ( 2 , m1 , k , i , 3 ) ci2 = cc ( 2 , m1 , k , i , 1 ) + taur * ti2 ch ( 2 , m2 , k , 1 , i ) = cc ( 2 , m1 , k , i , 1 ) + ti2 cr3 = taui * ( cc ( 1 , m1 , k , i , 2 ) - cc ( 1 , m1 , k , i , 3 )) ci3 = taui * ( cc ( 2 , m1 , k , i , 2 ) - cc ( 2 , m1 , k , i , 3 )) dr2 = cr2 - ci3 dr3 = cr2 + ci3 di2 = ci2 + cr3 di3 = ci2 - cr3 ch ( 2 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * di2 - wa ( i , 1 , 2 ) * dr2 ch ( 1 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * dr2 + wa ( i , 1 , 2 ) * di2 ch ( 2 , m2 , k , 3 , i ) = wa ( i , 2 , 1 ) * di3 - wa ( i , 2 , 2 ) * dr3 ch ( 1 , m2 , k , 3 , i ) = wa ( i , 2 , 1 ) * dr3 + wa ( i , 2 , 2 ) * di3 end do end do end do else if ( na == 1 ) then sn = 1.0E+00_prec / real ( 3 * l1 , prec ) do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 tr2 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 3 ) cr2 = cc ( 1 , m1 , k , 1 , 1 ) + taur * tr2 ch ( 1 , m2 , k , 1 , 1 ) = sn * ( cc ( 1 , m1 , k , 1 , 1 ) + tr2 ) ti2 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 3 ) ci2 = cc ( 2 , m1 , k , 1 , 1 ) + taur * ti2 ch ( 2 , m2 , k , 1 , 1 ) = sn * ( cc ( 2 , m1 , k , 1 , 1 ) + ti2 ) cr3 = taui * ( cc ( 1 , m1 , k , 1 , 2 ) - cc ( 1 , m1 , k , 1 , 3 )) ci3 = taui * ( cc ( 2 , m1 , k , 1 , 2 ) - cc ( 2 , m1 , k , 1 , 3 )) ch ( 1 , m2 , k , 2 , 1 ) = sn * ( cr2 - ci3 ) ch ( 1 , m2 , k , 3 , 1 ) = sn * ( cr2 + ci3 ) ch ( 2 , m2 , k , 2 , 1 ) = sn * ( ci2 + cr3 ) ch ( 2 , m2 , k , 3 , 1 ) = sn * ( ci2 - cr3 ) end do end do else sn = 1.0E+00_prec / real ( 3 * l1 , prec ) do k = 1 , l1 do m1 = 1 , m1d , im1 tr2 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 3 ) cr2 = cc ( 1 , m1 , k , 1 , 1 ) + taur * tr2 cc ( 1 , m1 , k , 1 , 1 ) = sn * ( cc ( 1 , m1 , k , 1 , 1 ) + tr2 ) ti2 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 3 ) ci2 = cc ( 2 , m1 , k , 1 , 1 ) + taur * ti2 cc ( 2 , m1 , k , 1 , 1 ) = sn * ( cc ( 2 , m1 , k , 1 , 1 ) + ti2 ) cr3 = taui * ( cc ( 1 , m1 , k , 1 , 2 ) - cc ( 1 , m1 , k , 1 , 3 )) ci3 = taui * ( cc ( 2 , m1 , k , 1 , 2 ) - cc ( 2 , m1 , k , 1 , 3 )) cc ( 1 , m1 , k , 1 , 2 ) = sn * ( cr2 - ci3 ) cc ( 1 , m1 , k , 1 , 3 ) = sn * ( cr2 + ci3 ) cc ( 2 , m1 , k , 1 , 2 ) = sn * ( ci2 + cr3 ) cc ( 2 , m1 , k , 1 , 3 ) = sn * ( ci2 - cr3 ) end do end do end if return end subroutine cmf4kb ( lot , ido , l1 , na , cc , im1 , in1 , ch , im2 , in2 , wa ) !******************************************************************************* ! !! CMF4KB is an FFTPACK5 auxiliary routine. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none integer ido integer in1 integer in2 integer l1 real ( prec ) cc ( 2 , in1 , l1 , ido , 4 ) real ( prec ) ch ( 2 , in2 , l1 , 4 , ido ) real ( prec ) ci2 real ( prec ) ci3 real ( prec ) ci4 real ( prec ) cr2 real ( prec ) cr3 real ( prec ) cr4 integer i integer im1 integer im2 integer k integer lot integer m1 integer m1d integer m2 integer m2s integer na real ( prec ) ti1 real ( prec ) ti2 real ( prec ) ti3 real ( prec ) ti4 real ( prec ) tr1 real ( prec ) tr2 real ( prec ) tr3 real ( prec ) tr4 real ( prec ) wa ( ido , 3 , 2 ) m1d = ( lot - 1 ) * im1 + 1 m2s = 1 - im2 if ( 1 < ido . or . na == 1 ) then do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ti1 = cc ( 2 , m1 , k , 1 , 1 ) - cc ( 2 , m1 , k , 1 , 3 ) ti2 = cc ( 2 , m1 , k , 1 , 1 ) + cc ( 2 , m1 , k , 1 , 3 ) tr4 = cc ( 2 , m1 , k , 1 , 4 ) - cc ( 2 , m1 , k , 1 , 2 ) ti3 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 4 ) tr1 = cc ( 1 , m1 , k , 1 , 1 ) - cc ( 1 , m1 , k , 1 , 3 ) tr2 = cc ( 1 , m1 , k , 1 , 1 ) + cc ( 1 , m1 , k , 1 , 3 ) ti4 = cc ( 1 , m1 , k , 1 , 2 ) - cc ( 1 , m1 , k , 1 , 4 ) tr3 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 4 ) ch ( 1 , m2 , k , 1 , 1 ) = tr2 + tr3 ch ( 1 , m2 , k , 3 , 1 ) = tr2 - tr3 ch ( 2 , m2 , k , 1 , 1 ) = ti2 + ti3 ch ( 2 , m2 , k , 3 , 1 ) = ti2 - ti3 ch ( 1 , m2 , k , 2 , 1 ) = tr1 + tr4 ch ( 1 , m2 , k , 4 , 1 ) = tr1 - tr4 ch ( 2 , m2 , k , 2 , 1 ) = ti1 + ti4 ch ( 2 , m2 , k , 4 , 1 ) = ti1 - ti4 end do end do do i = 2 , ido do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ti1 = cc ( 2 , m1 , k , i , 1 ) - cc ( 2 , m1 , k , i , 3 ) ti2 = cc ( 2 , m1 , k , i , 1 ) + cc ( 2 , m1 , k , i , 3 ) ti3 = cc ( 2 , m1 , k , i , 2 ) + cc ( 2 , m1 , k , i , 4 ) tr4 = cc ( 2 , m1 , k , i , 4 ) - cc ( 2 , m1 , k , i , 2 ) tr1 = cc ( 1 , m1 , k , i , 1 ) - cc ( 1 , m1 , k , i , 3 ) tr2 = cc ( 1 , m1 , k , i , 1 ) + cc ( 1 , m1 , k , i , 3 ) ti4 = cc ( 1 , m1 , k , i , 2 ) - cc ( 1 , m1 , k , i , 4 ) tr3 = cc ( 1 , m1 , k , i , 2 ) + cc ( 1 , m1 , k , i , 4 ) ch ( 1 , m2 , k , 1 , i ) = tr2 + tr3 cr3 = tr2 - tr3 ch ( 2 , m2 , k , 1 , i ) = ti2 + ti3 ci3 = ti2 - ti3 cr2 = tr1 + tr4 cr4 = tr1 - tr4 ci2 = ti1 + ti4 ci4 = ti1 - ti4 ch ( 1 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * cr2 - wa ( i , 1 , 2 ) * ci2 ch ( 2 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * ci2 + wa ( i , 1 , 2 ) * cr2 ch ( 1 , m2 , k , 3 , i ) = wa ( i , 2 , 1 ) * cr3 - wa ( i , 2 , 2 ) * ci3 ch ( 2 , m2 , k , 3 , i ) = wa ( i , 2 , 1 ) * ci3 + wa ( i , 2 , 2 ) * cr3 ch ( 1 , m2 , k , 4 , i ) = wa ( i , 3 , 1 ) * cr4 - wa ( i , 3 , 2 ) * ci4 ch ( 2 , m2 , k , 4 , i ) = wa ( i , 3 , 1 ) * ci4 + wa ( i , 3 , 2 ) * cr4 end do end do end do else do k = 1 , l1 do m1 = 1 , m1d , im1 ti1 = cc ( 2 , m1 , k , 1 , 1 ) - cc ( 2 , m1 , k , 1 , 3 ) ti2 = cc ( 2 , m1 , k , 1 , 1 ) + cc ( 2 , m1 , k , 1 , 3 ) tr4 = cc ( 2 , m1 , k , 1 , 4 ) - cc ( 2 , m1 , k , 1 , 2 ) ti3 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 4 ) tr1 = cc ( 1 , m1 , k , 1 , 1 ) - cc ( 1 , m1 , k , 1 , 3 ) tr2 = cc ( 1 , m1 , k , 1 , 1 ) + cc ( 1 , m1 , k , 1 , 3 ) ti4 = cc ( 1 , m1 , k , 1 , 2 ) - cc ( 1 , m1 , k , 1 , 4 ) tr3 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 4 ) cc ( 1 , m1 , k , 1 , 1 ) = tr2 + tr3 cc ( 1 , m1 , k , 1 , 3 ) = tr2 - tr3 cc ( 2 , m1 , k , 1 , 1 ) = ti2 + ti3 cc ( 2 , m1 , k , 1 , 3 ) = ti2 - ti3 cc ( 1 , m1 , k , 1 , 2 ) = tr1 + tr4 cc ( 1 , m1 , k , 1 , 4 ) = tr1 - tr4 cc ( 2 , m1 , k , 1 , 2 ) = ti1 + ti4 cc ( 2 , m1 , k , 1 , 4 ) = ti1 - ti4 end do end do end if return end subroutine cmf4kf ( lot , ido , l1 , na , cc , im1 , in1 , ch , im2 , in2 , wa ) !******************************************************************************* ! !! CMF4KF is an FFTPACK5 auxiliary routine. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none integer ido integer in1 integer in2 integer l1 real ( prec ) cc ( 2 , in1 , l1 , ido , 4 ) real ( prec ) ch ( 2 , in2 , l1 , 4 , ido ) real ( prec ) ci2 real ( prec ) ci3 real ( prec ) ci4 real ( prec ) cr2 real ( prec ) cr3 real ( prec ) cr4 integer i integer im1 integer im2 integer k integer lot integer m1 integer m1d integer m2 integer m2s integer na real ( prec ) sn real ( prec ) ti1 real ( prec ) ti2 real ( prec ) ti3 real ( prec ) ti4 real ( prec ) tr1 real ( prec ) tr2 real ( prec ) tr3 real ( prec ) tr4 real ( prec ) wa ( ido , 3 , 2 ) m1d = ( lot - 1 ) * im1 + 1 m2s = 1 - im2 if ( 1 < ido ) then do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ti1 = cc ( 2 , m1 , k , 1 , 1 ) - cc ( 2 , m1 , k , 1 , 3 ) ti2 = cc ( 2 , m1 , k , 1 , 1 ) + cc ( 2 , m1 , k , 1 , 3 ) tr4 = cc ( 2 , m1 , k , 1 , 2 ) - cc ( 2 , m1 , k , 1 , 4 ) ti3 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 4 ) tr1 = cc ( 1 , m1 , k , 1 , 1 ) - cc ( 1 , m1 , k , 1 , 3 ) tr2 = cc ( 1 , m1 , k , 1 , 1 ) + cc ( 1 , m1 , k , 1 , 3 ) ti4 = cc ( 1 , m1 , k , 1 , 4 ) - cc ( 1 , m1 , k , 1 , 2 ) tr3 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 4 ) ch ( 1 , m2 , k , 1 , 1 ) = tr2 + tr3 ch ( 1 , m2 , k , 3 , 1 ) = tr2 - tr3 ch ( 2 , m2 , k , 1 , 1 ) = ti2 + ti3 ch ( 2 , m2 , k , 3 , 1 ) = ti2 - ti3 ch ( 1 , m2 , k , 2 , 1 ) = tr1 + tr4 ch ( 1 , m2 , k , 4 , 1 ) = tr1 - tr4 ch ( 2 , m2 , k , 2 , 1 ) = ti1 + ti4 ch ( 2 , m2 , k , 4 , 1 ) = ti1 - ti4 end do end do do i = 2 , ido do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ti1 = cc ( 2 , m1 , k , i , 1 ) - cc ( 2 , m1 , k , i , 3 ) ti2 = cc ( 2 , m1 , k , i , 1 ) + cc ( 2 , m1 , k , i , 3 ) ti3 = cc ( 2 , m1 , k , i , 2 ) + cc ( 2 , m1 , k , i , 4 ) tr4 = cc ( 2 , m1 , k , i , 2 ) - cc ( 2 , m1 , k , i , 4 ) tr1 = cc ( 1 , m1 , k , i , 1 ) - cc ( 1 , m1 , k , i , 3 ) tr2 = cc ( 1 , m1 , k , i , 1 ) + cc ( 1 , m1 , k , i , 3 ) ti4 = cc ( 1 , m1 , k , i , 4 ) - cc ( 1 , m1 , k , i , 2 ) tr3 = cc ( 1 , m1 , k , i , 2 ) + cc ( 1 , m1 , k , i , 4 ) ch ( 1 , m2 , k , 1 , i ) = tr2 + tr3 cr3 = tr2 - tr3 ch ( 2 , m2 , k , 1 , i ) = ti2 + ti3 ci3 = ti2 - ti3 cr2 = tr1 + tr4 cr4 = tr1 - tr4 ci2 = ti1 + ti4 ci4 = ti1 - ti4 ch ( 1 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * cr2 + wa ( i , 1 , 2 ) * ci2 ch ( 2 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * ci2 - wa ( i , 1 , 2 ) * cr2 ch ( 1 , m2 , k , 3 , i ) = wa ( i , 2 , 1 ) * cr3 + wa ( i , 2 , 2 ) * ci3 ch ( 2 , m2 , k , 3 , i ) = wa ( i , 2 , 1 ) * ci3 - wa ( i , 2 , 2 ) * cr3 ch ( 1 , m2 , k , 4 , i ) = wa ( i , 3 , 1 ) * cr4 + wa ( i , 3 , 2 ) * ci4 ch ( 2 , m2 , k , 4 , i ) = wa ( i , 3 , 1 ) * ci4 - wa ( i , 3 , 2 ) * cr4 end do end do end do else if ( na == 1 ) then sn = 1.0E+00_prec / real ( 4 * l1 , prec ) do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ti1 = cc ( 2 , m1 , k , 1 , 1 ) - cc ( 2 , m1 , k , 1 , 3 ) ti2 = cc ( 2 , m1 , k , 1 , 1 ) + cc ( 2 , m1 , k , 1 , 3 ) tr4 = cc ( 2 , m1 , k , 1 , 2 ) - cc ( 2 , m1 , k , 1 , 4 ) ti3 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 4 ) tr1 = cc ( 1 , m1 , k , 1 , 1 ) - cc ( 1 , m1 , k , 1 , 3 ) tr2 = cc ( 1 , m1 , k , 1 , 1 ) + cc ( 1 , m1 , k , 1 , 3 ) ti4 = cc ( 1 , m1 , k , 1 , 4 ) - cc ( 1 , m1 , k , 1 , 2 ) tr3 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 4 ) ch ( 1 , m2 , k , 1 , 1 ) = sn * ( tr2 + tr3 ) ch ( 1 , m2 , k , 3 , 1 ) = sn * ( tr2 - tr3 ) ch ( 2 , m2 , k , 1 , 1 ) = sn * ( ti2 + ti3 ) ch ( 2 , m2 , k , 3 , 1 ) = sn * ( ti2 - ti3 ) ch ( 1 , m2 , k , 2 , 1 ) = sn * ( tr1 + tr4 ) ch ( 1 , m2 , k , 4 , 1 ) = sn * ( tr1 - tr4 ) ch ( 2 , m2 , k , 2 , 1 ) = sn * ( ti1 + ti4 ) ch ( 2 , m2 , k , 4 , 1 ) = sn * ( ti1 - ti4 ) end do end do else sn = 1.0E+00_prec / real ( 4 * l1 , prec ) do k = 1 , l1 do m1 = 1 , m1d , im1 ti1 = cc ( 2 , m1 , k , 1 , 1 ) - cc ( 2 , m1 , k , 1 , 3 ) ti2 = cc ( 2 , m1 , k , 1 , 1 ) + cc ( 2 , m1 , k , 1 , 3 ) tr4 = cc ( 2 , m1 , k , 1 , 2 ) - cc ( 2 , m1 , k , 1 , 4 ) ti3 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 4 ) tr1 = cc ( 1 , m1 , k , 1 , 1 ) - cc ( 1 , m1 , k , 1 , 3 ) tr2 = cc ( 1 , m1 , k , 1 , 1 ) + cc ( 1 , m1 , k , 1 , 3 ) ti4 = cc ( 1 , m1 , k , 1 , 4 ) - cc ( 1 , m1 , k , 1 , 2 ) tr3 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 4 ) cc ( 1 , m1 , k , 1 , 1 ) = sn * ( tr2 + tr3 ) cc ( 1 , m1 , k , 1 , 3 ) = sn * ( tr2 - tr3 ) cc ( 2 , m1 , k , 1 , 1 ) = sn * ( ti2 + ti3 ) cc ( 2 , m1 , k , 1 , 3 ) = sn * ( ti2 - ti3 ) cc ( 1 , m1 , k , 1 , 2 ) = sn * ( tr1 + tr4 ) cc ( 1 , m1 , k , 1 , 4 ) = sn * ( tr1 - tr4 ) cc ( 2 , m1 , k , 1 , 2 ) = sn * ( ti1 + ti4 ) cc ( 2 , m1 , k , 1 , 4 ) = sn * ( ti1 - ti4 ) end do end do end if return end subroutine cmf5kb ( lot , ido , l1 , na , cc , im1 , in1 , ch , im2 , in2 , wa ) !******************************************************************************* ! !! CMF5KB is an FFTPACK5 auxiliary routine. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none integer ido integer in1 integer in2 integer l1 real ( prec ) cc ( 2 , in1 , l1 , ido , 5 ) real ( prec ) ch ( 2 , in2 , l1 , 5 , ido ) real ( prec ) chold1 real ( prec ) chold2 real ( prec ) ci2 real ( prec ) ci3 real ( prec ) ci4 real ( prec ) ci5 real ( prec ) cr2 real ( prec ) cr3 real ( prec ) cr4 real ( prec ) cr5 real ( prec ) di2 real ( prec ) di3 real ( prec ) di4 real ( prec ) di5 real ( prec ) dr2 real ( prec ) dr3 real ( prec ) dr4 real ( prec ) dr5 integer i integer im1 integer im2 integer k integer lot integer m1 integer m1d integer m2 integer m2s integer na real ( prec ) ti2 real ( prec ) ti3 real ( prec ) ti4 real ( prec ) ti5 real ( prec ), parameter :: ti11 = 0.9510565162951536E+00_prec real ( prec ), parameter :: ti12 = 0.5877852522924731E+00_prec real ( prec ) tr2 real ( prec ) tr3 real ( prec ) tr4 real ( prec ) tr5 real ( prec ), parameter :: tr11 = 0.3090169943749474E+00_prec real ( prec ), parameter :: tr12 = - 0.8090169943749474E+00_prec real ( prec ) wa ( ido , 4 , 2 ) m1d = ( lot - 1 ) * im1 + 1 m2s = 1 - im2 if ( 1 < ido . or . na == 1 ) then do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ti5 = cc ( 2 , m1 , k , 1 , 2 ) - cc ( 2 , m1 , k , 1 , 5 ) ti2 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 5 ) ti4 = cc ( 2 , m1 , k , 1 , 3 ) - cc ( 2 , m1 , k , 1 , 4 ) ti3 = cc ( 2 , m1 , k , 1 , 3 ) + cc ( 2 , m1 , k , 1 , 4 ) tr5 = cc ( 1 , m1 , k , 1 , 2 ) - cc ( 1 , m1 , k , 1 , 5 ) tr2 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 5 ) tr4 = cc ( 1 , m1 , k , 1 , 3 ) - cc ( 1 , m1 , k , 1 , 4 ) tr3 = cc ( 1 , m1 , k , 1 , 3 ) + cc ( 1 , m1 , k , 1 , 4 ) ch ( 1 , m2 , k , 1 , 1 ) = cc ( 1 , m1 , k , 1 , 1 ) + tr2 + tr3 ch ( 2 , m2 , k , 1 , 1 ) = cc ( 2 , m1 , k , 1 , 1 ) + ti2 + ti3 cr2 = cc ( 1 , m1 , k , 1 , 1 ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( 2 , m1 , k , 1 , 1 ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( 1 , m1 , k , 1 , 1 ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( 2 , m1 , k , 1 , 1 ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 ch ( 1 , m2 , k , 2 , 1 ) = cr2 - ci5 ch ( 1 , m2 , k , 5 , 1 ) = cr2 + ci5 ch ( 2 , m2 , k , 2 , 1 ) = ci2 + cr5 ch ( 2 , m2 , k , 3 , 1 ) = ci3 + cr4 ch ( 1 , m2 , k , 3 , 1 ) = cr3 - ci4 ch ( 1 , m2 , k , 4 , 1 ) = cr3 + ci4 ch ( 2 , m2 , k , 4 , 1 ) = ci3 - cr4 ch ( 2 , m2 , k , 5 , 1 ) = ci2 - cr5 end do end do do i = 2 , ido do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ti5 = cc ( 2 , m1 , k , i , 2 ) - cc ( 2 , m1 , k , i , 5 ) ti2 = cc ( 2 , m1 , k , i , 2 ) + cc ( 2 , m1 , k , i , 5 ) ti4 = cc ( 2 , m1 , k , i , 3 ) - cc ( 2 , m1 , k , i , 4 ) ti3 = cc ( 2 , m1 , k , i , 3 ) + cc ( 2 , m1 , k , i , 4 ) tr5 = cc ( 1 , m1 , k , i , 2 ) - cc ( 1 , m1 , k , i , 5 ) tr2 = cc ( 1 , m1 , k , i , 2 ) + cc ( 1 , m1 , k , i , 5 ) tr4 = cc ( 1 , m1 , k , i , 3 ) - cc ( 1 , m1 , k , i , 4 ) tr3 = cc ( 1 , m1 , k , i , 3 ) + cc ( 1 , m1 , k , i , 4 ) ch ( 1 , m2 , k , 1 , i ) = cc ( 1 , m1 , k , i , 1 ) + tr2 + tr3 ch ( 2 , m2 , k , 1 , i ) = cc ( 2 , m1 , k , i , 1 ) + ti2 + ti3 cr2 = cc ( 1 , m1 , k , i , 1 ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( 2 , m1 , k , i , 1 ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( 1 , m1 , k , i , 1 ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( 2 , m1 , k , i , 1 ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 dr3 = cr3 - ci4 dr4 = cr3 + ci4 di3 = ci3 + cr4 di4 = ci3 - cr4 dr5 = cr2 + ci5 dr2 = cr2 - ci5 di5 = ci2 - cr5 di2 = ci2 + cr5 ch ( 1 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * dr2 - wa ( i , 1 , 2 ) * di2 ch ( 2 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * di2 + wa ( i , 1 , 2 ) * dr2 ch ( 1 , m2 , k , 3 , i ) = wa ( i , 2 , 1 ) * dr3 - wa ( i , 2 , 2 ) * di3 ch ( 2 , m2 , k , 3 , i ) = wa ( i , 2 , 1 ) * di3 + wa ( i , 2 , 2 ) * dr3 ch ( 1 , m2 , k , 4 , i ) = wa ( i , 3 , 1 ) * dr4 - wa ( i , 3 , 2 ) * di4 ch ( 2 , m2 , k , 4 , i ) = wa ( i , 3 , 1 ) * di4 + wa ( i , 3 , 2 ) * dr4 ch ( 1 , m2 , k , 5 , i ) = wa ( i , 4 , 1 ) * dr5 - wa ( i , 4 , 2 ) * di5 ch ( 2 , m2 , k , 5 , i ) = wa ( i , 4 , 1 ) * di5 + wa ( i , 4 , 2 ) * dr5 end do end do end do else do k = 1 , l1 do m1 = 1 , m1d , im1 ti5 = cc ( 2 , m1 , k , 1 , 2 ) - cc ( 2 , m1 , k , 1 , 5 ) ti2 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 5 ) ti4 = cc ( 2 , m1 , k , 1 , 3 ) - cc ( 2 , m1 , k , 1 , 4 ) ti3 = cc ( 2 , m1 , k , 1 , 3 ) + cc ( 2 , m1 , k , 1 , 4 ) tr5 = cc ( 1 , m1 , k , 1 , 2 ) - cc ( 1 , m1 , k , 1 , 5 ) tr2 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 5 ) tr4 = cc ( 1 , m1 , k , 1 , 3 ) - cc ( 1 , m1 , k , 1 , 4 ) tr3 = cc ( 1 , m1 , k , 1 , 3 ) + cc ( 1 , m1 , k , 1 , 4 ) chold1 = cc ( 1 , m1 , k , 1 , 1 ) + tr2 + tr3 chold2 = cc ( 2 , m1 , k , 1 , 1 ) + ti2 + ti3 cr2 = cc ( 1 , m1 , k , 1 , 1 ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( 2 , m1 , k , 1 , 1 ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( 1 , m1 , k , 1 , 1 ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( 2 , m1 , k , 1 , 1 ) + tr12 * ti2 + tr11 * ti3 cc ( 1 , m1 , k , 1 , 1 ) = chold1 cc ( 2 , m1 , k , 1 , 1 ) = chold2 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 cc ( 1 , m1 , k , 1 , 2 ) = cr2 - ci5 cc ( 1 , m1 , k , 1 , 5 ) = cr2 + ci5 cc ( 2 , m1 , k , 1 , 2 ) = ci2 + cr5 cc ( 2 , m1 , k , 1 , 3 ) = ci3 + cr4 cc ( 1 , m1 , k , 1 , 3 ) = cr3 - ci4 cc ( 1 , m1 , k , 1 , 4 ) = cr3 + ci4 cc ( 2 , m1 , k , 1 , 4 ) = ci3 - cr4 cc ( 2 , m1 , k , 1 , 5 ) = ci2 - cr5 end do end do end if return end subroutine cmf5kf ( lot , ido , l1 , na , cc , im1 , in1 , ch , im2 , in2 , wa ) !******************************************************************************* ! !! CMF5KF is an FFTPACK5 auxiliary routine. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none integer ido integer in1 integer in2 integer l1 real ( prec ) cc ( 2 , in1 , l1 , ido , 5 ) real ( prec ) ch ( 2 , in2 , l1 , 5 , ido ) real ( prec ) chold1 real ( prec ) chold2 real ( prec ) ci2 real ( prec ) ci3 real ( prec ) ci4 real ( prec ) ci5 real ( prec ) cr2 real ( prec ) cr3 real ( prec ) cr4 real ( prec ) cr5 real ( prec ) di2 real ( prec ) di3 real ( prec ) di4 real ( prec ) di5 real ( prec ) dr2 real ( prec ) dr3 real ( prec ) dr4 real ( prec ) dr5 integer i integer im1 integer im2 integer k integer lot integer m1 integer m1d integer m2 integer m2s integer na real ( prec ) sn real ( prec ) ti2 real ( prec ) ti3 real ( prec ) ti4 real ( prec ) ti5 real ( prec ), parameter :: ti11 = - 0.9510565162951536E+00_prec real ( prec ), parameter :: ti12 = - 0.5877852522924731E+00_prec real ( prec ) tr2 real ( prec ) tr3 real ( prec ) tr4 real ( prec ) tr5 real ( prec ), parameter :: tr11 = 0.3090169943749474E+00_prec real ( prec ), parameter :: tr12 = - 0.8090169943749474E+00_prec real ( prec ) wa ( ido , 4 , 2 ) m1d = ( lot - 1 ) * im1 + 1 m2s = 1 - im2 if ( 1 < ido ) then do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ti5 = cc ( 2 , m1 , k , 1 , 2 ) - cc ( 2 , m1 , k , 1 , 5 ) ti2 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 5 ) ti4 = cc ( 2 , m1 , k , 1 , 3 ) - cc ( 2 , m1 , k , 1 , 4 ) ti3 = cc ( 2 , m1 , k , 1 , 3 ) + cc ( 2 , m1 , k , 1 , 4 ) tr5 = cc ( 1 , m1 , k , 1 , 2 ) - cc ( 1 , m1 , k , 1 , 5 ) tr2 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 5 ) tr4 = cc ( 1 , m1 , k , 1 , 3 ) - cc ( 1 , m1 , k , 1 , 4 ) tr3 = cc ( 1 , m1 , k , 1 , 3 ) + cc ( 1 , m1 , k , 1 , 4 ) ch ( 1 , m2 , k , 1 , 1 ) = cc ( 1 , m1 , k , 1 , 1 ) + tr2 + tr3 ch ( 2 , m2 , k , 1 , 1 ) = cc ( 2 , m1 , k , 1 , 1 ) + ti2 + ti3 cr2 = cc ( 1 , m1 , k , 1 , 1 ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( 2 , m1 , k , 1 , 1 ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( 1 , m1 , k , 1 , 1 ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( 2 , m1 , k , 1 , 1 ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 ch ( 1 , m2 , k , 2 , 1 ) = cr2 - ci5 ch ( 1 , m2 , k , 5 , 1 ) = cr2 + ci5 ch ( 2 , m2 , k , 2 , 1 ) = ci2 + cr5 ch ( 2 , m2 , k , 3 , 1 ) = ci3 + cr4 ch ( 1 , m2 , k , 3 , 1 ) = cr3 - ci4 ch ( 1 , m2 , k , 4 , 1 ) = cr3 + ci4 ch ( 2 , m2 , k , 4 , 1 ) = ci3 - cr4 ch ( 2 , m2 , k , 5 , 1 ) = ci2 - cr5 end do end do do i = 2 , ido do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ti5 = cc ( 2 , m1 , k , i , 2 ) - cc ( 2 , m1 , k , i , 5 ) ti2 = cc ( 2 , m1 , k , i , 2 ) + cc ( 2 , m1 , k , i , 5 ) ti4 = cc ( 2 , m1 , k , i , 3 ) - cc ( 2 , m1 , k , i , 4 ) ti3 = cc ( 2 , m1 , k , i , 3 ) + cc ( 2 , m1 , k , i , 4 ) tr5 = cc ( 1 , m1 , k , i , 2 ) - cc ( 1 , m1 , k , i , 5 ) tr2 = cc ( 1 , m1 , k , i , 2 ) + cc ( 1 , m1 , k , i , 5 ) tr4 = cc ( 1 , m1 , k , i , 3 ) - cc ( 1 , m1 , k , i , 4 ) tr3 = cc ( 1 , m1 , k , i , 3 ) + cc ( 1 , m1 , k , i , 4 ) ch ( 1 , m2 , k , 1 , i ) = cc ( 1 , m1 , k , i , 1 ) + tr2 + tr3 ch ( 2 , m2 , k , 1 , i ) = cc ( 2 , m1 , k , i , 1 ) + ti2 + ti3 cr2 = cc ( 1 , m1 , k , i , 1 ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( 2 , m1 , k , i , 1 ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( 1 , m1 , k , i , 1 ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( 2 , m1 , k , i , 1 ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 dr3 = cr3 - ci4 dr4 = cr3 + ci4 di3 = ci3 + cr4 di4 = ci3 - cr4 dr5 = cr2 + ci5 dr2 = cr2 - ci5 di5 = ci2 - cr5 di2 = ci2 + cr5 ch ( 1 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * dr2 + wa ( i , 1 , 2 ) * di2 ch ( 2 , m2 , k , 2 , i ) = wa ( i , 1 , 1 ) * di2 - wa ( i , 1 , 2 ) * dr2 ch ( 1 , m2 , k , 3 , i ) = wa ( i , 2 , 1 ) * dr3 + wa ( i , 2 , 2 ) * di3 ch ( 2 , m2 , k , 3 , i ) = wa ( i , 2 , 1 ) * di3 - wa ( i , 2 , 2 ) * dr3 ch ( 1 , m2 , k , 4 , i ) = wa ( i , 3 , 1 ) * dr4 + wa ( i , 3 , 2 ) * di4 ch ( 2 , m2 , k , 4 , i ) = wa ( i , 3 , 1 ) * di4 - wa ( i , 3 , 2 ) * dr4 ch ( 1 , m2 , k , 5 , i ) = wa ( i , 4 , 1 ) * dr5 + wa ( i , 4 , 2 ) * di5 ch ( 2 , m2 , k , 5 , i ) = wa ( i , 4 , 1 ) * di5 - wa ( i , 4 , 2 ) * dr5 end do end do end do else if ( na == 1 ) then sn = 1.0E+00_prec / real ( 5 * l1 , prec ) do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ti5 = cc ( 2 , m1 , k , 1 , 2 ) - cc ( 2 , m1 , k , 1 , 5 ) ti2 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 5 ) ti4 = cc ( 2 , m1 , k , 1 , 3 ) - cc ( 2 , m1 , k , 1 , 4 ) ti3 = cc ( 2 , m1 , k , 1 , 3 ) + cc ( 2 , m1 , k , 1 , 4 ) tr5 = cc ( 1 , m1 , k , 1 , 2 ) - cc ( 1 , m1 , k , 1 , 5 ) tr2 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 5 ) tr4 = cc ( 1 , m1 , k , 1 , 3 ) - cc ( 1 , m1 , k , 1 , 4 ) tr3 = cc ( 1 , m1 , k , 1 , 3 ) + cc ( 1 , m1 , k , 1 , 4 ) ch ( 1 , m2 , k , 1 , 1 ) = sn * ( cc ( 1 , m1 , k , 1 , 1 ) + tr2 + tr3 ) ch ( 2 , m2 , k , 1 , 1 ) = sn * ( cc ( 2 , m1 , k , 1 , 1 ) + ti2 + ti3 ) cr2 = cc ( 1 , m1 , k , 1 , 1 ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( 2 , m1 , k , 1 , 1 ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( 1 , m1 , k , 1 , 1 ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( 2 , m1 , k , 1 , 1 ) + tr12 * ti2 + tr11 * ti3 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 ch ( 1 , m2 , k , 2 , 1 ) = sn * ( cr2 - ci5 ) ch ( 1 , m2 , k , 5 , 1 ) = sn * ( cr2 + ci5 ) ch ( 2 , m2 , k , 2 , 1 ) = sn * ( ci2 + cr5 ) ch ( 2 , m2 , k , 3 , 1 ) = sn * ( ci3 + cr4 ) ch ( 1 , m2 , k , 3 , 1 ) = sn * ( cr3 - ci4 ) ch ( 1 , m2 , k , 4 , 1 ) = sn * ( cr3 + ci4 ) ch ( 2 , m2 , k , 4 , 1 ) = sn * ( ci3 - cr4 ) ch ( 2 , m2 , k , 5 , 1 ) = sn * ( ci2 - cr5 ) end do end do else sn = 1.0E+00_prec / real ( 5 * l1 , prec ) do k = 1 , l1 do m1 = 1 , m1d , im1 ti5 = cc ( 2 , m1 , k , 1 , 2 ) - cc ( 2 , m1 , k , 1 , 5 ) ti2 = cc ( 2 , m1 , k , 1 , 2 ) + cc ( 2 , m1 , k , 1 , 5 ) ti4 = cc ( 2 , m1 , k , 1 , 3 ) - cc ( 2 , m1 , k , 1 , 4 ) ti3 = cc ( 2 , m1 , k , 1 , 3 ) + cc ( 2 , m1 , k , 1 , 4 ) tr5 = cc ( 1 , m1 , k , 1 , 2 ) - cc ( 1 , m1 , k , 1 , 5 ) tr2 = cc ( 1 , m1 , k , 1 , 2 ) + cc ( 1 , m1 , k , 1 , 5 ) tr4 = cc ( 1 , m1 , k , 1 , 3 ) - cc ( 1 , m1 , k , 1 , 4 ) tr3 = cc ( 1 , m1 , k , 1 , 3 ) + cc ( 1 , m1 , k , 1 , 4 ) chold1 = sn * ( cc ( 1 , m1 , k , 1 , 1 ) + tr2 + tr3 ) chold2 = sn * ( cc ( 2 , m1 , k , 1 , 1 ) + ti2 + ti3 ) cr2 = cc ( 1 , m1 , k , 1 , 1 ) + tr11 * tr2 + tr12 * tr3 ci2 = cc ( 2 , m1 , k , 1 , 1 ) + tr11 * ti2 + tr12 * ti3 cr3 = cc ( 1 , m1 , k , 1 , 1 ) + tr12 * tr2 + tr11 * tr3 ci3 = cc ( 2 , m1 , k , 1 , 1 ) + tr12 * ti2 + tr11 * ti3 cc ( 1 , m1 , k , 1 , 1 ) = chold1 cc ( 2 , m1 , k , 1 , 1 ) = chold2 cr5 = ti11 * tr5 + ti12 * tr4 ci5 = ti11 * ti5 + ti12 * ti4 cr4 = ti12 * tr5 - ti11 * tr4 ci4 = ti12 * ti5 - ti11 * ti4 cc ( 1 , m1 , k , 1 , 2 ) = sn * ( cr2 - ci5 ) cc ( 1 , m1 , k , 1 , 5 ) = sn * ( cr2 + ci5 ) cc ( 2 , m1 , k , 1 , 2 ) = sn * ( ci2 + cr5 ) cc ( 2 , m1 , k , 1 , 3 ) = sn * ( ci3 + cr4 ) cc ( 1 , m1 , k , 1 , 3 ) = sn * ( cr3 - ci4 ) cc ( 1 , m1 , k , 1 , 4 ) = sn * ( cr3 + ci4 ) cc ( 2 , m1 , k , 1 , 4 ) = sn * ( ci3 - cr4 ) cc ( 2 , m1 , k , 1 , 5 ) = sn * ( ci2 - cr5 ) end do end do end if return end subroutine cmfgkb ( lot , ido , ip , l1 , lid , na , cc , cc1 , im1 , in1 , & ch , ch1 , im2 , in2 , wa ) !******************************************************************************* ! !! CMFGKB is an FFTPACK5 auxiliary routine. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none integer ido integer in1 integer in2 integer ip integer l1 integer lid real ( prec ) cc ( 2 , in1 , l1 , ip , ido ) real ( prec ) cc1 ( 2 , in1 , lid , ip ) real ( prec ) ch ( 2 , in2 , l1 , ido , ip ) real ( prec ) ch1 ( 2 , in2 , lid , ip ) real ( prec ) chold1 real ( prec ) chold2 integer i integer idlj integer im1 integer im2 integer ipp2 integer ipph integer j integer jc integer k integer ki integer l integer lc integer lot integer m1 integer m1d integer m2 integer m2s integer na real ( prec ) wa ( ido , ip - 1 , 2 ) real ( prec ) wai real ( prec ) war m1d = ( lot - 1 ) * im1 + 1 m2s = 1 - im2 ipp2 = ip + 2 ipph = ( ip + 1 ) / 2 do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch1 ( 1 , m2 , ki , 1 ) = cc1 ( 1 , m1 , ki , 1 ) ch1 ( 2 , m2 , ki , 1 ) = cc1 ( 2 , m1 , ki , 1 ) end do end do do j = 2 , ipph jc = ipp2 - j do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch1 ( 1 , m2 , ki , j ) = cc1 ( 1 , m1 , ki , j ) + cc1 ( 1 , m1 , ki , jc ) ch1 ( 1 , m2 , ki , jc ) = cc1 ( 1 , m1 , ki , j ) - cc1 ( 1 , m1 , ki , jc ) ch1 ( 2 , m2 , ki , j ) = cc1 ( 2 , m1 , ki , j ) + cc1 ( 2 , m1 , ki , jc ) ch1 ( 2 , m2 , ki , jc ) = cc1 ( 2 , m1 , ki , j ) - cc1 ( 2 , m1 , ki , jc ) end do end do end do do j = 2 , ipph do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 cc1 ( 1 , m1 , ki , 1 ) = cc1 ( 1 , m1 , ki , 1 ) + ch1 ( 1 , m2 , ki , j ) cc1 ( 2 , m1 , ki , 1 ) = cc1 ( 2 , m1 , ki , 1 ) + ch1 ( 2 , m2 , ki , j ) end do end do end do do l = 2 , ipph lc = ipp2 - l do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 cc1 ( 1 , m1 , ki , l ) = ch1 ( 1 , m2 , ki , 1 ) + wa ( 1 , l - 1 , 1 ) * ch1 ( 1 , m2 , ki , 2 ) cc1 ( 1 , m1 , ki , lc ) = wa ( 1 , l - 1 , 2 ) * ch1 ( 1 , m2 , ki , ip ) cc1 ( 2 , m1 , ki , l ) = ch1 ( 2 , m2 , ki , 1 ) + wa ( 1 , l - 1 , 1 ) * ch1 ( 2 , m2 , ki , 2 ) cc1 ( 2 , m1 , ki , lc ) = wa ( 1 , l - 1 , 2 ) * ch1 ( 2 , m2 , ki , ip ) end do end do do j = 3 , ipph jc = ipp2 - j idlj = mod ( ( l - 1 ) * ( j - 1 ), ip ) war = wa ( 1 , idlj , 1 ) wai = wa ( 1 , idlj , 2 ) do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 cc1 ( 1 , m1 , ki , l ) = cc1 ( 1 , m1 , ki , l ) + war * ch1 ( 1 , m2 , ki , j ) cc1 ( 1 , m1 , ki , lc ) = cc1 ( 1 , m1 , ki , lc ) + wai * ch1 ( 1 , m2 , ki , jc ) cc1 ( 2 , m1 , ki , l ) = cc1 ( 2 , m1 , ki , l ) + war * ch1 ( 2 , m2 , ki , j ) cc1 ( 2 , m1 , ki , lc ) = cc1 ( 2 , m1 , ki , lc ) + wai * ch1 ( 2 , m2 , ki , jc ) end do end do end do end do if ( 1 < ido . or . na == 1 ) then do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch1 ( 1 , m2 , ki , 1 ) = cc1 ( 1 , m1 , ki , 1 ) ch1 ( 2 , m2 , ki , 1 ) = cc1 ( 2 , m1 , ki , 1 ) end do end do do j = 2 , ipph jc = ipp2 - j do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch1 ( 1 , m2 , ki , j ) = cc1 ( 1 , m1 , ki , j ) - cc1 ( 2 , m1 , ki , jc ) ch1 ( 1 , m2 , ki , jc ) = cc1 ( 1 , m1 , ki , j ) + cc1 ( 2 , m1 , ki , jc ) ch1 ( 2 , m2 , ki , jc ) = cc1 ( 2 , m1 , ki , j ) - cc1 ( 1 , m1 , ki , jc ) ch1 ( 2 , m2 , ki , j ) = cc1 ( 2 , m1 , ki , j ) + cc1 ( 1 , m1 , ki , jc ) end do end do end do if ( ido == 1 ) then return end if do i = 1 , ido do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 cc ( 1 , m1 , k , 1 , i ) = ch ( 1 , m2 , k , i , 1 ) cc ( 2 , m1 , k , 1 , i ) = ch ( 2 , m2 , k , i , 1 ) end do end do end do do j = 2 , ip do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 cc ( 1 , m1 , k , j , 1 ) = ch ( 1 , m2 , k , 1 , j ) cc ( 2 , m1 , k , j , 1 ) = ch ( 2 , m2 , k , 1 , j ) end do end do end do do j = 2 , ip do i = 2 , ido do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 cc ( 1 , m1 , k , j , i ) = wa ( i , j - 1 , 1 ) * ch ( 1 , m2 , k , i , j ) & - wa ( i , j - 1 , 2 ) * ch ( 2 , m2 , k , i , j ) cc ( 2 , m1 , k , j , i ) = wa ( i , j - 1 , 1 ) * ch ( 2 , m2 , k , i , j ) & + wa ( i , j - 1 , 2 ) * ch ( 1 , m2 , k , i , j ) end do end do end do end do else do j = 2 , ipph jc = ipp2 - j do ki = 1 , lid do m1 = 1 , m1d , im1 chold1 = cc1 ( 1 , m1 , ki , j ) - cc1 ( 2 , m1 , ki , jc ) chold2 = cc1 ( 1 , m1 , ki , j ) + cc1 ( 2 , m1 , ki , jc ) cc1 ( 1 , m1 , ki , j ) = chold1 cc1 ( 2 , m1 , ki , jc ) = cc1 ( 2 , m1 , ki , j ) - cc1 ( 1 , m1 , ki , jc ) cc1 ( 2 , m1 , ki , j ) = cc1 ( 2 , m1 , ki , j ) + cc1 ( 1 , m1 , ki , jc ) cc1 ( 1 , m1 , ki , jc ) = chold2 end do end do end do end if return end subroutine cmfgkf ( lot , ido , ip , l1 , lid , na , cc , cc1 , im1 , in1 , & ch , ch1 , im2 , in2 , wa ) !******************************************************************************* ! !! CMFGKF is an FFTPACK5 auxiliary routine. ! !  License: ! !    Licensed under the GNU General Public License (GPL). !    Copyright (C) 1995-2004, Scientific Computing Division, !    University Corporation for Atmospheric Research ! !  Author: ! !    Paul Swarztrauber !    Richard Valent ! !  Reference: ! !    Paul Swarztrauber, !    Vectorizing the Fast Fourier Transforms, !    in Parallel Computations, !    edited by G. Rodrigue, !    Academic Press, 1982. ! !    Paul Swarztrauber, !    Fast Fourier Transform Algorithms for Vector Computers, !    Parallel Computing, pages 45-63, 1984. ! !  Parameters: ! use fftpack5 implicit none integer ido integer in1 integer in2 integer ip integer l1 integer lid real ( prec ) cc ( 2 , in1 , l1 , ip , ido ) real ( prec ) cc1 ( 2 , in1 , lid , ip ) real ( prec ) ch ( 2 , in2 , l1 , ido , ip ) real ( prec ) ch1 ( 2 , in2 , lid , ip ) real ( prec ) chold1 real ( prec ) chold2 integer i integer idlj integer im1 integer im2 integer ipp2 integer ipph integer j integer jc integer k integer ki integer l integer lc integer lot integer m1 integer m1d integer m2 integer m2s integer na real ( prec ) sn real ( prec ) wa ( ido , ip - 1 , 2 ) real ( prec ) wai real ( prec ) war m1d = ( lot - 1 ) * im1 + 1 m2s = 1 - im2 ipp2 = ip + 2 ipph = ( ip + 1 ) / 2 do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch1 ( 1 , m2 , ki , 1 ) = cc1 ( 1 , m1 , ki , 1 ) ch1 ( 2 , m2 , ki , 1 ) = cc1 ( 2 , m1 , ki , 1 ) end do end do do j = 2 , ipph jc = ipp2 - j do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch1 ( 1 , m2 , ki , j ) = cc1 ( 1 , m1 , ki , j ) + cc1 ( 1 , m1 , ki , jc ) ch1 ( 1 , m2 , ki , jc ) = cc1 ( 1 , m1 , ki , j ) - cc1 ( 1 , m1 , ki , jc ) ch1 ( 2 , m2 , ki , j ) = cc1 ( 2 , m1 , ki , j ) + cc1 ( 2 , m1 , ki , jc ) ch1 ( 2 , m2 , ki , jc ) = cc1 ( 2 , m1 , ki , j ) - cc1 ( 2 , m1 , ki , jc ) end do end do end do do j = 2 , ipph do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 cc1 ( 1 , m1 , ki , 1 ) = cc1 ( 1 , m1 , ki , 1 ) + ch1 ( 1 , m2 , ki , j ) cc1 ( 2 , m1 , ki , 1 ) = cc1 ( 2 , m1 , ki , 1 ) + ch1 ( 2 , m2 , ki , j ) end do end do end do do l = 2 , ipph lc = ipp2 - l do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 cc1 ( 1 , m1 , ki , l ) = ch1 ( 1 , m2 , ki , 1 ) + wa ( 1 , l - 1 , 1 ) * ch1 ( 1 , m2 , ki , 2 ) cc1 ( 1 , m1 , ki , lc ) = - wa ( 1 , l - 1 , 2 ) * ch1 ( 1 , m2 , ki , ip ) cc1 ( 2 , m1 , ki , l ) = ch1 ( 2 , m2 , ki , 1 ) + wa ( 1 , l - 1 , 1 ) * ch1 ( 2 , m2 , ki , 2 ) cc1 ( 2 , m1 , ki , lc ) = - wa ( 1 , l - 1 , 2 ) * ch1 ( 2 , m2 , ki , ip ) end do end do do j = 3 , ipph jc = ipp2 - j idlj = mod ( ( l - 1 ) * ( j - 1 ), ip ) war = wa ( 1 , idlj , 1 ) wai = - wa ( 1 , idlj , 2 ) do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 cc1 ( 1 , m1 , ki , l ) = cc1 ( 1 , m1 , ki , l ) + war * ch1 ( 1 , m2 , ki , j ) cc1 ( 1 , m1 , ki , lc ) = cc1 ( 1 , m1 , ki , lc ) + wai * ch1 ( 1 , m2 , ki , jc ) cc1 ( 2 , m1 , ki , l ) = cc1 ( 2 , m1 , ki , l ) + war * ch1 ( 2 , m2 , ki , j ) cc1 ( 2 , m1 , ki , lc ) = cc1 ( 2 , m1 , ki , lc ) + wai * ch1 ( 2 , m2 , ki , jc ) end do end do end do end do if ( 1 < ido ) then do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch1 ( 1 , m2 , ki , 1 ) = cc1 ( 1 , m1 , ki , 1 ) ch1 ( 2 , m2 , ki , 1 ) = cc1 ( 2 , m1 , ki , 1 ) end do end do do j = 2 , ipph jc = ipp2 - j do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch1 ( 1 , m2 , ki , j ) = cc1 ( 1 , m1 , ki , j ) - cc1 ( 2 , m1 , ki , jc ) ch1 ( 2 , m2 , ki , j ) = cc1 ( 2 , m1 , ki , j ) + cc1 ( 1 , m1 , ki , jc ) ch1 ( 1 , m2 , ki , jc ) = cc1 ( 1 , m1 , ki , j ) + cc1 ( 2 , m1 , ki , jc ) ch1 ( 2 , m2 , ki , jc ) = cc1 ( 2 , m1 , ki , j ) - cc1 ( 1 , m1 , ki , jc ) end do end do end do do i = 1 , ido do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 cc ( 1 , m1 , k , 1 , i ) = ch ( 1 , m2 , k , i , 1 ) cc ( 2 , m1 , k , 1 , i ) = ch ( 2 , m2 , k , i , 1 ) end do end do end do do j = 2 , ip do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 cc ( 1 , m1 , k , j , 1 ) = ch ( 1 , m2 , k , 1 , j ) cc ( 2 , m1 , k , j , 1 ) = ch ( 2 , m2 , k , 1 , j ) end do end do end do do j = 2 , ip do i = 2 , ido do k = 1 , l1 m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 cc ( 1 , m1 , k , j , i ) = wa ( i , j - 1 , 1 ) * ch ( 1 , m2 , k , i , j ) & + wa ( i , j - 1 , 2 ) * ch ( 2 , m2 , k , i , j ) cc ( 2 , m1 , k , j , i ) = wa ( i , j - 1 , 1 ) * ch ( 2 , m2 , k , i , j ) & - wa ( i , j - 1 , 2 ) * ch ( 1 , m2 , k , i , j ) end do end do end do end do else if ( na == 1 ) then sn = 1.0E+00_prec / real ( ip * l1 , prec ) do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch1 ( 1 , m2 , ki , 1 ) = sn * cc1 ( 1 , m1 , ki , 1 ) ch1 ( 2 , m2 , ki , 1 ) = sn * cc1 ( 2 , m1 , ki , 1 ) end do end do do j = 2 , ipph jc = ipp2 - j do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 ch1 ( 1 , m2 , ki , j ) = sn * ( cc1 ( 1 , m1 , ki , j ) - cc1 ( 2 , m1 , ki , jc ) ) ch1 ( 2 , m2 , ki , j ) = sn * ( cc1 ( 2 , m1 , ki , j ) + cc1 ( 1 , m1 , ki , jc ) ) ch1 ( 1 , m2 , ki , jc ) = sn * ( cc1 ( 1 , m1 , ki , j ) + cc1 ( 2 , m1 , ki , jc ) ) ch1 ( 2 , m2 , ki , jc ) = sn * ( cc1 ( 2 , m1 , ki , j ) - cc1 ( 1 , m1 , ki , jc ) ) end do end do end do else sn = 1.0E+00_prec / real ( ip * l1 , prec ) do ki = 1 , lid m2 = m2s do m1 = 1 , m1d , im1 m2 = m2 + im2 cc1 ( 1 , m1 , ki , 1 ) = sn * cc1 ( 1 , m1 , ki , 1 ) cc1 ( 2 , m1 , ki , 1 ) = sn * cc1 ( 2 , m1 , ki , 1 ) end do end do do j = 2 , ipph jc = ipp2 - j do ki = 1 , lid do m1 = 1 , m1d , im1 chold1 = sn * ( cc1 ( 1 , m1 , ki , j ) - cc1 ( 2 , m1 , ki , jc ) ) chold2 = sn * ( cc1 ( 1 , m1 , ki , j ) + cc1 ( 2 , m1 , ki , jc ) ) cc1 ( 1 , m1 , ki , j ) = chold1 cc1 ( 2 , m1 , ki , jc ) = sn * ( cc1 ( 2 , m1 , ki , j ) - cc1 ( 1 , m1 , ki , jc ) ) cc1 ( 2 , m1 , ki , j ) = sn * ( cc1 ( 2 , m1 , ki , j ) + cc1 ( 1 , m1 , ki , jc ) ) cc1 ( 1 , m1 , ki , jc ) = chold2 end do end do end do end if return end","tags":"","url":"sourcefile/cfftnd.f90.html"},{"title":"w902intw.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! program w902intw !! display: none !! !! Build and save Wannier U and H(R) matrices for use within INTW. !! !! ### Details !! !! #### Input parameters !! !! ```{.txt} !! &input !!     outdir                = 'directory' !!     prefix                = 'prefix' !!     nk1                   = integer !!     nk2                   = integer !!     nk3                   = integer !!     use_exclude_bands     = 'none', 'wannier' or 'custom' !!     include_bands_initial = integer !!     include_bands_final   = integer !! / !! ``` !! !! See [[intw_input_parameters]] module for the description of each parameter. !! use kinds , only : dp use intw_version , only : print_intw_version use intw_utility , only : get_timing , print_threads , print_date_time use intw_w90_setup , only : read_eig , allocate_and_build_u_mesh , write_formatted_u_mesh , & allocate_and_build_ws_irvec , allocate_and_build_ham_k , & allocate_and_build_ham_r , write_ham_r use intw_input_parameters , only : nk1 , nk2 , nk3 , outdir , prefix , read_input use intw_reading , only : read_parameters_data_file , set_num_bands use intw_intw2wannier , only : read_nnkp_file implicit none character ( 256 ) :: nnkp_file logical :: have_nnkp logical :: read_status ! timing real ( dp ) :: time1 , time2 20 format ( A ) 30 format ( A , F8 . 2 , 6 X , A ) !================================================================================ ! Beginning !================================================================================ call get_timing ( time1 ) write ( * , 20 ) '=====================================================' write ( * , 20 ) '|                  program w902intw                 |' write ( * , 20 ) '|         ---------------------------------         |' call print_intw_version () call print_threads () call print_date_time ( \"Start of execution\" ) write ( * , 20 ) '=====================================================' !================================================================================ ! Read the input file !================================================================================ call read_input ( read_status ) if ( read_status ) stop !================================================================================ ! Check that $prefix.nnkp is present !================================================================================ nnkp_file = trim ( outdir ) // trim ( prefix ) // \".nnkp\" inquire ( file = nnkp_file , exist = have_nnkp ) if (. not . have_nnkp ) then write ( * , 20 ) '**********************************************************' write ( * , 20 ) '* Could not find the file ' // trim ( nnkp_file ) write ( * , 20 ) '* Did you run W90 -pp $seed to get the parameter file?   ' write ( * , 20 ) '**********************************************************' stop end if write ( * , 20 ) '| - .nnkp file found                                |' write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Read the parameters from the SCF calculation !================================================================================ write ( * , 20 ) '| - Reading calculation parameters...               |' call read_parameters_data_file () !================================================================================ ! Set the number of wave functions !================================================================================ call set_num_bands () !================================================================================ ! Read the .nnkp file !================================================================================ write ( * , 20 ) '| - Reading nnkp file...                            |' call read_nnkp_file ( nnkp_file ) write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Read the .eig file !================================================================================ write ( * , 20 ) '| - Reading eig file...                             |' call read_eig () !================================================================================ ! Read the .chk file, build u matrix and write to file !================================================================================ write ( * , 20 ) '| - Reading and building Wannier U matrix...        |' call allocate_and_build_u_mesh () write ( * , 20 ) '| - Saving Wannier U matrix...                      |' call write_formatted_u_mesh () !================================================================================ ! Build Wigner-Seitz cell !================================================================================ write ( * , 20 ) '| - Building WS mesh...                             |' call allocate_and_build_ws_irvec ( nk1 , nk2 , nk3 ) !================================================================================ ! Build H(k) and H(R), write H(R) to file !================================================================================ write ( * , 20 ) '| - Building Wannier H(k) and H(R)...               |' call allocate_and_build_ham_k () call allocate_and_build_ham_r () write ( * , 20 ) '| - Saving Wannier H(R)...                          |' call write_ham_r () write ( * , 20 ) '=====================================================' !================================================================================ ! Finish !================================================================================ call get_timing ( time2 ) write ( * , 20 ) '|                      ALL DONE                     |' write ( * , 30 ) '|     Total time: ' , time2 - time1 , ' seconds            |' call print_date_time ( 'End of execution  ' ) write ( * , 20 ) '=====================================================' end program w902intw","tags":"","url":"sourcefile/w902intw.f90.html"},{"title":"fft.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_fft !! display: none !! !! This module contains variables and subroutines for handling most of the g -> r and !! r -> g transformations using FFT. !! !! ### Details !! !! The correspondence between the nr1 nr2 nr3 FFT grid with the G list !! of the calculation is taken into account, and for wave functions, !! the reduced G list inside the cut-off is considered. !! use kinds , only : dp ! implicit none ! ! variables public :: nl , g_fft_map , gvec_cart , gg , phase , strf ! ! subroutines public :: allocate_fft , deallocate_fft , & generate_nl , wfc_by_expigr , wfc_from_g_to_r , wfc_from_r_to_g , & func_from_g_to_r , r_function_by_exp_igr , func_from_r_to_g , & find_iG , coarse_to_smooth ! private ! ! Correspondence between the nr1 nr2 nr3 FFT grid with the G list (calculations). integer , allocatable :: nl (:) integer , allocatable :: g_fft_map (:,:,:) ! The G vectors in cartesian coordinates real ( dp ), allocatable :: gvec_cart (:,:) ! The module squared of the G vectors real ( dp ), allocatable :: gg (:) ! The complex phases for each G and atomic position: exp( -2 pi i tau(1:nat).G ) complex ( dp ), allocatable :: phase (:,:) ! The structure factor complex ( dp ), allocatable :: strf (:,:) ! save contains subroutine allocate_fft () !-------------------------------------------------------- ! This subroutine simply allocates the arrays needed ! by the fft algorithms. !-------------------------------------------------------- use intw_reading , only : nG , nr1 , nr2 , nr3 , nat , ntyp implicit none allocate ( nl ( nG ), g_fft_map ( nr1 , nr2 , nr3 ) ) allocate ( phase ( nG , nat ) ) allocate ( gvec_cart ( 3 , nG )) allocate ( gg ( nG )) allocate ( strf ( nG , ntyp )) end subroutine allocate_fft subroutine deallocate_fft () !-------------------------------------------------------- ! This subroutine simply deallocates the arrays needed ! by the fft algorithms. !-------------------------------------------------------- deallocate ( nl , g_fft_map ) deallocate ( phase ) deallocate ( gvec_cart ) deallocate ( gg ) deallocate ( strf ) end subroutine deallocate_fft subroutine generate_nl () !------------------------------------------------------------------------ !  This subroutine generates information important for the 3D-FFT !  algorithm. ! !  A bit of theory: !  --------------- ! !  Consider a mesh in real space described by nr1 x nr2 x nr3, such that !            r(i,j,k) =  (i-1)/nr1 a1 +  (j-1)/nr2 a2 + (k-1)/nr3 a3 ! !  with a1, a2, a3 the basis vectors of the real space lattice, and !                1 <= i <= nr1, 1 <= j <= nr2, 1 <= k <= nr3. ! !  A reciprocal space lattice can then be defined: ! !  G_fft(I,J,K)  =  (I-1) b1 +  (J-1) b2 + (K-1) b3 !  with b1, b2, b3 the basis vectors of the reciprocal space lattice. !             As usual, a_i * b_j = 2 pi delta_{ij} ! !  So that the phase factor is given by: ! !     EXP [ i G_fft(I,J,K) * r(i,j,k) ] = ! !             EXP[ 2 pi i (  (I-1)(i-1)   + (J-1)(j-1)   + (K-1)(k-1) )] !                [        (  ---------      ----------     ---------  )] !                [        (     nr1            nr2             nr3    )] ! !     Then, clearly, the only independent phase factors correspond to !                1 <= I <= nr1, 1 <= J <= nr2, 1 <= K <= nr3. !     Any G vector outside of this box is periodically equivalent to !     a G vector inside the box. ! !  So, what does this subroutine do? !  --------------------------------- ! !  The G vectors usually used are not defined in the box !                1 <= I <= nr1, 1 <= J <= nr2, 1 <= K <= nr3, !  but rather they are symmetrically distributed around the origin. !  This makes sense from a physical point of view, which doesn't care !  about FFT meshes. ! !  THIS SUBROUTINE: ! !             - finds the relationship between the usually defined !               G vectors, stored in gvec in crystal coordinates, and !               the FFT G vector mesh. ! !             - It creates an array !                  G_fft_map(n1,n2,n3) = index of G vector in gvec which !                                        corresponds to G_fft(n1,n2,n3) ! !             - It creates an array nl, which returns the scalar !               index \"nl\" corresponding to the triple index (n1,n2,n3) !               of the G vector gvec(ig). ! !             - It computes the phases !                    phase(ig,ia) = Exp ( -2 pi i gvec(ig) * tau(ia) ) ! !------------------------------------------------------------------------ use intw_reading , only : nG , gvec , bg , nat , tau , ntyp , ityp , nr1 , nr2 , nr3 , tpiba2 use intw_utility , only : triple_to_joint_index_r , cryst_to_cart use intw_useful_constants , only : tpi , cmplx_i , cmplx_0 implicit none !local logical :: assigned ( nr1 , nr2 , nr3 ) integer :: n1 , n2 , n3 integer :: ig , na , nt g_fft_map (:,:,:) = 0 nl (:) = 0 assigned (:,:,:) = . false . ! loop on all G vectors in the global array gvec do ig = 1 , nG ! find the triple index corresponding to the G_fft mesh ! NOTE: the function \"modulo\" always returns a positive number in FORTRAN90 !       the function \"mod\" is more dangerous. n1 = modulo ( gvec ( 1 , ig ), nr1 ) + 1 n2 = modulo ( gvec ( 2 , ig ), nr2 ) + 1 n3 = modulo ( gvec ( 3 , ig ), nr3 ) + 1 if (. not . assigned ( n1 , n2 , n3 ) ) then assigned ( n1 , n2 , n3 ) = . true . g_fft_map ( n1 , n2 , n3 ) = ig ! compute the scalar index corresponding to n1,n2,n3 and ! assign it to nl(ig) call triple_to_joint_index_r ( nr1 , nr2 , nr3 , nl ( ig ), n1 , n2 , n3 ) else write ( * , * ) 'ERROR in generate_nl. FFT mesh too small?' write ( * , * ) '    More than one G-vector in the gvec array are being' write ( * , * ) '    assigned to the same FFT triple (n1,n2,n3);       ' write ( * , * ) '    this suggests that the FFT mesh (nr1,nr2,nr3) is  ' write ( * , * ) '    too small.                                        ' stop endif end do ! ig ! Obtain the G vectors in cartesian coordinates gvec_cart ( 1 : 3 , 1 : nG ) = gvec ( 1 : 3 , 1 : nG ) call cryst_to_cart ( nG , gvec_cart , bg , 1 ) ! Calculate module squared of the G vectors do ig = 1 , nG gg ( ig ) = tpiba2 * dot_product ( gvec_cart (:, ig ), gvec_cart (:, ig )) enddo ! Compute the phases do na = 1 , nat do ig = 1 , nG ! the tau vectors are in cartesian, alat units. phase ( ig , na ) = exp ( - tpi * cmplx_i * dot_product ( gvec_cart (:, ig ), tau (:, na )) ) enddo enddo ! Compute structure factor strf (:,:) = cmplx_0 do nt = 1 , ntyp do na = 1 , nat if ( ityp ( na ) == nt ) then strf (:, nt ) = strf (:, nt ) + phase (:, na ) endif enddo enddo end subroutine generate_nl subroutine wfc_by_expigr ( num_bands , nspin , G , list_iG , wfc ) use intw_reading , only : gvec , nGk_max use intw_utility , only : hpsort_integer use intw_useful_constants , only : cmplx_0 implicit none !I/O variables integer , intent ( in ) :: num_bands , nspin integer , intent ( in ) :: G ( 3 ) ! G vector such that k_out = k_in + G integer , intent ( inout ) :: list_iG ( nGk_max ) ! On input, G vector indices for k, sorted ! On output, G vector indices for k + G, sorted complex ( dp ), intent ( inout ) :: wfc ( nGk_max , num_bands , nspin ) ! On input, wave function components for k ! On output, wave function components for k + G !local variables integer :: list_iG_k_irr ( nGk_max ) complex ( dp ) :: wfc_k_irr ( nGk_max , num_bands , nspin ) integer :: p_i , i , iG_k_irr , iG_k integer :: G_k ( 3 ) ! a vector for Rk, the point in the 1BZ integer :: permutations ( nGk_max ) ! index permutation which orders list_G_k integer :: nb , ispin , nGk !Initialization ! list_iG_k_irr = list_iG list_iG = 0 ! ! loop on all G_k_irr, the coefficients of the wave function at the IBZ k point ! nGk = 0 do i = 1 , nGk_max ! iG_k_irr = list_iG_k_irr ( i ) ! if ( iG_k_irr == 0 ) exit ! the index array is zero-padded at the end. ! nGk = nGk + 1 ! G_k (:) = gvec (:, iG_k_irr ) - G (:) ! minus by convention: exp(-iGr) ! call find_iG ( G_k , iG_k ) ! list_iG ( nGk ) = iG_k ! enddo ! call hpsort_integer ( nGk , list_iG , permutations ) wfc_k_irr = wfc wfc = cmplx_0 ! do i = 1 , nGk ! p_i = permutations ( i ) ! ! compute the wfc element ! do nb = 1 , num_bands do ispin = 1 , nspin ! wfc ( i , nb , ispin ) = wfc_k_irr ( p_i , nb , ispin ) ! enddo enddo ! enddo end subroutine wfc_by_expigr subroutine wfc_from_g_to_r ( list_iG , wfc_g , wfc_r ) !-------------------------------------------------------- !  This subroutine is a driver which uses the 3D-FFT !  code to transform a wavefunction in G space to !  a wavefunction in r space. ! !     in ::        wfc_g(nGk_max)        : the u_{nk}(G) coefficients !                  list_iG               : the indices of the G vectors used !                                          in the wave function ! !     out::  wfc_r(nr1*nr2*nr3)          : The periodic part of the wave functions !                                          in real space, with the space index !                                          represented by a scalar. !-------------------------------------------------------- use intw_reading , only : nGk_max , nr1 , nr2 , nr3 use intw_useful_constants , only : cmplx_0 implicit none external :: cfftnd integer :: i , iG integer :: list_iG ( nGk_max ) complex ( dp ), intent ( in ) :: wfc_g ( nGk_max ) complex ( dp ), intent ( out ) :: wfc_r ( nr1 * nr2 * nr3 ) ! initialize work array wfc_r (:) = cmplx_0 ! put wfc_g in wfc_r do i = 1 , nGk_max ! identify the G vector by its index, as stored in list_iG iG = list_iG ( i ) if ( iG == 0 ) exit ! use nl to identify which G_fft vector G corresponds to, ! and assign the value of the wave function in the aux array wfc_r ( nl ( iG )) = wfc_g ( i ) enddo ! perform fourier transform in place wfc_g(G) -> wfc_r(r) ! CONVENTION BY ASIER call cfftnd ( 3 ,( / nr1 , nr2 , nr3 / ), 1 , wfc_r ) ! ! this convention reproduces ! the results of pw2wannier EXACTLY end subroutine wfc_from_g_to_r subroutine wfc_from_r_to_g ( list_iG , wfc_r , wfc_g ) !-------------------------------------------------------- !  This subroutine is a driver which uses the 3D-FFT !  code to transform a wavefunction in G space to !  a wavefunction in r space. ! !     in ::        wfc_g(nGk_max)        : the u_{nk}(G) coefficients !                  list_iG               : the indices of the G vectors used !                                          in the wave function ! !     out::  wfc_r(nr1*nr2*nr3)          : The periodic part of the wave functions !                                          in real space, with the space index !                                          represented by a scalar. !-------------------------------------------------------- use intw_reading , only : nGk_max , nr1 , nr2 , nr3 use intw_useful_constants , only : cmplx_0 implicit none external :: cfftnd integer :: i , iG integer :: list_iG ( nGk_max ) complex ( dp ), intent ( out ) :: wfc_g ( nGk_max ) complex ( dp ), intent ( in ) :: wfc_r ( nr1 * nr2 * nr3 ) complex ( dp ) :: aux ( nr1 * nr2 * nr3 ) ! initialize work array aux = wfc_r wfc_g (:) = cmplx_0 call cfftnd ( 3 ,( / nr1 , nr2 , nr3 / ), - 1 , aux ) ! ! this convention reproduces ! the results of pw2wannier EXACTLY do i = 1 , nGk_max ! identify the G vector by its index, as stored in list_iG iG = list_iG ( i ) if ( iG == 0 ) exit ! use nl to identify which G_fft vector G corresponds to, ! and assign the value of the wave function in the aux array wfc_g ( i ) = aux ( nl ( ig )) enddo end subroutine wfc_from_r_to_g subroutine func_from_g_to_r ( nfunc , fg , fr ) !-------------------------------------------------------- !  This subroutine is a driver which uses the 3D-FFT !  code to go from f(G) to f(r). !-------------------------------------------------------- use intw_reading , only : nr1 , nr2 , nr3 , nG use intw_useful_constants , only : cmplx_0 implicit none integer , intent ( in ) :: nfunc complex ( dp ), intent ( in ) :: fg ( nG , nfunc ) complex ( dp ), intent ( out ) :: fr ( nr1 * nr2 * nr3 , nfunc ) integer :: mode , ig complex ( dp ) :: aux ( nr1 * nr2 * nr3 ) external :: cfftnd do mode = 1 , nfunc ! initialize work array aux (:) = cmplx_0 ! put fg in aux do ig = 1 , nG aux ( nl ( ig )) = fg ( ig , mode ) enddo ! perform fourier transform in place aux(fg) -> aux(fr) call cfftnd ( 3 , ( / nr1 , nr2 , nr3 / ), 1 , aux ) ! This is the right convention ! put aux in fr fr (:, mode ) = aux (:) enddo end subroutine func_from_g_to_r subroutine r_function_by_exp_igr ( g_cryst , nfunc , nr1 , nr2 , nr3 , fr , fr_exp_igr ) use intw_utility , only : joint_to_triple_index_g use intw_useful_constants , only : tpi , cmplx_i implicit none integer , intent ( in ) :: g_cryst ( 3 ), nfunc , nr1 , nr2 , nr3 complex ( dp ), intent ( in ) :: fr ( nr1 * nr2 * nr3 , nfunc ) complex ( dp ), intent ( out ) :: fr_exp_igr ( nr1 * nr2 * nr3 , nfunc ) integer :: mode , i , j , k , ir real ( dp ) :: gr do mode = 1 , nfunc do ir = 1 , nr1 * nr2 * nr3 call joint_to_triple_index_g ( nr1 , nr2 , nr3 , ir , i , j , k ) gr = tpi * ( g_cryst ( 1 ) * ( i - 1 ) / nr1 + g_cryst ( 1 ) * ( j - 1 ) / nr2 + g_cryst ( 1 ) * ( k - 1 ) / nr3 ) fr_exp_igr ( ir , mode ) = fr ( ir , mode ) * exp ( cmplx_i * gr ) enddo enddo end subroutine r_function_by_exp_igr subroutine func_from_r_to_g ( nfunc , fr , fg ) !-------------------------------------------------------- !  This subroutine is a driver which uses the 3D-FFT !  code to go from f(r) to f(G). !-------------------------------------------------------- use intw_reading , only : nr1 , nr2 , nr3 , nG use intw_useful_constants , only : cmplx_0 implicit none integer , intent ( in ) :: nfunc complex ( dp ), intent ( in ) :: fr ( nr1 * nr2 * nr3 , nfunc ) complex ( dp ), intent ( out ) :: fg ( nG , nfunc ) integer :: mode , ig , ir complex ( dp ) :: aux ( nr1 * nr2 * nr3 ) external :: cfftnd do mode = 1 , nfunc aux (:) = cmplx_0 do ir = 1 , nr1 * nr2 * nr3 aux ( ir ) = fr ( ir , mode ) enddo call cfftnd ( 3 , ( / nr1 , nr2 , nr3 / ), - 1 , aux ) ! this is the right convention do ig = 1 , nG fg ( ig , mode ) = aux ( nl ( ig )) enddo enddo end subroutine func_from_r_to_g subroutine find_iG ( G , iG ) !----------------------------------------------------------------------------! !     Given a G vector in crystal coordinates, this subroutine !     finds the index iG to which this G vector corresponds to in the !     global list of G vectors. In other words: ! !     G = gvec(iG) ! !     If G is not found, an error is thrown. !----------------------------------------------------------------------------! use intw_reading , only : nr1 , nr2 , nr3 implicit none integer :: G ( 3 ) integer :: iG , n1 , n2 , n3 ! Find the FFT G vector corresponding to G n1 = modulo ( G ( 1 ), nr1 ) + 1 n2 = modulo ( G ( 2 ), nr2 ) + 1 n3 = modulo ( G ( 3 ), nr3 ) + 1 ! use the tabulated values to find iG iG = g_fft_map ( n1 , n2 , n3 ) end subroutine find_iG subroutine coarse_to_smooth ( n1 , n2 , n3 , FR_coarse , n1s , n2s , n3s , FR_smooth ) !------------------------------------------- ! This subroutine puts the coarse force ! constants in the smooth force constant ! array ! NOTE: (Haritz 03/09/2025): This subroutine is not used and has not been tested !------------------------------------------- use intw_useful_constants , only : cmplx_0 implicit none ! input/output variables integer , intent ( in ) :: n1 , n2 , n3 , n1s , n2s , n3s complex ( dp ), intent ( in ) :: FR_coarse ( n1 , n2 , n3 ) complex ( dp ), intent ( out ) :: FR_smooth ( n1s , n2s , n3s ) ! local variables integer :: i1 , i2 , i3 , i1s , i2s , i3s ! local variables FR_smooth (:,:,:) = cmplx_0 do i1 = 1 , n1 if ( i1 <= n1 / 2 ) then i1s = i1 else i1s = n1s - n1 + i1 end if do i2 = 1 , n2 if ( i2 <= n2 / 2 ) then i2s = i2 else i2s = n2s - n2 + i2 end if do i3 = 1 , n3 if ( i3 <= n3 / 2 ) then i3s = i3 else i3s = n3s - n3 + i3 end if FR_smooth ( i1s , i2s , i3s ) = FR_coarse ( i1 , i2 , i3 ) end do end do end do end subroutine coarse_to_smooth end module intw_fft","tags":"","url":"sourcefile/fft.f90.html"},{"title":"reading.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_reading !! display: none !! !! This module contains variables and subroutines for reading and !! managing input data from DFT calculations. !! use kinds , only : dp implicit none save ! variables public :: alat , tpiba , tpiba2 , at , volume0 , bg , & ntyp , atom_labels , amass , atom_pfile , & nat , tau , tau_cryst , ityp , & nsym , s , ftau , TR , & nkpoints_QE , kpoints_QE , & nbands , num_bands_intw , num_wann_intw , & num_exclude_bands_intw , band_excluded_intw , & nspin , lspin , lspinorb , lmag , & nr1 , nr2 , nr3 , ecutwfc , ecutrho , & nG , gvec , nGk_max , gamma_only ! subroutines public :: read_parameters_data_file , & read_kpoints_data_file , & get_gvec , & get_K_folder_data , & deallocate_reading_variables , & set_num_bands , & scan_file_to private !==================================! ! unit cell variables              ! ! system / configuration variables ! !==================================! real ( dp ) :: alat !! The lattice parameter TODOD: Units real ( dp ) :: tpiba !! tpi/alat real ( dp ) :: tpiba2 !! tpiba**2 real ( dp ) :: at ( 3 , 3 ) !! The a1 a2 and a3 lattice vectors column wise TODO: Units real ( dp ) :: volume0 !! The volume of the unit cell TODO: units real ( dp ) :: bg ( 3 , 3 ) !! The reciprocal lattice vectors column wise TODO: units integer :: ntyp !! The number types of atoms in the cell character ( len = 3 ), allocatable :: atom_labels (:) !! atom_label( j ) = name of the j-th atomic type (or species) real ( dp ), allocatable :: amass (:) !! amass(1:ntyp) = atomic masses TODOD: units character ( len = 80 ), allocatable :: atom_pfile (:) !! atom_pfile( j ) = name of pseudopotential file for !! the j-th atomic type (or species) integer :: nat !! The number of atoms in the cell real ( dp ), allocatable :: tau (:, :) !! tau( 1:3, i ) = position of the i-th atom (in cartesian, alat units) real ( dp ), allocatable :: tau_cryst (:, :) !! tau( 1:3, i ) = position of the i-th atom (in Crystal units) integer , allocatable :: ityp (:) !! ityp( i ) = type of the i-th atom !====================! ! Symmetry variables ! !====================! integer :: nsym !! Number of crystal symmetries integer , allocatable :: s (:, :, :) !! Symmetry matrices, in crystal coordinates, !! CAREFUL!!! since the symmetry matrices are expressed !! in the crystal coordinates, they may not *look* like !! rotation matrices: convert to cartesian coordinates !! and they'll have a sensible form. real ( dp ), allocatable :: ftau (:, :) !! Fractional translations, in crystal coordinates. logical , allocatable :: TR (:) !! This array indicates if TR can (should) be used !! with a given point group operation. TR is optional !! if the ground state is not magnetically polarized, but !! can become mandatory; for a magnetic ground state, !! certain rotations can only be permitted in conjunction !! with time reversal symmetry (ie: the rotation flips B, and !! TR flips it back). This array will take note of !! which point group symmetries require TR. !===================! ! k-point variables ! !===================! integer :: nkpoints_QE !! Number of k points used in the DFT calculation real ( dp ), allocatable :: kpoints_QE (:, :) !! The kpoints used in the DFT calculation TODO: crystal or Cartesian? !=================! ! Bands variables ! !=================! integer :: nbands !! The number of bands computed in the DFT calculation ! JLB: These are not read from the DFT calculation, but I think it's cleanest to put them here. !      They are set in the subroutine \"set_num_bands\" in this module. !      To be discussed. integer :: num_bands_intw !! Number of bands forming the subspace from which Wannier functions are to be obtained !! Might be different from nbands if exclude_bands is used integer :: num_wann_intw !! Number of Wannier functions, or equivalently bands/KS states to be interpolated !! Might be different from num_bands_intw if disentanglement is used integer :: num_exclude_bands_intw !! Number of bands to be excluded logical , allocatable :: band_excluded_intw (:) !! Array determining the bands to be excluded !================! ! Spin variables ! !================! integer :: nspin !! nspin = 1 for non-polarized calculations, nspin = 2 for spin-polarized ones. !! NOTE: Colinear spin-polarized calculations are transformed to a non-colinear !!       spinor format by pw2intw or siesta2intw. logical :: lspin !! If a spin-polarized calculation (colinear or non-collinear) lspin = T logical :: lspinorb !! If spin-orbit non-collinear calculation lspinorb = T logical :: lmag !! If the calculation is magnetic (time-reversal broken) lmag = T !! NOTE: In QE, if the system has TR symmetry (no magnetization), !!       only one spin component of the induced potential is calculated !!       and saved to the file, even if the calculation is non-collinear. !=======================! ! Plane-waves variables ! !=======================! integer :: nr1 , nr2 , nr3 !! The FFT grid real ( dp ) :: ecutwfc !! Cutoff energy for wave functions (Rydberg) real ( dp ) :: ecutrho !! Cutoff energy for charge density (Rydberg) integer :: nG !! The number of g vectors integer , allocatable :: gvec (:, :) !! The global g vectors (to which indices refer). TODO: crystal or Cartesian? integer :: nGk_max !! The maximum number of G vectors for any k point logical :: gamma_only !! If Gamma is the only k-point and Gamma only tricks are used (half of the G-vectors are used) !! gamma_only = .true. contains subroutine read_parameters_data_file () !------------------------------------------------------------------ ! This subroutine reads in atomic positions and composition, symmetries ! and all data from the prefix.save.intw/crystal.dat file. !------------------------------------------------------------------ use intw_input_parameters , only : outdir , prefix , TR_symmetry use intw_utility , only : find_free_unit use intw_matrix_vector , only : ainv use intw_useful_constants , only : tpi implicit none integer :: io_unit , ierr ! input/output variables integer :: i , j , ii ! loop variables character ( len = 256 ) :: dummy character ( 256 ) :: datafile ! variables for the magnetic case. integer :: max_nsym ! maximum possible value of nsym. Relevant integer :: i_sym integer , allocatable , dimension (:, :, :) :: ss real ( dp ), allocatable , dimension (:, :) :: fftau integer , allocatable , dimension (:) :: trev ! Read the data related to the crystal structure datafile = trim ( trim ( outdir ) // trim ( prefix ) // \".save.intw/\" // \"crystal.dat\" ) io_unit = find_free_unit () open ( unit = io_unit , file = datafile , status = \"unknown\" , action = \"read\" , form = \"formatted\" , iostat = ierr ) if ( ierr /= 0 ) stop \"ERROR: read_parameters_data_file: Error opening crystal.dat file!\" !ALAT read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) alat !AT read ( unit = io_unit , fmt =* ) dummy do i = 1 , 3 read ( unit = io_unit , fmt =* ) ( at ( i , j ), j = 1 , 3 ) enddo !BG read ( unit = io_unit , fmt =* ) dummy do i = 1 , 3 read ( unit = io_unit , fmt =* ) ( bg ( i , j ), j = 1 , 3 ) enddo !NTYP read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) ntyp allocate ( atom_labels ( ntyp )) allocate ( atom_pfile ( ntyp )) allocate ( amass ( ntyp )) !ATOM LABELS and PP files read ( unit = io_unit , fmt =* ) dummy do i = 1 , ntyp read ( unit = io_unit , fmt =* ) atom_labels ( i ), amass ( i ), atom_pfile ( i ) end do !NAT read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) nat allocate ( ityp ( nat )) allocate ( tau ( 3 , nat )) allocate ( tau_cryst ( 3 , nat )) !POSITIONS read ( unit = io_unit , fmt =* ) dummy do i = 1 , nat read ( unit = io_unit , fmt =* ) dummy , ityp ( i ), tau (:, i ) tau_cryst (:, i ) = matmul ( ainv ( at ), tau (:, i )) end do !NSYM read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) nsym allocate ( ss ( 3 , 3 , nsym )) allocate ( fftau ( 3 , nsym )) allocate ( trev ( nsym )) !SYM do ii = 1 , nsym read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) i_sym do i = 1 , 3 read ( unit = io_unit , fmt =* ) ( ss ( i , j , ii ), j = 1 , 3 ) enddo read ( unit = io_unit , fmt =* ) ( fftau ( j , ii ), j = 1 , 3 ) read ( unit = io_unit , fmt =* ) trev ( ii ) end do !ii !LSPIN read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) lspin !LSPINORB read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) lspinorb !LMAG read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) lmag if ( lspin ) then nspin = 2 else nspin = 1 end if !NKS read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) nkpoints_QE !NBAND read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) nbands !FFT GRID NR1 NR2 NR3 read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) nr1 , nr2 , nr3 !ECUTWFC read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) ecutwfc !ECUTRHO read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) ecutrho !NG read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) nG !NGK_MAX read ( unit = io_unit , fmt =* ) dummy read ( unit = io_unit , fmt =* ) nGk_max close ( unit = io_unit ) ! Set some variables tpiba = tpi / alat tpiba2 = tpiba * tpiba volume0 = alat ** 3 * abs ( at ( 1 , 1 ) * ( at ( 2 , 2 ) * at ( 3 , 3 ) - at ( 2 , 3 ) * at ( 3 , 2 )) + & at ( 1 , 2 ) * ( at ( 2 , 3 ) * at ( 3 , 1 ) - at ( 2 , 1 ) * at ( 3 , 3 )) + & at ( 1 , 3 ) * ( at ( 2 , 1 ) * at ( 3 , 2 ) - at ( 2 , 2 ) * at ( 3 , 1 )) ) ! Remove symmetry opreations that are not wanted if ( lmag ) then ! Count valid symmetries max_nsym = nsym nsym = 0 do ii = 1 , max_nsym if ( trev ( ii ) == 0 . or . TR_symmetry ) nsym = nsym + 1 end do allocate ( s ( 3 , 3 , nsym )) allocate ( ftau ( 3 , nsym )) allocate ( TR ( nsym )) ! Select only valid symmetries i_sym = 0 do ii = 1 , max_nsym if ( trev ( ii ) == 0 . or . TR_symmetry ) then i_sym = i_sym + 1 s (:, :, i_sym ) = ss (:, :, ii ) ftau (:, i_sym ) = fftau (:, ii ) TR ( i_sym ) = trev ( ii ) == 1 endif end do else ! This is the easy case. Simply read in the symmetries allocate ( s ( 3 , 3 , nsym )) allocate ( ftau ( 3 , nsym )) allocate ( TR ( nsym )) s = ss ftau = fftau TR = TR_symmetry ! If .not. lmag trev does not mean anything, it is allways 0 end if deallocate ( ss ) deallocate ( fftau ) deallocate ( trev ) end subroutine read_parameters_data_file subroutine read_kpoints_data_file ( kpoints_cryst ) !------------------------------------------------------------------------ ! This subroutine reads the prefix.save.intw/kpoints.dat file. ! The k-points are read in cartesian 2pi/a units: they will be converted ! to the more convenient crystal units !------------------------------------------------------------------------ use intw_input_parameters , only : outdir , prefix use intw_utility , only : find_free_unit use intw_matrix_vector , only : ainv implicit none integer :: io_unit character ( 256 ) :: datafile real ( dp ) :: k ( 3 ), kpoints_cryst ( 3 , nkpoints_QE ) integer :: i datafile = trim ( trim ( outdir ) // trim ( prefix ) // \".save.intw/\" // \"kpoints.dat\" ) io_unit = find_free_unit () open ( unit = io_unit , file = datafile , status = \"unknown\" , action = \"read\" , form = \"formatted\" ) do i = 1 , nkpoints_QE read ( unit = io_unit , fmt =* ) k ( 1 : 3 ) kpoints_cryst (:, i ) = matmul ( ainv ( bg ), k ) end do close ( unit = io_unit ) end subroutine read_kpoints_data_file subroutine get_gvec () !------------------------------------------------------------------------ ! TODO: Add description !------------------------------------------------------------------------ use intw_input_parameters , only : outdir , prefix use intw_utility , only : find_free_unit implicit none integer :: io_unit character ( 256 ) :: datafile integer :: ig , nG_read datafile = trim ( trim ( outdir ) // trim ( prefix ) // \".save.intw/\" // \"gvectors.dat\" ) io_unit = find_free_unit () open ( unit = io_unit , file = datafile , status = \"unknown\" , action = \"read\" , form = \"unformatted\" ) read ( unit = io_unit ) nG_read if ( nG /= nG_read ) stop \"ERROR: get_gvec: Wrong number of G vectors!\" allocate ( gvec ( 3 , nG )) do ig = 1 , nG read ( unit = io_unit ) gvec ( 1 : 3 , ig ) end do close ( unit = io_unit ) end subroutine get_gvec subroutine get_K_folder_data ( ik , list_iG , wfc , eig , nGk , altprefix ) !------------------------------------------------------------------------ ! For the kpoint labeled by ik, this subroutine reads all the ! wave functions for bands 1, .., nbands and stores them in the array ! wfc(nGk_max, nbands). It reads the G vectors index array list_iG, ! which refers to the global list of G vectors gvecs. It also reads ! the eigenvalues. ! ! Do not be confused! G means \"reciprocal lattice vector\". !                     K means \"point in the 1BZ\" ! ! NOTE: In fortran, \"the first index varies fastest\". I take this to mean ! that arrays are stored column-wise, namely, for a matrix ! ! M = [ m_{11}   m_{12}   m_{13} ] !     [ m_{21}   m_{22}   m_{23} ] !     [ m_{31}   m_{32}   m_{33} ] ! ! m_{21} is closer in memory to m_{11} than m_{12}, and in fact ! M is stored as ! M ~ [ m_{11} m_{21} m_{31} m_{12} m_{22} m_{32} m_{13} m_{23} m_{33}] ! Thus, it makes GOOD SENSE to put the G index first, as this is ! the index that will be used to perform inner products. ! ! JLB: Excluded bands are taken care for at this point. !      Only relevant \"num_bands_intw\" wave functions are stored on output. !      This subroutine is only called in symmetries.f90, !      where only the wfc-s within \"num_bands_intw\" are rotated. !------------------------------------------------------------------------ use intw_input_parameters , only : outdir , prefix use intw_utility , only : find_free_unit use intw_useful_constants , only : ZERO , cmplx_0 implicit none !I/O variables integer , intent ( in ) :: ik integer , intent ( out ) :: list_iG ( nGk_max ) real ( dp ), intent ( out ) :: eig ( num_bands_intw ) complex ( dp ), intent ( out ) :: wfc ( nGk_max , num_bands_intw , nspin ) integer , intent ( out ) :: nGk character ( 256 ), optional , intent ( in ) :: altprefix !logical variables character ( 256 ) :: wfc_file , datafile integer :: io_unit , ibnd , is , n_yes real ( dp ) :: eig_all ( nbands ) ! ! Initialize the arrays to zero (zero will be broadcasted) list_iG (:) = 0 wfc (:, :, :) = cmplx_0 eig (:) = ZERO ! write ( wfc_file , 100 ) ik 100 format ( 'wfc' , I5 . 5 , '.dat' ) ! if ( present ( altprefix )) then datafile = trim ( trim ( outdir ) // trim ( altprefix ) // \".save.intw/\" // trim ( wfc_file )) else datafile = trim ( trim ( outdir ) // trim ( prefix ) // \".save.intw/\" // trim ( wfc_file )) end if io_unit = find_free_unit () open ( unit = io_unit , file = datafile , status = \"unknown\" , action = \"read\" , form = \"unformatted\" ) ! ! Read data read ( unit = io_unit ) nGk ! read ( unit = io_unit ) list_iG ( 1 : nGk ) ! read ( unit = io_unit ) eig_all ( 1 : nbands ) ! n_yes = 0 do ibnd = 1 , nbands ! if ( band_excluded_intw ( ibnd )) then read ( unit = io_unit ) else n_yes = n_yes + 1 read ( unit = io_unit ) ( wfc ( 1 : nGk , n_yes , is ), is = 1 , nspin ) eig ( n_yes ) = eig_all ( ibnd ) endif ! enddo ! close ( io_unit ) end subroutine get_K_folder_data subroutine deallocate_reading_variables () !------------------------------------------------------------------------ ! TODO: Add description !------------------------------------------------------------------------ deallocate ( atom_labels ) deallocate ( atom_pfile ) deallocate ( amass ) deallocate ( ityp ) deallocate ( tau ) deallocate ( s ) deallocate ( ftau ) ! JLB: Not sure whether this should go somewhere else if ( allocated ( band_excluded_intw )) deallocate ( band_excluded_intw ) end subroutine deallocate_reading_variables subroutine scan_file_to ( nnkp_unit , keyword ) !---------------------------------------------------------------------- ! This subroutine reads a file all the way to the line !            begin $keyword ! This is useful when extracting parameters from the ascii file $seed.nnkp. ! ! JLB 07/2023: Moved this subroutine here from intw2wannier.f90 !---------------------------------------------------------------------- implicit none integer , intent ( in ) :: nnkp_unit character ( len =* ), intent ( in ) :: keyword character ( len = 256 ) :: word1 , word2 logical :: found , test integer :: ios found = . false . ! do ! read ( nnkp_unit , * , iostat = ios ) word1 , word2 ! test = ( trim ( word1 ). eq . 'begin' ) . and . ( trim ( word2 ). eq . keyword ) ! if ( test ) exit ! if ( ios /= 0 ) then ! write ( * , * ) keyword , \" data-block missing\" stop ! endif ! enddo end subroutine scan_file_to subroutine set_num_bands () !---------------------------------------------------------------------- ! This subroutine sets the sizes of the different band subspaces. ! Very important for all subsequent calculations, ! should be called at the beginning of all utilities. ! ! For the moment it detects whether a .nnkp file exists, ! and in that case it reads them from there. ! If there's no such file, the number of bands is set to nbands ! (the number of bands in the DFT calculation). ! JLB: I think it would be useful to add the option to set them on input. ! ! WARNING: This subroutine must always be called after \"read_parameters_data_file\" !          so that nbands is set. ! ! MBR 20/05/2024: three options for exclude_bands !------------------------------------------------------------------------ use intw_utility , only : find_free_unit use intw_input_parameters , only : prefix , use_exclude_bands , & include_bands_initial , include_bands_final implicit none character ( len = 256 ) :: nnkp_filename logical :: have_nnkp integer :: nnkp_unit , i , nn ! Check if .nnkp file exists nnkp_filename = trim ( prefix ) // trim ( '.nnkp' ) inquire ( file = nnkp_filename , exist = have_nnkp ) ! control consistency with use_exclude_bands flag if ( have_nnkp . and . trim ( use_exclude_bands ) . eq . 'none' ) then write ( * , '(A)' ) '| - use_exclude_bands = none in input but           |' write ( * , '(A)' ) '| - .nnkp file found. Inconsistency!!               |' write ( * , '(A)' ) ' Stopping ' stop else if ( have_nnkp . and . trim ( use_exclude_bands ) . eq . 'custom' ) then write ( * , '(A)' ) '| - use_exclude_bands = custom in input but         |' write ( * , '(A)' ) '| - .nnkp file found. Inconsistency!!               |' write ( * , '(A)' ) ' Stopping ' stop else if ( . not . have_nnkp . and . trim ( use_exclude_bands ) . eq . 'wannier' ) then write ( * , '(A)' ) '| - use_exclude_bands = wannier in input but        |' write ( * , '(A)' ) '| - .nnkp file not found. Inconsistency!!           |' write ( * , '(A)' ) ' Stopping ' stop end if ! Set number of bands ! from .nnkp if ( trim ( use_exclude_bands ) . eq . 'wannier' ) then ! write ( * , '(A)' ) '| - .nnkp file found                                |' write ( * , '(A)' ) '| - Setting number of bands from .nnkp              |' write ( * , '(A)' ) '|           ---------------------------------       |' ! nnkp_unit = find_free_unit () open ( unit = nnkp_unit , file = nnkp_filename , status = 'old' ) ! ! Number of wannier functions (after disentanglement) ! must be the same as number of projections if ( lspin ) then call scan_file_to ( nnkp_unit , 'spinor_projections' ) read ( nnkp_unit , * ) num_wann_intw else call scan_file_to ( nnkp_unit , 'projections' ) read ( nnkp_unit , * ) num_wann_intw end if ! ! Excluded bands, if any call scan_file_to ( nnkp_unit , 'exclude_bands ' ) read ( nnkp_unit , * ) num_exclude_bands_intw allocate ( band_excluded_intw ( nbands )) band_excluded_intw (:) = . false . do i = 1 , num_exclude_bands_intw read ( nnkp_unit , * ) nn band_excluded_intw ( nn ) = . true . enddo ! close ( nnkp_unit ) ! ! Number of bands (before disentanglement) num_bands_intw = nbands - num_exclude_bands_intw ! ! all bands from DFT else if ( trim ( use_exclude_bands ) . eq . 'none' ) then write ( * , '(A)' ) '| - Setting number of bands from calculation        |' write ( * , '(A)' ) '|           ---------------------------------       |' ! allocate ( band_excluded_intw ( nbands )) band_excluded_intw (:) = . false . num_bands_intw = nbands num_wann_intw = nbands ! ! custom bands from input else if ( trim ( use_exclude_bands ) . eq . 'custom' ) then write ( * , '(A)' ) '| - Setting custom number of bands:                 |' write ( * , '(A9,I4,A4,I4,31X,A1)' ) '|   From ' , include_bands_initial , ' to ' , include_bands_final , '|' write ( * , '(A)' ) '|           ---------------------------------       |' allocate ( band_excluded_intw ( nbands )) num_bands_intw = include_bands_final - include_bands_initial + 1 num_wann_intw = num_bands_intw num_exclude_bands_intw = nbands - num_bands_intw band_excluded_intw (:) = . true . do i = include_bands_initial , include_bands_final band_excluded_intw ( i ) = . false . end do ! end if end subroutine end module intw_reading","tags":"","url":"sourcefile/reading.f90.html"},{"title":"ph_interpolate.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_ph_interpolate !! display: none !! !! This module contains the necessary tools for interpolating phonons. !! !! ### Details !! !! So far, it contains routines to generate Wigner-Seitz real meshes, !! Fourier transforms of the dynamical matrix, interpolation at a given q-point. !! !! Those tools are similar to some routines in w90_setup, which have been !! adapted here for phonon meshes. !! !! MBR 24/01/24 !! use kinds , only : dp implicit none ! ! variables public :: n_wss_q , n_ws_search_q public :: irvec_q , nrpts_q , ndegen_q public :: irvec_qtau , nrpts_qtau , ndegen_qtau , nrpts_qtau12 public :: dyn_q , dyn_r public :: w2_q , u_q ! ! subroutines public :: allocate_and_build_ws_irvec_q , allocate_and_build_ws_irvec_qtau , & allocate_and_build_dyn_qmesh , allocate_and_build_dyn_qmesh_from_fc , & dyn_q_to_dyn_r , dyn_interp_1q , dyn_diagonalize_1q , interpolated_phonon_DOS , & wann_IFT_1index_q ! private ! save ! ! these will substitute w90_hamiltonian: irvec, nrpts, ndegen integer :: nrpts_q integer , allocatable :: ndegen_q (:), irvec_q (:,:) ! as above, but corrected with atom positions integer :: nrpts_qtau integer , allocatable :: ndegen_qtau (:,:,:), irvec_qtau (:,:,:,:), nrpts_qtau12 (:,:) ! search space for WS vectors integer , parameter :: n_wss_q = 27 ! TODO give somewhere as input integer , dimension ( 3 ) , parameter :: n_ws_search_q = ( / 1 , 1 , 1 / ) ! TODO give somewhere as input ! dynamical matrix in qmesh and real space (WS vectors) complex ( kind = dp ), allocatable :: dyn_q (:,:,:), dyn_r (:,:,:) ! omega&#94;q and eigenvectors in qmesh real ( kind = dp ), allocatable :: w2_q (:,:) complex ( kind = dp ), allocatable :: u_q (:,:,:) ! in a.u. (without the mass factor) ! ! contains subroutine allocate_and_build_ws_irvec_q () !NEW VERSION !  Calculate real-space Wigner-Seitz lattice vectors for phonon grid. !  Similar to w90_setup allocate_and_build_ws_irvec routine. !----------------------------------------------------------------------------! use intw_reading , only : at , alat use intw_useful_constants , only : eps_8 use intw_utility , only : cryst_to_cart use intw_input_parameters , only : nq1 , nq2 , nq3 use intw_ph , only : qmesh ! implicit none ! integer :: iq , i , j , k , l , l0 , l1 , nboundary logical :: in_ws integer :: Rs ( 3 , n_wss_q ), r_cryst_int ( 3 ), ndegen_ws ( nq1 * nq2 * nq3 * n_wss_q ), irvec_ws ( 3 , nq1 * nq2 * nq3 * n_wss_q ) real ( kind = dp ) :: r_cryst ( 3 ), r_length_l , r_length_l1 , r_cart ( 3 ) ! ! generate superlattice replica vectors search mesh l = 0 do i = - n_ws_search_q ( 1 ), n_ws_search_q ( 1 ) do j = - n_ws_search_q ( 2 ), n_ws_search_q ( 2 ) do k = - n_ws_search_q ( 3 ), n_ws_search_q ( 3 ) l = l + 1 Rs (:, l ) = ( / i , j , k / ) if ( i == 0 . and . j == 0 . and . k == 0 ) l0 = l ! Origin O end do end do end do ! nrpts_q = 0 ! total number of WS vectors do iq = 1 , nq1 * nq2 * nq3 ! do l = 1 , n_wss_q ! r-R(l), where for r-supercell-vector I use a conventional cell mesh of size nq1, nq2, nq3 ! and R(l) runs over replicas r_cryst = ( qmesh (:, iq ) - real ( Rs (:, l ), dp ) ) * real ( ( / nq1 , nq2 , nq3 / ), dp ) r_cryst_int = nint ( r_cryst ) !R-vector from crystallographic to cartesian r_cart = r_cryst call cryst_to_cart ( 1 , r_cart , at , 1 ) r_length_l = alat * sqrt ( sum ( r_cart * r_cart ) ) ! distance of r-R(l) to O (cartesian, bohr) ! ! r-R(l) is in the WS if its distance to O is shorter than its ! distance to any other O' origin. ! If it is equidistant, it lies on the boundary and is degenerate. in_ws = . true . nboundary = 1 ! ! Loop over origins O' given by R(l1) do l1 = 1 , n_wss_q ! r-R(l)-R(l1) r_cryst = ( qmesh (:, iq ) - real ( Rs (:, l ) + Rs (:, l1 ), dp ) ) * real ( ( / nq1 , nq2 , nq3 / ), dp ) r_cart = r_cryst call cryst_to_cart ( 1 , r_cart , at , 1 ) r_length_l1 = alat * sqrt ( sum ( r_cart * r_cart ) ) ! distance of r-R(l) to O' (cartesian, bohr) ! compare distances leaving a gap eps_8 ! TODO: put tolerance as parameter. It depends a lot on this! ! I guess that we need a smaller one the less nq... if ( r_length_l > r_length_l1 + eps_8 * 100 0. . and . l1 /= l0 ) then ! not in the WS => remove vector from list in_ws = . false . exit else if ( abs ( r_length_l - r_length_l1 ) <= eps_8 * 100 0. . and . l1 /= l0 ) then ! on the boundary => add degeneracy nboundary = nboundary + 1 end if end do ! ! store r-R(l) and its degeneracy if it is inside WS if ( in_ws ) then nrpts_q = nrpts_q + 1 irvec_ws (:, nrpts_q ) = r_cryst_int ndegen_ws ( nrpts_q ) = nboundary end if ! end do end do ! iq ! ! Data for Wannier: WS kpoint list and degeneracies. ! Simply dismiss the array at sites >nrpts, which have not been used allocate ( irvec_q ( 3 , nrpts_q ) ) allocate ( ndegen_q ( nrpts_q ) ) ndegen_q = ndegen_ws ( 1 : nrpts_q ) do i = 1 , 3 irvec_q ( i ,:) = irvec_ws ( i , 1 : nrpts_q ) end do end subroutine allocate_and_build_ws_irvec_q subroutine allocate_and_build_ws_irvec_qtau () !NEW VERSION !  Calculate real-space Wigner-Seitz lattice vectors for phonon grid. !  Similar to w90_setup allocate_and_build_ws_irvec routine. !  Unlike the allocate_and_build_ws_irvec_q version, here we choose as WS !  criterion that, for each tau1,tau2 atom pair, the WS cell is centered at tau1. !  So, we impose the truncation using R+tau2-tau1, !  as in S. Poncé et al, Phys. Rev. Research 3, 043022 (2021)  (appendix D) !  and  G. Pizzi et al, J. Phys.: Condens. Matter 32 165902 (2020) (section 4.2). !----------------------------------------------------------------------------! use intw_reading , only : at , alat , nat , tau_cryst use intw_useful_constants , only : eps_8 use intw_utility , only : cryst_to_cart use intw_input_parameters , only : nq1 , nq2 , nq3 use intw_ph , only : qmesh ! implicit none ! integer :: iq , i , j , k , l , l0 , l1 , nboundary , iat1 , iat2 , nws logical :: in_ws integer :: Rs ( 3 , n_wss_q ), r_cryst_int ( 3 ), ndegen_ws ( nq1 * nq2 * nq3 * n_wss_q , nat , nat ), irvec_ws ( 3 , nq1 * nq2 * nq3 * n_wss_q , nat , nat ) real ( kind = dp ) :: r_cryst ( 3 ), r_length_l , r_length_l1 , r_cart ( 3 ) irvec_ws = 0 ! ! generate superlattice replica vectors search mesh l = 0 do i = - n_ws_search_q ( 1 ), n_ws_search_q ( 1 ) do j = - n_ws_search_q ( 2 ), n_ws_search_q ( 2 ) do k = - n_ws_search_q ( 3 ), n_ws_search_q ( 3 ) l = l + 1 Rs (:, l ) = ( / i , j , k / ) if ( i == 0 . and . j == 0 . and . k == 0 ) l0 = l ! Origin O end do end do end do ! nrpts_q = 0 ! allocate ( nrpts_qtau12 ( nat , nat ) ) nrpts_qtau12 = 0 ! do iat1 = 1 , nat do iat2 = 1 , nat nws = 0 ! total number of WS vectors for this atoms pair do iq = 1 , nq1 * nq2 * nq3 ! do l = 1 , n_wss_q ! r-R(l), where for r-supercell-vector I use a conventional cell mesh of size nq1, nq2, nq3 ! and R(l) runs over replicas r_cryst = ( qmesh (:, iq ) - real ( Rs (:, l ), dp ) ) * real ( ( / nq1 , nq2 , nq3 / ), dp ) r_cryst_int = nint ( r_cryst ) r_cart = r_cryst + tau_cryst (:, iat2 ) - tau_cryst (:, iat1 ) ! add interatomic distance criterion (O is at iat1 position) !R-vector from crystallographic to cartesian call cryst_to_cart ( 1 , r_cart , at , 1 ) r_length_l = alat * sqrt ( sum ( r_cart * r_cart ) ) ! distance of r-R(l) to O  (cartesian, bohr) ! ! r-R(l) is in the WS if its distance to O is shorter than its ! distance to any other O' origin. ! If it is equidistant, it lies on the boundary and is degenerate. in_ws = . true . nboundary = 1 ! ! Loop over origins O' given by R(l1) do l1 = 1 , n_wss_q ! r-R(l)-R(l1) r_cryst = ( qmesh (:, iq ) - real ( Rs (:, l ) + Rs (:, l1 ), dp ) ) * real ( ( / nq1 , nq2 , nq3 / ), dp ) r_cart = r_cryst + tau_cryst (:, iat2 ) - tau_cryst (:, iat1 ) ! add interatomic distance to distance criterion (O' is at l1+iat1 position) call cryst_to_cart ( 1 , r_cart , at , 1 ) r_length_l1 = alat * sqrt ( sum ( r_cart * r_cart ) ) ! distance of r-R(l) to O' (cartesian, bohr) ! compare distances leaving a gap eps_8*1000. ! TODO: put tolerance as parameter. It depends a lot on this! ! I guess that we need a smaller one the less nq... if ( r_length_l > r_length_l1 + eps_8 * 100 0. . and . l1 /= l0 ) then ! not in the WS => remove vector from list in_ws = . false . exit else if ( abs ( r_length_l - r_length_l1 ) <= eps_8 * 100 0. . and . l1 /= l0 ) then ! on the boundary => add degeneracy nboundary = nboundary + 1 end if end do ! ! store r-R(l) and its degeneracy if it is inside WS if ( in_ws ) then nws = nws + 1 irvec_ws (:, nws , iat1 , iat2 ) = r_cryst_int ndegen_ws ( nws , iat1 , iat2 ) = nboundary end if ! end do ! l end do ! iq ! nrpts_qtau12 ( iat1 , iat2 ) = nws ! end do !iat2 end do !iat1 ! ! max. number of WS vectors among all pairs is used as irvec_q array dimension nrpts_qtau = maxval ( nrpts_qtau12 ) ! ! Data for Wannier: WS kpoint list and degeneracies. ! Simply dismiss the array at sites >nrpts, which have not been used allocate ( irvec_qtau ( 3 , nrpts_qtau , nat , nat ) ) allocate ( ndegen_qtau ( nrpts_qtau , nat , nat ) ) ndegen_qtau = 0 irvec_qtau = 0 do iat1 = 1 , nat do iat2 = 1 , nat nws = nrpts_qtau12 ( iat1 , iat2 ) ndegen_qtau ( 1 : nws , iat1 , iat2 ) = ndegen_ws ( 1 : nws , iat1 , iat2 ) do i = 1 , 3 irvec_qtau ( i , 1 : nws , iat1 , iat2 ) = irvec_ws ( i , 1 : nws , iat1 , iat2 ) end do end do end do ! ! print*, '#max nrpts_q = ',  nrpts_qtau12 ! write(*,'(A19,I6,27X,A1)') '|   #max nrpts_q = ', nrpts_qtau, '|' end subroutine allocate_and_build_ws_irvec_qtau subroutine allocate_and_build_dyn_qmesh () ! Read the dynamical matrices and compute eiegnvectors and omega&#94;2 on the full qmesh !---------------------------------------------------------------------------- use intw_useful_constants , only : cmplx_0 , cmplx_i , tpi use intw_reading , only : nat use intw_ph , only : nqmesh , qmesh , read_dynq ! implicit none ! integer :: iq real ( dp ) :: qpoint ( 3 ) ! ! ! allocate and calculate dynmat at qmesh allocate ( dyn_q ( 3 * nat , 3 * nat , nqmesh ), w2_q ( 3 * nat , nqmesh ), u_q ( 3 * nat , 3 * nat , nqmesh ) ) ! ! read dynmat call read_dynq ( dyn_q ) ! ! diagonalize do iq = 1 , nqmesh qpoint = qmesh (:, iq ) call dyn_diagonalize_1q ( 3 * nat , dyn_q (:,:, iq ), u_q (:,:, iq ), w2_q (:, iq )) end do end subroutine allocate_and_build_dyn_qmesh subroutine allocate_and_build_dyn_qmesh_from_fc ( fcfile ) ! Same as but read force constants and then compute dynamical matrices !---------------------------------------------------------------------------- use intw_useful_constants , only : cmplx_0 , cmplx_i , tpi use intw_input_parameters , only : nq1 , nq2 , nq3 use intw_reading , only : nat use intw_ph , only : nqmesh , qmesh , mat_inv_four_t , readfc ! implicit none ! character ( 256 ) , intent ( in ) :: fcfile integer :: iq real ( dp ) :: qpoint ( 3 ) complex ( dp ) :: frc ( nq1 , nq2 , nq3 , 3 , 3 , nat , nat ) ! ! ! Read the force constant matrix from the QE directory call readfc ( fcfile , frc ) ! ! allocate and calculate dynmat at qmesh allocate ( dyn_q ( 3 * nat , 3 * nat , nqmesh ), w2_q ( 3 * nat , nqmesh ), u_q ( 3 * nat , 3 * nat , nqmesh ) ) ! ! transform to dyn(q) and diagonalize do iq = 1 , nqmesh qpoint = qmesh (:, iq ) call mat_inv_four_t ( qpoint , nq1 , nq2 , nq3 , frc , dyn_q (:,:, iq )) call dyn_diagonalize_1q ( 3 * nat , dyn_q (:,:, iq ), u_q (:,:, iq ), w2_q (:, iq )) end do end subroutine allocate_and_build_dyn_qmesh_from_fc subroutine dyn_q_to_dyn_r () ! allocate_and_build_ws_irvec_qtau and allocate_and_build_dyn_qmesh must have been previously run !---------------------------------------------------------------------------- use intw_useful_constants , only : cmplx_0 , cmplx_i , tpi use intw_reading , only : nat use intw_ph , only : nqmesh , qmesh ! implicit none ! integer :: ir , iq , iat1 , iat2 complex ( kind = dp ) :: fac ! allocate ( dyn_r ( 3 * nat , 3 * nat , nrpts_qtau )) ! ! dyn_r = cmplx_0 ! do iat1 = 1 , nat do iat2 = 1 , nat do ir = 1 , nrpts_qtau12 ( iat1 , iat2 ) do iq = 1 , nqmesh fac = exp ( - cmplx_i * tpi * dot_product ( qmesh (:, iq ), irvec_qtau (:, ir , iat1 , iat2 ))) dyn_r (( iat1 - 1 ) * 3 + 1 : iat1 * 3 , ( iat2 - 1 ) * 3 + 1 : iat2 * 3 , ir ) = & dyn_r (( iat1 - 1 ) * 3 + 1 : iat1 * 3 , ( iat2 - 1 ) * 3 + 1 : iat2 * 3 , ir ) + & fac * dyn_q (( iat1 - 1 ) * 3 + 1 : iat1 * 3 , ( iat2 - 1 ) * 3 + 1 : iat2 * 3 , iq ) end do end do end do end do dyn_r = dyn_r / real ( nqmesh , dp ) end subroutine dyn_q_to_dyn_r subroutine dyn_interp_1q ( qpoint , dyn_qint ) ! allocate_and_build_ws_irvec_qtau and dyn_q_to_dyn_r must have been previously run, ! as this uses irvec_qtau and dyn_r variables. !---------------------------------------------------------------------------- use intw_useful_constants , only : cmplx_0 , cmplx_i , tpi use intw_reading , only : nat ! implicit none ! real ( dp ) , intent ( in ) :: qpoint ( 3 ) ! complex ( dp ) , intent ( out ) :: dyn_qint ( 3 * nat , 3 * nat ) ! integer :: ir , iat1 , iat2 complex ( kind = dp ) :: fac ! ! dyn_qint = cmplx_0 do iat1 = 1 , nat do iat2 = 1 , nat do ir = 1 , nrpts_qtau12 ( iat1 , iat2 ) fac = exp ( cmplx_i * tpi * dot_product ( qpoint (:), irvec_qtau (:, ir , iat1 , iat2 ))) / real ( ndegen_qtau ( ir , iat1 , iat2 ), dp ) dyn_qint (( iat1 - 1 ) * 3 + 1 : iat1 * 3 , ( iat2 - 1 ) * 3 + 1 : iat2 * 3 ) = & dyn_qint (( iat1 - 1 ) * 3 + 1 : iat1 * 3 , ( iat2 - 1 ) * 3 + 1 : iat2 * 3 ) + & fac * dyn_r (( iat1 - 1 ) * 3 + 1 : iat1 * 3 , ( iat2 - 1 ) * 3 + 1 : iat2 * 3 , ir ) end do end do end do end subroutine dyn_interp_1q subroutine dyn_diagonalize_1q ( n , dynq , uq , w2q ) ! For a given dynq at a certain qpoint, with n=3*nat, ! this subroutine is a driver for zhpevx, which returns omega&#94;2 and eigenvectors ! ! TODO this is c+p Haritz's diagonalize_cmat, which should be in intw_utilities, since it is useful !---------------------------------------------------------------------------- use intw_reading , only : nat , amass , ityp use intw_utility , only : diagonalize_cmat use intw_useful_constants , only : pmass ! implicit none ! integer , intent ( in ) :: n complex ( dp ), intent ( in ) :: dynq ( n , n ) ! Dynamical matrix in a.u. (without the mass factor) complex ( dp ), intent ( out ) :: uq ( n , n ) ! Phonon polarization vectors in a.u. real ( dp ), intent ( out ) :: w2q ( n ) ! Phonon frequencies&#94;2 in a.u. ! integer :: iat1 , iat2 ! ! ! Add mass factor do iat1 = 1 , nat do iat2 = 1 , nat ! uq ( ( iat1 - 1 ) * 3 + 1 : iat1 * 3 , ( iat2 - 1 ) * 3 + 1 : iat2 * 3 ) = dynq ( ( iat1 - 1 ) * 3 + 1 : iat1 * 3 , ( iat2 - 1 ) * 3 + 1 : iat2 * 3 ) & / sqrt ( amass ( ityp ( iat1 )) * amass ( ityp ( iat2 )) ) / pmass ! in a.u. (Hartree/Bohr&#94;2*/me = Hartree&#94;2/hbar&#94;2) ! end do end do !atoms ! ! force hermiticity uq = 0.5_dp * ( uq + transpose ( conjg ( uq )) ) ! call diagonalize_cmat ( uq , w2q ) end subroutine dyn_diagonalize_1q subroutine interpolated_phonon_DOS ( niq1 , niq2 , niq3 , eini , efin , esmear , ne , DOS ) ! !----------------------------------------------------------------------------! ! !  Calculate phonon DOS using a fine grid niq1 x niq2 x niq3 !  and a gaussian smearing. ! !----------------------------------------------------------------------------! ! use intw_reading , only : nat use intw_utility , only : smeared_delta use intw_useful_constants , only : Ha_to_Ry implicit none integer , intent ( in ) :: niq1 , niq2 , niq3 , ne real ( dp ), intent ( in ) :: eini , efin , esmear real ( dp ), intent ( out ) :: DOS ( 3 * nat , ne ) real ( dp ) :: estep , ener real ( dp ) :: qpoint ( 3 ) real ( dp ) :: w2 ( 3 * nat ), w ( 3 * nat ) complex ( dp ) :: dyn ( 3 * nat , 3 * nat ), u ( 3 * nat , 3 * nat ) integer :: iq1 , iq2 , iq3 , imode , iener estep = ( efin - eini ) / real ( ne - 1 , dp ) ! DOS = 0.0_dp ! ! Construct fine grid of qpoints, interpolate and add contribution to DOS(e) ! !$omp parallel do collapse(3) reduction(+: DOS) & !$omp default(none) & !$omp shared(niq1, niq2, niq3, nat) & !$omp shared(ne, eini, estep, esmear) & !$omp private(qpoint, dyn, u, w2, w) & !$omp private(imode, iener, ener) do iq1 = 1 , niq1 do iq2 = 1 , niq2 do iq3 = 1 , niq3 qpoint ( 1 ) = real ( iq1 - 1 , dp ) / real ( niq1 , dp ) qpoint ( 2 ) = real ( iq2 - 1 , dp ) / real ( niq2 , dp ) qpoint ( 3 ) = real ( iq3 - 1 , dp ) / real ( niq3 , dp ) ! ! Interpolate frequency in qpoint call dyn_interp_1q ( qpoint , dyn ) call dyn_diagonalize_1q ( 3 * nat , dyn , u , w2 ) ! ! Phonon frequency in Ry w = sign ( sqrt ( abs ( w2 )), w2 ) * Ha_to_Ry ! ! Smear for DOS do iener = 1 , ne ener = eini + estep * ( iener - 1 ) ! in Ry do imode = 1 , 3 * nat DOS ( imode , iener ) = DOS ( imode , iener ) + smeared_delta ( ener - w ( imode ), esmear ) ! Gaussian smearing end do end do ! end do end do end do !$omp end parallel do ! DOS = DOS / ( niq1 * niq2 * niq3 ) ! Normalize for Nq points end subroutine interpolated_phonon_DOS subroutine wann_IFT_1index_q ( nqs , qpoints , matq , matL ) ! !----------------------------------------------------------------------------! !  This does the same as wann_IFT_1index from intw_w90_setup module !  but for q !----------------------------------------------------------------------------! ! use intw_useful_constants , only : cmplx_0 , cmplx_i , tpi use intw_reading , only : num_wann_intw ! implicit none ! integer , intent ( in ) :: nqs real ( kind = dp ) , intent ( in ) :: qpoints ( 3 , nqs ) complex ( kind = dp ) , intent ( in ) :: matq ( num_wann_intw , num_wann_intw , nqs ) complex ( kind = dp ) , intent ( out ) :: matL ( num_wann_intw , num_wann_intw , nrpts_q ) ! integer :: irq , iq complex ( kind = dp ) :: fac matL = cmplx_0 do irq = 1 , nrpts_q do iq = 1 , nqs fac = exp ( - cmplx_i * tpi * dot_product ( qpoints (:, iq ), irvec_q (:, irq ))) matL (:,:, irq ) = matL (:,:, irq ) + fac * matq (:,:, iq ) end do end do matL = matL / real ( nqs , dp ) end subroutine wann_IFT_1index_q end module intw_ph_interpolate","tags":"","url":"sourcefile/ph_interpolate.f90.html"},{"title":"intw_pseudo_non_local.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_pseudo_non_local !! display: none !! !! This module contains variables and subroutines for obtaining the non-local !! part of the pseudo-potentials. !! use kinds , only : dp implicit none ! variables public :: nkb , DKB ! subroutines public :: init_KB_PP , init_KB_projectors , & multiply_psi_by_vKB , multiply_psi_by_dvKB private integer , parameter :: l_kb_max = 3 ! Max non local angular momentum (l=0 to l_kb_max) real ( kind = dp ), parameter :: dq = 0.01d0 ! Space between points in the pseudopotential tab integer :: nqx ! Number of interpolation points real ( kind = dp ), allocatable :: tab (:,:,:) ! Interpolation table for PPs real ( kind = dp ), allocatable :: tab_d2y (:,:,:) ! For cubic splines integer :: lmaxkb ! Max angular momentum of beta functions integer :: nbetam ! Max number of beta functions per atomic type integer , allocatable :: nh (:) ! Number of beta(lm) functions per atomic type integer :: nhm ! Max number of beta(lm) functions per atomic type integer , allocatable :: nhtonbeta (:,:) ! Link between index of beta(lm) function in the atomic type -> index of beta function in the atomic type integer , allocatable :: nhtol (:,:) ! Link between index of beta(lm) function in the atomic type -> angular momentum l integer , allocatable :: nhtolm (:,:) ! Link between index of beta(lm) function in the atomic type -> combined lm angular momentum index l*l+m real ( kind = dp ), allocatable :: nhtoj (:,:) ! Link between index of beta(lm) function in the atomic type -> total angular momentum j complex ( kind = dp ), allocatable :: Dion (:,:,:,:,:) ! D_{mu,nu} matrix for beta(lm) functions for each atomic type integer :: nkb ! Total number of beta(lm) functions in the solid integer , allocatable :: nkbtona (:) ! Link between index of beta(lm) function in the solid -> index of the atom complex ( kind = dp ), allocatable :: DKB (:,:,:,:) ! D_{mu,nu} matrix for beta(lm) functions in the solid contains subroutine init_KB_PP () ! ! This subroutine is based on the init_us_1 subroutine distributed as part of ! the Quantum Espresso project: !   Copyright (C) 2001-2007 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! !  Modifications by INTW group, 2024: !   - Split the subroutine in small parts that make certain tasks. !   - Remove parts related to ultrasoft pseudo potentials. !   - Calculate Dij matrix for the KB projectors of the solid. ! use intw_reading , only : nat , ntyp , ityp use intw_pseudo , only : upf use intw_useful_constants , only : cmplx_0 implicit none integer :: nt , nb , na ! ! Calculate the total number of beta(lm) projectors for each atomic type and maximum angular momentum ! if ( allocated ( nh )) deallocate ( nh ) allocate ( nh ( ntyp )) lmaxkb = - 1 do nt = 1 , ntyp ! nh ( nt ) = 0 ! do nb = 1 , upf ( nt )% nbeta nh ( nt ) = nh ( nt ) + 2 * upf ( nt )% lll ( nb ) + 1 lmaxkb = max ( lmaxkb , upf ( nt )% lll ( nb )) end do ! end do ! ! Calculate the maximum number of beta(lm) and beta functions ! nhm = maxval ( nh ) nbetam = maxval ( upf (:)% nbeta ) ! ! Calculate the number of beta(lm) functions in the solid ! nkb = 0 do na = 1 , nat nt = ityp ( na ) nkb = nkb + nh ( nt ) end do ! ! Calculate the arrays to link indices of the beta functions ! call init_KB_link_indices () ! ! Calculate Dij matrix for each atomic type ! call init_Dion () ! ! Calculate Dij matrix for the solid ! call init_DKB () ! ! Calculate interpolation table ! call init_interpolation_table () end subroutine init_KB_PP subroutine init_KB_link_indices () ! Initialize the arrays used to link the index of the beta(lm) projector for ! each atomic type with the index of the projetor of the PP file (nhtonbeta), ! with the angular momentum of the projetor (nhtol, nhtolm and nhtoj), and the ! index of the beta(lm) projector in the solid with the index of the atom (nkbtona). ! ! This subroutine is based on the init_us_1 subroutine distributed as part of ! the Quantum Espresso project: !   Copyright (C) 2001-2007 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! use intw_reading , only : ntyp , nat , ityp use intw_pseudo , only : upf implicit none !local variables integer :: nt , ih , nb , l , m , na , ikb real ( kind = dp ) :: j if ( allocated ( nhtonbeta )) deallocate ( nhtonbeta ) allocate ( nhtonbeta ( nhm , ntyp )) ! if ( allocated ( nhtol )) deallocate ( nhtol ) allocate ( nhtol ( nhm , ntyp )) ! if ( allocated ( nhtolm )) deallocate ( nhtolm ) allocate ( nhtolm ( nhm , ntyp )) ! if ( allocated ( nhtoj )) deallocate ( nhtoj ) allocate ( nhtoj ( nhm , ntyp )) ! do nt = 1 , ntyp ! ih = 1 do nb = 1 , upf ( nt )% nbeta ! l = upf ( nt )% lll ( nb ) ! do m = 1 , 2 * l + 1 ! nhtol ( ih , nt ) = l nhtolm ( ih , nt ) = l * l + m nhtonbeta ( ih , nt ) = nb ih = ih + 1 ! end do !m ! end do !nb ! if ( upf ( nt )% has_so ) then ! ih = 1 do nb = 1 , upf ( nt )% nbeta ! l = upf ( nt )% lll ( nb ) j = upf ( nt )% jjj ( nb ) ! do m = 1 , 2 * l + 1 ! nhtoj ( ih , nt ) = j ih = ih + 1 ! end do !m ! end do !nb ! end if ! end do !nt if ( allocated ( nkbtona )) deallocate ( nkbtona ) allocate ( nkbtona ( nkb )) ikb = 0 do na = 1 , nat nt = ityp ( na ) do ih = 1 , nh ( nt ) ikb = ikb + 1 nkbtona ( ikb ) = na end do !ih end do !na end subroutine init_KB_link_indices subroutine init_Dion () ! Initialize the Dion matrix for the beta(lm) projetors for all atomic types ! Dion includes the spin indices in the case of a SO calculation ! ! This subroutine is based on the init_us_1 subroutine distributed as part of ! the Quantum Espresso project: !   Copyright (C) 2001-2007 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! use intw_useful_constants , only : sqrt2 , cmplx_0 , cmplx_1 , cmplx_i use intw_reading , only : ntyp , lspinorb , nspin use intw_pseudo , only : upf implicit none complex ( kind = dp ) :: rot_ylm ( 2 * l_kb_max + 1 , 2 * l_kb_max + 1 ) ! to transform real spherical harmonics into complex ones complex ( kind = dp ), allocatable :: fcoef (:,:,:,:,:) ! needed to account for spinors integer :: n1 , n , l , m integer :: nt , ih , jh , kh , ir , is integer :: m0 , m1 , li , lk , mi , mk , vi , vj , ispin , jspin complex ( kind = dp ) :: coeff real ( kind = dp ) :: ji , jk ! ! Initialization of the variables ! if ( lspinorb ) then allocate ( Dion ( nhm , nhm , nspin , nspin , ntyp )) allocate ( fcoef ( nhm , nhm , 2 , 2 , ntyp )) else allocate ( Dion ( nhm , nhm , 1 , 1 , ntyp )) end if ! Dion = cmplx_0 ! ! the following prevents an out-of-bound error: upf(nt)%nqlc=2*lmax+1 ! but in some versions of the PP files lmax is not set to the maximum ! l of the beta functions but includes the l of the local potential ! if ( lspinorb ) then ! ! In the spin-orbit case we need the unitary matrix u which rotates the ! real spherical harmonics and yields the complex ones. ! rot_ylm = cmplx_0 l = l_kb_max rot_ylm ( l + 1 , 1 ) = cmplx_1 do n1 = 2 , 2 * l + 1 , 2 m = n1 / 2 n = l + 1 - m rot_ylm ( n , n1 ) = cmplx_1 / sqrt2 * ( - 1 ) ** m rot_ylm ( n , n1 + 1 ) = - cmplx_i / sqrt2 * ( - 1 ) ** m n = l + 1 + m rot_ylm ( n , n1 ) = cmplx_1 / sqrt2 rot_ylm ( n , n1 + 1 ) = cmplx_i / sqrt2 end do fcoef = cmplx_0 end if ! ! For each pseudopotential we initialize the indices nhtol, nhtolm, ! nhtoj, nhtonbeta, and if the pseudopotential is of KB type we initialize the ! atomic D terms ! ! ! Here we initialize the D of the solid ! do nt = 1 , ntyp ! if ( upf ( nt )% has_so . and . lspinorb ) then ! ! first calculate the fcoef coefficients ! do ih = 1 , nh ( nt ) li = nhtol ( ih , nt ) ji = nhtoj ( ih , nt ) mi = nhtolm ( ih , nt ) - li * li do kh = 1 , nh ( nt ) lk = nhtol ( kh , nt ) jk = nhtoj ( kh , nt ) mk = nhtolm ( kh , nt ) - lk * lk if ( li == lk . and . abs ( ji - jk ) < 1.d-7 ) then do ispin = 1 , 2 do jspin = 1 , 2 coeff = cmplx_0 do m = - li - 1 , li m0 = sph_ind ( li , ji , m , ispin ) + l_kb_max + 1 m1 = sph_ind ( lk , jk , m , jspin ) + l_kb_max + 1 coeff = coeff + rot_ylm ( m0 , mi ) * spinor ( li , ji , m , ispin ) & * conjg ( rot_ylm ( m1 , mk )) * spinor ( lk , jk , m , jspin ) end do fcoef ( ih , kh , ispin , jspin , nt ) = coeff end do end do end if end do end do ! ! and calculate the bare coefficients ! do ih = 1 , nh ( nt ) vi = nhtonbeta ( ih , nt ) do jh = 1 , nh ( nt ) vj = nhtonbeta ( jh , nt ) do ispin = 1 , 2 do jspin = 1 , 2 Dion ( ih , jh , ispin , jspin , nt ) = upf ( nt )% dion ( vi , vj ) * fcoef ( ih , jh , ispin , jspin , nt ) if ( vi . ne . vj ) fcoef ( ih , jh , ispin , jspin , nt ) = cmplx_0 end do end do end do end do else do ih = 1 , nh ( nt ) do jh = 1 , nh ( nt ) if ( nhtol ( ih , nt ) == nhtol ( jh , nt ) . and . nhtolm ( ih , nt ) == nhtolm ( jh , nt ) ) then ir = nhtonbeta ( ih , nt ) is = nhtonbeta ( jh , nt ) if ( lspinorb ) then Dion ( ih , jh , 1 , 1 , nt ) = upf ( nt )% dion ( ir , is ) Dion ( ih , jh , 2 , 2 , nt ) = upf ( nt )% dion ( ir , is ) else Dion ( ih , jh , 1 , 1 , nt ) = upf ( nt )% dion ( ir , is ) end if end if end do end do end if end do end subroutine init_Dion subroutine init_DKB () ! Initilize the DKB matrix for all beta(lm) projectors in the solid use intw_useful_constants , only : cmplx_0 use intw_reading , only : nat , ntyp , nspin , lspinorb , ityp implicit none integer :: ikb , jkb , nt , na , ih , jh , ntj , naj , ispin allocate ( DKB ( nkb , nkb , nspin , nspin )) DKB = cmplx_0 ikb = 0 do nt = 1 , ntyp do na = 1 , nat ! if ( ityp ( na ) == nt ) then ! do ih = 1 , nh ( ityp ( na )) ikb = ikb + 1 jkb = 0 do ntj = 1 , ntyp do naj = 1 , nat if ( ityp ( naj ) == ntj ) then do jh = 1 , nh ( ityp ( naj )) jkb = jkb + 1 if ( na == naj ) then if ( lspinorb ) then DKB ( ikb , jkb ,:,:) = Dion ( ih , jh ,:,:, ityp ( na )) else do ispin = 1 , nspin DKB ( ikb , jkb , ispin , ispin ) = Dion ( ih , jh , 1 , 1 , ityp ( na )) end do end if end if end do !jh end if end do !naj end do !ntj end do !ih ! end if ! end do !na end do !nt end subroutine init_DKB subroutine init_interpolation_table () ! Initialize the interpoation table used to calculate the KB projectors in reciprocal space ! ! This subroutine is based on the init_us_1 subroutine distributed as part of ! the Quantum Espresso project: !   Copyright (C) 2001-2007 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! use intw_reading , only : ecutwfc , ntyp , volume0 use intw_pseudo , only : upf use intw_useful_constants , only : fpi , ZERO use intw_utility , only : sphb , simpson , spline implicit none real ( kind = dp ), allocatable :: aux (:), xdata (:) real ( kind = dp ) :: vqint integer :: iq , ndm , nt , nb , l ! ! Calculate dimensions for array tab (including a possible factor ! coming from cell contraction during variable cell relaxation/MD) ! nqx = int ( sqrt ( 2 * ecutwfc ) / dq + 4 ) ! x2 because Ry -> Hartree ! ! q-point grid for interpolation ! allocate ( xdata ( nqx )) do iq = 1 , nqx xdata ( iq ) = ( iq - 1 ) * dq end do ! ! Fill the interpolation table ! allocate ( tab ( nqx , nbetam , ntyp )) allocate ( tab_d2y ( nqx , nbetam , ntyp )) ! ndm = maxval ( upf (:)% kkbeta ) allocate ( aux ( ndm )) ! tab = ZERO do nt = 1 , ntyp do nb = 1 , upf ( nt )% nbeta l = upf ( nt )% lll ( nb ) do iq = 1 , nqx aux = upf ( nt )% beta (:, nb ) * sphb ( l , xdata ( iq ) * upf ( nt )% r ) * upf ( nt )% r call simpson ( upf ( nt )% kkbeta , aux , upf ( nt )% rab , vqint ) ! ASIER 29/07/2021 ! Integrating by spline + gauss 2. order ! vqint = intgr_spline_gaussq( upf(nt)%r(1:upf(nt)%kkbeta), aux ) tab ( iq , nb , nt ) = vqint * fpi / sqrt ( volume0 ) end do end do end do ! deallocate ( aux ) ! ! Initialize spline interpolation ! do nt = 1 , ntyp do nb = 1 , upf ( nt )% nbeta call spline ( xdata , tab (:, nb , nt ), 0.0_dp , 0.0_dp , tab_d2y (:, nb , nt )) end do end do end subroutine init_interpolation_table subroutine init_KB_projectors ( npw , igk , kpoint_cryst , kb_projectors ) !---------------------------------------------------------------------- ! ! Calculates beta functions (Kleinman-Bylander projectors), with ! structure factor, for all atoms, in reciprocal space ! ! This subroutine is based on the init_us_2 subroutine distributed as part of ! the Quantum Espresso project: !   Copyright (C) 2001 PWSCF group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! use intw_reading , only : nat , nGk_max , ntyp , ityp , tau , bg , tpiba use intw_useful_constants , only : tpi , cmplx_0 , cmplx_i use intw_fft , only : gvec_cart use intw_pseudo , only : upf use intw_utility , only : real_ylmr2 , splint implicit none !I/O variables integer , intent ( in ) :: npw !number of PW's in k-point integer , intent ( in ) :: igk ( nGk_max ) !G list of k-point real ( kind = dp ), intent ( in ) :: kpoint_cryst ( 3 ) !k-point vector complex ( kind = dp ), intent ( out ) :: kb_projectors ( nGk_max , nkb ) !beta functions !local variables integer :: ig , l , lm , na , nt , nb , ih , jkb , iq real ( kind = dp ) :: kpoint_cart ( 3 ), kg_cart ( 3 , npw ), vkb1 ( npw , nhm ), xdata ( nqx ), ylm ( npw , ( lmaxkb + 1 ) ** 2 ) real ( kind = dp ), dimension ( npw ) :: kg ( npw ), vk ( npw ) complex ( kind = dp ) :: pref , sk ( npw ) kb_projectors = cmplx_0 ! kpoint_cart = matmul ( bg , kpoint_cryst ) ! if ( lmaxkb . lt . 0 ) return ! do ig = 1 , npw ! kg_cart ( 1 , ig ) = kpoint_cart ( 1 ) + gvec_cart ( 1 , igk ( ig )) kg_cart ( 2 , ig ) = kpoint_cart ( 2 ) + gvec_cart ( 2 , igk ( ig )) kg_cart ( 3 , ig ) = kpoint_cart ( 3 ) + gvec_cart ( 3 , igk ( ig )) ! kg ( ig ) = kg_cart ( 1 , ig ) ** 2 + kg_cart ( 2 , ig ) ** 2 + kg_cart ( 3 , ig ) ** 2 ! end do !ig ! call real_ylmr2 ( lmaxkb , npw , kg_cart , kg , ylm ) ! ! set now kg=|k+G| in atomic units ! kg (:) = tpiba * sqrt ( kg (:)) ! do iq = 1 , nqx xdata ( iq ) = ( iq - 1 ) * dq end do !iq ! ! |beta_lm(kg)> = (4pi/omega) * (-i&#94;l) * Y_lm(kg/|kg|) * f_l(|kg|) * S(kg) ! jkb = 0 vk = 0.d0 ! do nt = 1 , ntyp ! ! calculate beta in G-space using an interpolation table f_l(|kg|)=\\int _0 &#94;\\infty dr r&#94;2 f_l(r) j_l(|kg|.r) ! do nb = 1 , upf ( nt )% nbeta ! do ig = 1 , npw ! vk ( ig ) = splint ( xdata , tab (:, nb , nt ), tab_d2y (:, nb , nt ), kg ( ig )) ! end do !ig ! ! add spherical harmonic part: Y_lm(kg/|kg|) * f_l(|kg|) ! do ih = 1 , nh ( nt ) ! if ( nb /= nhtonbeta ( ih , nt )) cycle ! l = nhtol ( ih , nt ) lm = nhtolm ( ih , nt ) ! vkb1 (:, ih ) = ylm (:, lm ) * vk (:) ! end do !ih ! end do !nb ! ! vkb1 contains all betas including angular part for type nt ! now add the structure factor and factor (-i)&#94;l ! do na = 1 , nat ! ! ordering: first all betas for atoms of type 1 !           then  all betas for atoms of type 2  and so on ! if ( ityp ( na ) /= nt ) cycle ! do ig = 1 , npw ! sk ( ig ) = exp ( - tpi * cmplx_i * ( kg_cart ( 1 , ig ) * tau ( 1 , na ) & + kg_cart ( 2 , ig ) * tau ( 2 , na ) & + kg_cart ( 3 , ig ) * tau ( 3 , na ) ) ) ! end do !ig ! do ih = 1 , nh ( nt ) ! jkb = jkb + 1 pref = ( - cmplx_i ) ** nhtol ( ih , nt ) ! do ig = 1 , npw ! kb_projectors ( ig , jkb ) = pref * vkb1 ( ig , ih ) * sk ( ig ) ! end do !ig ! end do !ih ! end do !na ! end do !ntyp end subroutine init_KB_projectors subroutine multiply_psi_by_vKB ( k_cryst , list_iGk , num_bands , psi_k , vnl_psi ) !INTW project: KB projection by wave functions. ! use intw_useful_constants , only : cmplx_0 use intw_reading , only : nspin , nGk_max implicit none real ( kind = dp ), intent ( in ) :: k_cryst ( 3 ) integer , intent ( in ) :: list_iGk ( nGk_max ) integer , intent ( in ) :: num_bands complex ( kind = dp ), intent ( in ) :: psi_k ( nGk_max , num_bands , nspin ) complex ( kind = dp ), intent ( inout ) :: vnl_psi ( nGk_max , num_bands , nspin ) complex ( kind = dp ) :: vkb_k ( nGk_max , nkb ) complex ( kind = dp ) :: projec_d ( nkb , nspin ), DKB_projec_d ( nkb , nspin ) integer :: iband , ikb , ispin , jspin integer :: iG , nGk ! Compute non local |beta> projectors of KB PP for k nGk = 0 do iG = 1 , nGk_max if ( list_iGk ( iG ) == 0 ) exit nGk = nGk + 1 enddo call init_KB_projectors ( nGk , list_iGk , k_cryst , vkb_k ) do iband = 1 , num_bands ! projec_d = cmplx_0 ! ! do ikb = 1 , nkb ! do ispin = 1 , nspin ! do iG = 1 , nGk projec_d ( ikb , ispin ) = projec_d ( ikb , ispin ) + conjg ( vkb_k ( iG , ikb )) * psi_k ( iG , iband , ispin ) end do !iG ! end do !ispin ! end do !ikb ! multiplay the projections <\\beta_j|\\psi_n> by the matrix DKB DKB_projec_d = cmplx_0 do ispin = 1 , nspin do jspin = 1 , nspin ! DKB_projec_d (:, ispin ) = DKB_projec_d (:, ispin ) + matmul ( DKB (:,:, ispin , jspin ), projec_d (:, jspin ) ) ! end do !jspin end do !ispin ! do ikb = 1 , nkb ! do ispin = 1 , nspin ! vnl_psi (:, iband , ispin ) = DKB_projec_d ( ikb , ispin ) * vkb_k (:, ikb ) ! end do !ispin ! end do !ikb ! end do !iband end subroutine multiply_psi_by_vKB subroutine multiply_psi_by_dvKB ( k_cryst , q_cryst , list_iGk , list_iGkq , num_bands , psi_k , dvnl_psi ) use intw_useful_constants , only : cmplx_0 , cmplx_i use intw_reading , only : nat , nspin , nGk_max , tpiba , bg use intw_fft , only : gvec_cart implicit none real ( kind = dp ), intent ( in ) :: k_cryst ( 3 ), q_cryst ( 3 ) integer , intent ( in ) :: list_iGk ( nGk_max ), list_iGkq ( nGk_max ) integer , intent ( in ) :: num_bands complex ( kind = dp ), intent ( in ) :: psi_k ( nGk_max , num_bands , nspin ) complex ( kind = dp ), intent ( inout ) :: dvnl_psi ( nGk_max , num_bands , nspin , nspin , 3 * nat ) complex ( kind = dp ) :: vkb_k ( nGk_max , nkb ), vkb_kq ( nGk_max , nkb ) complex ( kind = dp ) :: projec_1 ( nkb , 3 , nspin ), projec_2 ( nkb , 3 , nspin ) complex ( kind = dp ) :: DKB_projec_1 ( nkb , 3 , nspin , nspin ), DKB_projec_2 ( nkb , 3 , nspin , nspin ) real ( kind = dp ) :: k_cart ( 3 ), q_cart ( 3 ) integer :: iG , iGk , iGkq , nGk , nGkq integer :: iband , ipol , ikb , ispin , jspin , na , imode k_cart = matmul ( bg , k_cryst ) q_cart = matmul ( bg , q_cryst ) ! Compute non local |beta> projectors of KB PP for k and k+q nGk = 0 do iG = 1 , nGk_max if ( list_iGk ( iG ) == 0 ) exit nGk = nGk + 1 enddo call init_KB_projectors ( nGk , list_iGk , k_cryst , vkb_k ) ! nGkq = 0 do iG = 1 , nGk_max if ( list_iGkq ( iG ) == 0 ) exit nGkq = nGkq + 1 enddo call init_KB_projectors ( nGkq , list_iGkq , k_cryst + q_cryst , vkb_kq ) do iband = 1 , num_bands projec_1 = cmplx_0 projec_2 = cmplx_0 ! Asier: KB potentziala hurrengo eran emanik dago: sum_l |b(l)> <b(l)| !               beraz deribatuak bi gai dauzka: !               sum_l d|b(l,r)> <b(l,r)| + |b(l,r)> d<b(l,r)| ~ Fourier ~ !               sum_l i(k+G)|b(l,G)> <b(l,G)| + |b(l,G)> <b(l,G)| ! do ipol = 1 , 3 ! Cart. coord. ! do ikb = 1 , nkb ! do ispin = 1 , nspin ! do iG = 1 , nGk ! iGk = list_iGk ( iG ) ! projec_1 ( ikb , ipol , ispin ) = projec_1 ( ikb , ipol , ispin ) & + conjg ( vkb_k ( iG , ikb )) * psi_k ( iG , iband , ispin ) ! projec_2 ( ikb , ipol , ispin ) = projec_2 ( ikb , ipol , ispin ) & + conjg ( vkb_k ( iG , ikb )) * psi_k ( iG , iband , ispin ) * & tpiba * cmplx_i * ( k_cart ( ipol ) + gvec_cart ( ipol , iGk ) ) ! end do !iG ! end do !ispin ! end do !ikb ! end do !ipol ! multiplay the projections <\\beta_j|\\psi_n> by the matrix DKB DKB_projec_1 = cmplx_0 DKB_projec_2 = cmplx_0 do ipol = 1 , 3 ! Cart. coord. ! do ispin = 1 , nspin do jspin = 1 , nspin ! DKB_projec_1 (:, ipol , ispin , jspin ) = matmul ( DKB (:,:, ispin , jspin ), projec_1 (:, ipol , jspin ) ) DKB_projec_2 (:, ipol , ispin , jspin ) = matmul ( DKB (:,:, ispin , jspin ), projec_2 (:, ipol , jspin ) ) ! end do !jspin end do !ispin ! end do !ipol do ipol = 1 , 3 ! Cart. coord. ! do ikb = 1 , nkb ! na = nkbtona ( ikb ) ! imode = ( na - 1 ) * 3 + ipol ! do iG = 1 , nGkq ! iGkq = list_iGkq ( iG ) ! do ispin = 1 , nspin do jspin = 1 , nspin ! dvnl_psi ( iG , iband , ispin , jspin , imode ) = dvnl_psi ( iG , iband , ispin , jspin , imode ) & + DKB_projec_2 ( ikb , ipol , ispin , jspin ) * vkb_kq ( iG , ikb ) ! dvnl_psi ( iG , iband , ispin , jspin , imode ) = dvnl_psi ( iG , iband , ispin , jspin , imode ) & - DKB_projec_1 ( ikb , ipol , ispin , jspin ) * vkb_kq ( iG , ikb ) * & tpiba * cmplx_i * ( k_cart ( ipol ) + q_cart ( ipol ) + gvec_cart ( ipol , iGkq ) ) ! end do !jspin end do !ispin ! end do !iG ! end do !ikb ! end do !ipol end do !iband end subroutine multiply_psi_by_dvKB function sph_ind ( l , j , m , spin ) ! This function calculates the m index of the spherical harmonic ! in a spinor with orbital angular momentum l, total angular ! momentum j, projection along z of the total angular momentum m+-1/2. ! Spin selects the up (spin=1) or down (spin=2) coefficient. ! ! This subroutine is originally distributed as part of the Quantum Espresso project: !   Copyright (C) 2004 PWSCF group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! !  Modifications by INTW group, 2024: !   - Intent(in) variables specified explicitly. ! use kinds , only : dp use intw_utility , ONLY : errore implicit none integer , intent ( in ) :: l , & ! orbital angular momentum m , & ! projection of the total angular momentum+-1/2 spin ! 1 or 2 select the component real ( kind = dp ), intent ( in ) :: j ! total angular momentum integer :: sph_ind if ( spin . ne . 1. and . spin . ne . 2 ) call errore ( 'sph_ind' , 'spin direction unknown' , 1 ) if ( m . lt . - l - 1. or . m . gt . l ) call errore ( 'sph_ind' , 'm not allowed' , 1 ) if ( abs ( j - l - 0.5d0 ). lt . 1.d-8 ) then if ( spin . eq . 1 ) sph_ind = m if ( spin . eq . 2 ) sph_ind = m + 1 elseif ( abs ( j - l + 0.5d0 ). lt . 1.d-8 ) then if ( m . lt . - l + 1 ) then sph_ind = 0 else if ( spin . eq . 1 ) sph_ind = m - 1 if ( spin . eq . 2 ) sph_ind = m endif else write ( 6 , * ) l , j call errore ( 'sph_ind' , 'l and j not compatible' , 1 ) endif if ( sph_ind . lt . - l . or . sph_ind . gt . l ) sph_ind = 0 return end function sph_ind function spinor ( l , j , m , spin ) ! This function calculates the numerical coefficient of a spinor ! with orbital angular momentum l, total angular momentum j, ! projection along z of the total angular momentum m+-1/2. Spin selects ! the up (spin=1) or down (spin=2) coefficient. ! ! This subroutine is originally distributed as part of the Quantum Espresso project: !   Copyright (C) 2004 PWSCF group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! !  Modifications by INTW group, 2024: !   - Intent(in) variables specified explicitly. ! use kinds , only : dp use intw_utility , ONLY : errore implicit none integer , intent ( in ) :: l , & ! orbital angular momentum m , & ! projection of the total angular momentum+-1/2 spin ! 1 or 2 select the component real ( kind = dp ), intent ( in ) :: j ! total angular momentum real ( kind = dp ) :: spinor real ( kind = dp ) :: denom ! denominator if ( spin . ne . 1. and . spin . ne . 2 ) call errore ( 'spinor' , 'spin direction unknown' , 1 ) if ( m . lt . - l - 1. or . m . gt . l ) call errore ( 'spinor' , 'm not allowed' , 1 ) denom = 1.d0 / ( 2.d0 * l + 1.d0 ) if ( abs ( j - l - 0.5d0 ). lt . 1.d-8 ) then if ( spin . eq . 1 ) spinor = sqrt (( l + m + 1.d0 ) * denom ) if ( spin . eq . 2 ) spinor = sqrt (( l - m ) * denom ) elseif ( abs ( j - l + 0.5d0 ). lt . 1.d-8 ) then if ( m . lt . - l + 1 ) then spinor = 0.d0 else if ( spin . eq . 1 ) spinor = sqrt (( l - m + 1.d0 ) * denom ) if ( spin . eq . 2 ) spinor = - sqrt (( l + m ) * denom ) endif else call errore ( 'spinor' , 'j and l not compatible' , 1 ) endif return end function spinor end module intw_pseudo_non_local","tags":"","url":"sourcefile/intw_pseudo_non_local.f90.html"},{"title":"utility.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_utility !! display: none !! !! This module contains useful functions and subroutines that implement common tasks. !! !! ### Details !! !! It will be VERY useful to call these functions instead !! of reimplementing them every time they are needed, especially !! to ensure CONSISTENCY. !! use kinds , only : dp implicit none ! ! subroutines public :: diagonalize_cmat , get_timing , & joint_to_triple_index_g , triple_to_joint_index_g , & joint_to_triple_index_r , triple_to_joint_index_r , & generate_kmesh , generate_and_allocate_kpath , & find_neighbor , find_maximum_index_int , test_qpt_on_fine_mesh , & find_k_1BZ_and_G , cryst_to_cart , & hpsort_integer , hpsort_real , & find_r_in_WS_cell , errore , simpson , sphb , & real_ylmr2 , dosplineint , spline , splint , & print_threads , print_date_time ! ! functions public :: intgr_spline_gaussq , multiple , & qe_erf , qe_erfc , find_free_unit , conmesurate_and_coarser , & smeared_delta , smeared_lorentz , fermi_dirac , int2str ! private ! contains subroutine diagonalize_cmat ( A , w ) ! ! Diagonalize a complex Hermitian matrix ! implicit none ! ! input variables complex ( kind = dp ), intent ( inout ) :: A (:,:) ! matrix to diagonalize on input, eigenvector on output real ( kind = dp ), intent ( out ) :: w (:) ! eigenvalues ! complex ( kind = dp ), allocatable , dimension (:) :: WORK real ( kind = dp ), allocatable , dimension (:) :: RWORK integer :: N , LWORK , INFO ! external :: zheev N = size (( A ), DIM = 1 ) if ( size (( A ), DIM = 2 ) . ne . N ) stop \"diagonalize_cmat: ERROR\" if ( size (( w ), DIM = 1 ) . ne . N ) stop \"diagonalize_cmat: ERROR\" ! LWORK = - 1 allocate ( WORK ( 1 )) allocate ( RWORK ( max ( 1 , 3 * N - 2 ))) ! call zheev ( \"V\" , \"U\" , N , A , N , w , WORK , LWORK , RWORK , INFO ) ! LWORK = int ( WORK ( 1 )) ! deallocate ( WORK ) allocate ( WORK ( LWORK )) ! call zheev ( \"V\" , \"U\" , N , A , N , w , WORK , LWORK , RWORK , INFO ) end subroutine diagonalize_cmat function intgr_spline_gaussq ( xdata , ydata ) result ( batura ) ! This function integrates exactly (numerical) ! the cubic spline interpolation of a given data in 1D ! this is so because 2nd order gauss cuadrature ! is exact of pol. of order 3. real ( kind = dp ), intent ( in ) :: xdata (:), ydata (:) !out real ( kind = dp ) :: batura !local real ( kind = dp ), dimension ( size ( xdata )) :: ys2 real ( kind = dp ) :: x1 , x2 , y1 , y2 real ( kind = dp ), parameter :: onesqrt3 = 0.57735026919_dp integer :: i call spline ( xdata , ydata , 0.0_dp , 0.0_dp , ys2 ) batura = 0.0_dp do i = 1 , size ( xdata ) - 1 x1 = ( xdata ( i + 1 ) + xdata ( i )) / 2.0_dp - ( xdata ( i + 1 ) - xdata ( i )) / 2.0_dp / onesqrt3 x2 = ( xdata ( i + 1 ) + xdata ( i )) / 2.0_dp + ( xdata ( i + 1 ) - xdata ( i )) / 2.0_dp / onesqrt3 y1 = splint ( xdata , ydata , ys2 , x1 ) y2 = splint ( xdata , ydata , ys2 , x2 ) batura = batura + ( y2 + y1 ) * ( xdata ( i + 1 ) - xdata ( i )) / 2.0_dp enddo end function intgr_spline_gaussq subroutine get_timing ( time ) !----------------------------------------------------------------------------! ! Timing the code is very important for optimized performance. ! However, some experimence indicates that \"timing\" is not so easy: ! time can overflow the buffer in which it is held, or it can give ! crazy numbers for (so far) unknown reasons. Thus, in order to be ! able to quickly modify how time is measured, a single subroutine ! will be called throuhout the code to measure time. This subroutine ! can then easily be modified as the code writer becomes ! aware of \"better\" timing algorithms. !----------------------------------------------------------------------------! implicit none real ( dp ), external :: dsecnd real ( dp ) :: time time = dsecnd () end subroutine get_timing function conmesurate_and_coarser ( nk1 , nk2 , nk3 , nq1 , nq2 , nq3 ) !Asier&&Idoia 23 06 2014 logical :: conmesurate_and_coarser integer , intent ( in ) :: nk1 , nk2 , nk3 , nq1 , nq2 , nq3 conmesurate_and_coarser = . true . !check if electron k grid does not contain the phonon q grid. if (( nk1 < nq1 ). or .( nk2 < nq2 ). or .( nk3 < nq3 )) conmesurate_and_coarser = . false . !check if q is contained in k if ( . not . multiple ( nk1 , nq1 ) ) conmesurate_and_coarser = . false . if ( . not . multiple ( nk2 , nq2 ) ) conmesurate_and_coarser = . false . if ( . not . multiple ( nk3 , nq3 ) ) conmesurate_and_coarser = . false . end function conmesurate_and_coarser function multiple ( i1 , i2 ) !Asier&&Idoia 23 06 2014 !Check if two integers are multiple of each other. logical :: multiple integer , intent ( in ) :: i1 , i2 multiple = . false . if ( ( i1 / i2 * i2 == i1 ) . or . ( i2 / i1 * i1 == i2 ) ) then multiple = . true . endif end function multiple subroutine joint_to_triple_index_g ( n1 , n2 , n3 , i_joint , i , j , k ) !----------------------------------------------------------------------------! ! Compute the triple indices i, j, k of a point in a n1, n2, n3 mesh on ! reciprocal space from the joint index i_joint. ! ! i_joint is a single integer from 1 to n1*n2*n3, which uniquely ! labels all the points of the mesh. ! ! i, j, k are the triple indices, which uniquely label all the points ! of the mesh according to their coordinates in the mesh. ! ! The 3rd triple index loops fastest: !   i_joint = k + (j-1)*n3 + (i-1)*n2*n3 !----------------------------------------------------------------------------! implicit none integer , intent ( in ) :: n1 , n2 , n3 integer , intent ( in ) :: i_joint integer , intent ( out ) :: i , j , k i = ( i_joint - 1 ) / ( n2 * n3 ) + 1 j = ( i_joint - 1 ) / n3 - ( i - 1 ) * n2 + 1 k = i_joint - int (( i_joint - 1 ) / n3 ) * n3 ! k = mod(i_joint-1, n3) + 1 end subroutine joint_to_triple_index_g subroutine triple_to_joint_index_g ( n1 , n2 , n3 , i_joint , i , j , k ) !----------------------------------------------------------------------------! ! Compute the joint index i_joint of a point in a n1, n2, n3 mesh on ! reciprocal space from the triple indices i, j, k. ! ! i_joint is a single integer from 1 to n1*n2*n3, which uniquely ! labels all the points of the mesh. ! ! i, j, k are the triple indices, which uniquely label all the points ! of the mesh according to their coordinates in the mesh. ! ! The 3rd triple index loops fastest: !   i_joint = k + (j-1)*n3 + (i-1)*n2*n3 !----------------------------------------------------------------------------! implicit none integer , intent ( in ) :: n1 , n2 , n3 integer , intent ( out ) :: i_joint integer , intent ( in ) :: i , j , k i_joint = k + ( j - 1 + ( i - 1 ) * n2 ) * n3 end subroutine triple_to_joint_index_g subroutine joint_to_triple_index_r ( n1 , n2 , n3 , i_joint , i , j , k ) !----------------------------------------------------------------------------! ! Compute the triple indices i, j, k of a point in a n1, n2, n3 mesh on ! real space from the joint index i_joint. ! ! i_joint is a single integer from 1 to n1*n2*n3, which uniquely ! labels all the points of the mesh. ! ! i, j, k are the triple indices, which uniquely label all the points ! of the mesh according to their coordinates in the mesh. ! ! The 1st triple index loops fastest: !   i_joint = i + (j-1)*n2 + (k-1)*n1*n2 !----------------------------------------------------------------------------! implicit none integer , intent ( in ) :: n1 , n2 , n3 integer , intent ( in ) :: i_joint integer , intent ( out ) :: i , j , k k = ( i_joint - 1 ) / ( n1 * n2 ) + 1 j = ( i_joint - 1 ) / n1 - ( k - 1 ) * n2 + 1 i = i_joint - int (( i_joint - 1 ) / n1 ) * n1 ! k = mod(i_joint-1, n1) + 1 end subroutine joint_to_triple_index_r subroutine triple_to_joint_index_r ( n1 , n2 , n3 , i_joint , i , j , k ) !----------------------------------------------------------------------------! ! Compute the triple indices i, j, k of a point in a n1, n2, n3 mesh on ! real space from the joint index i_joint. ! ! i_joint is a single integer from 1 to n1*n2*n3, which uniquely ! labels all the points of the mesh. ! ! i, j, k are the triple indices, which uniquely label all the points ! of the mesh according to their coordinates in the mesh. ! ! The 1st triple index loops fastest: !   i_joint = i + (j-1)*n2 + (k-1)*n1*n2 !----------------------------------------------------------------------------! implicit none integer , intent ( in ) :: n1 , n2 , n3 integer , intent ( out ) :: i_joint integer , intent ( in ) :: i , j , k i_joint = i + ( j - 1 + ( k - 1 ) * n2 ) * n1 end subroutine triple_to_joint_index_r subroutine generate_kmesh ( kmesh , nk_1 , nk_2 , nk_3 ) !----------------------------------------------------------------------------! !     This subroutine builds the array of k vectors corresponding !     to MP indices nk_1,nk_2,nk_3, ordered according to their joint !     index. !----------------------------------------------------------------------------! implicit none integer , intent ( in ) :: nk_1 , nk_2 , nk_3 real ( dp ), intent ( out ) :: kmesh ( 3 , nk_1 * nk_2 * nk_3 ) integer :: i , j , k integer :: ikpt , nkmesh ! Build kmesh nkmesh = nk_1 * nk_2 * nk_3 do ikpt = 1 , nkmesh call joint_to_triple_index_g ( nk_1 , nk_2 , nk_3 , ikpt , i , j , k ) kmesh ( 1 , ikpt ) = dble ( i - 1 ) / nk_1 kmesh ( 2 , ikpt ) = dble ( j - 1 ) / nk_2 kmesh ( 3 , ikpt ) = dble ( k - 1 ) / nk_3 end do end subroutine generate_kmesh subroutine generate_and_allocate_kpath ( at , bg , tpiba , nkpath , nkspecial , kspecial , kpath , & dkpath , kspecial_indices ) ! -------------------------------------------------- ! MBR 03/05/2024 ! This generates the path of nearly equispaced k-points in cartesians ! and convert to cryst at the end. ! It works similar to Asier's method: ! The total length of the path is calculated and a ! number of points per stage is assigned proportional ! to the stage length. ! Each stage starts with a kspecial point. ! In the end it may happen that this routine generates a few less points ! in total than nkpath. In that case, this value is corrected and returned, ! together with the allocated kpath list (in fractional coordinates). ! Optionally, a list of distances dkpath between k-points (in cartesians) is returned. ! -------------------------------------------------- implicit none integer , intent ( in ) :: nkspecial integer , intent ( inout ) :: nkpath integer , allocatable , intent ( out ), optional :: kspecial_indices (:) real ( dp ), intent ( in ) :: at ( 3 , 3 ), bg ( 3 , 3 ), tpiba real ( dp ), intent ( in ) :: kspecial ( 3 , nkspecial ) real ( dp ), allocatable , intent ( out ) :: kpath (:,:) real ( dp ), allocatable , intent ( out ) , optional :: dkpath (:) integer :: i , j , ik , nkstage ( nkspecial - 1 ) real ( dp ) :: lpath real ( dp ) :: kspecial_cart ( 3 , nkspecial ), lstage ( nkspecial - 1 ), vec ( 3 ) ! cryst to cart of special points forming the path milestones kspecial_cart = kspecial call cryst_to_cart ( nkspecial , kspecial_cart , bg , 1 ) ! total length (lpath) of the path by adding stages of length (lstage) do i = 2 , nkspecial vec = kspecial_cart (:, i ) - kspecial_cart (:, i - 1 ) lstage ( i - 1 ) = sqrt ( dot_product ( vec , vec ) ) end do lpath = sum ( lstage ) ! number of points in the path per stage do i = 2 , nkspecial nkstage ( i - 1 ) = nint ( real ( nkpath - 1 , dp ) * lstage ( i - 1 ) / lpath ) + 1 end do ! check how many point will we actually generate if ( sum ( nkstage ) + 1 /= nkpath ) & write ( * , '(A19,I4,A19,I4,A7)' ) '|   Path will have ' , sum ( nkstage ) + 1 , ' points instead of ' , nkpath , ' !    |' nkpath = sum ( nkstage ) + 1 allocate ( kpath ( 3 , nkpath )) if ( present ( kspecial_indices )) then allocate ( kspecial_indices ( nkspecial )) kspecial_indices ( 1 ) = 1 end if ! Build path points in cartesians kpath = 0.0_dp ik = 0 do i = 2 , nkspecial ! stage i-1 starts in i-1-th, ends in i-th special point, ! but this i-th point is not included. ! It contains nkstage(i-1) points do j = 1 , nkstage ( i - 1 ) ik = ik + 1 kpath (:, ik ) = kspecial_cart (:, i - 1 ) + & ( kspecial_cart (:, i ) - kspecial_cart (:, i - 1 ) ) * real ( j - 1 , dp ) / real ( nkstage ( i - 1 ), dp ) end do !  index in k-path corresponding to this special k-point(end of stage) if ( present ( kspecial_indices )) kspecial_indices ( i ) = ik + 1 end do ! last point is the last special point kpath (:, nkpath ) = kspecial_cart (:, nkspecial ) ! check we made all the points if ( ik + 1 . ne . nkpath ) then write ( * , * ) ' ERROR nkpath not fulfilled. Stopping.' stop end if !compute accumulated distance (cartesians, atomic units, incl. 2pi/alat factor) along path if requested if ( present ( dkpath )) then allocate ( dkpath ( nkpath )) dkpath ( 1 ) = 0.0_dp do ik = 2 , nkpath dkpath ( ik ) = dkpath ( ik - 1 ) + & sqrt ( dot_product ( kpath (:, ik ) - kpath (:, ik - 1 ), kpath (:, ik ) - kpath (:, ik - 1 ) )) * tpiba end do end if ! Finally, convert kpath list to crystal coordinates call cryst_to_cart ( nkpath , kpath , at , - 1 ) end subroutine generate_and_allocate_kpath subroutine find_neighbor ( kpoint , nk_1 , nk_2 , nk_3 , i_k , j_k , k_k ) !----------------------------------------------------------------------------! !     Given a kpoint = (kx, ky, kz) in crystal coordinates, which lies !     inside the 1BZ, namely 0 <= kx,ky,kz < 1, this subroutine returns !     the coordinates of the neighbor which lies at the origin of the tricubic !     4x4x4 interpolation grid, in the format (i_k,j_k,k_k). !     The crystal coordinates of the neigbhor are given by !                     ((i_k-1)/nk_1, (j_k-1)/nk_2, (k_k-1)/nk_3). ! !----------------------------------------------------------------------------! implicit none real ( dp ), intent ( in ) :: kpoint ( 3 ) integer , intent ( in ) :: nk_1 , nk_2 , nk_3 integer , intent ( out ) :: i_k , j_k , k_k i_k = 1 + nint ( kpoint ( 1 ) * nk_1 ) j_k = 1 + nint ( kpoint ( 2 ) * nk_2 ) k_k = 1 + nint ( kpoint ( 3 ) * nk_3 ) end subroutine find_neighbor subroutine find_maximum_index_int ( array , sze , i_max ) !----------------------------------------------------------------------------! !     Given an array of integers array(sze), this subroutine returns !     the largest value in the array. !----------------------------------------------------------------------------! implicit none integer , intent ( in ) :: sze , array ( sze ) integer , intent ( out ) :: i_max integer :: i , maximum i_max = 1 maximum = array ( 1 ) do i = 2 , sze if ( array ( i ) > maximum ) then maximum = array ( i ) i_max = i end if end do end subroutine find_maximum_index_int subroutine test_qpt_on_fine_mesh ( qpt , nk1s , nk2s , nk3s , test_qpt , i_qpt1 , i_qpt2 , i_qpt3 ) !----------------------------------------------------------------------------! ! ! This subroutine tests whether the q-point, qpt(3), is of the form ! !     qpt(:) = [ i_qpt1-1   i_qpt2-1   i_qpt3-1 ] + (I,J,K) !              [ -------- , -------- , -------- ] !              [   nk1s       nk2s       nk3s   ] ! ! ! where I,J,K are integers, and i_qpt(1,2,3) are integers between 1 and nk(123)s. ! ! It is important to perform this task in a defensive way. ! The fortran internal functions nint, floor, and modulo are DANGEROUS. ! IT IS CRUCIAL TO DO THIS RIGHT ONCE AND FOR ALL. ! !----------------------------------------------------------------------------! use intw_useful_constants , only : eps_8 implicit none ! input integer , intent ( in ) :: nk1s , nk2s , nk3s ! the fine mesh parameters real ( dp ), intent ( in ) :: qpt ( 3 ) ! the q-point ! output logical , intent ( out ) :: test_qpt ! is the q-point on the fine mesh? integer , intent ( out ) :: i_qpt1 , i_qpt2 , i_qpt3 ! internal variables real ( dp ) :: nqpt_1 , nqpt_2 , nqpt_3 real ( dp ) :: err_1 , err_2 , err_3 ! the q-point ! find err nqpt_1 = dble ( nk1s ) * qpt ( 1 ) nqpt_2 = dble ( nk2s ) * qpt ( 2 ) nqpt_3 = dble ( nk3s ) * qpt ( 3 ) err_1 = ( nqpt_1 - nint ( nqpt_1 )) / dble ( nk1s ) err_2 = ( nqpt_2 - nint ( nqpt_2 )) / dble ( nk2s ) err_3 = ( nqpt_3 - nint ( nqpt_3 )) / dble ( nk3s ) test_qpt = err_1 < eps_8 . and . & err_2 < eps_8 . and . & err_3 < eps_8 if ( test_qpt ) then ! q is on mesh; find its coordinates. i_qpt1 = modulo ( nint ( nqpt_1 ), nk1s ) + 1 i_qpt2 = modulo ( nint ( nqpt_2 ), nk2s ) + 1 i_qpt3 = modulo ( nint ( nqpt_3 ), nk3s ) + 1 else ! q is not on mesh! throw an error outside the subroutine i_qpt1 = 0 i_qpt2 = 0 i_qpt3 = 0 end if end subroutine test_qpt_on_fine_mesh subroutine find_k_1BZ_and_G ( kpoint , nk1 , nk2 , nk3 , i , j , k , kpt_in_1BZ , G ) !----------------------------------------------------------------------------! ! Given a kpoint(3) in crystal coordinates, this subroutine ! generates: !            - k_1BZ(3),   with 0 <= k_1BZ(i) < 1 !            - G(3),       G(i) an integer !            - i,j,k       the triple coordinates of the point in the mesh. ! ! It it EXTREMELY important to have a subroutine which performs this ! task in a defensive way. The fortran internal functions nint, floor, ! and modulo are DANGEROUS. IT IS CRUCIAL TO DO THIS RIGHT ONCE AND FOR ! ALL. ! ! The basic relationship is !    kpoint = k_1BZ + G ! ! Assume !    kpoint(l) =  G(l) + (i_l-1)/nk_l+ epsilon , ! with !    l    = 1, 2, 3 !    i_l  = i, j ,k !    nk_l = nk1, nk2, nk3 !    G(l) an integer ! epsilon numerical noise !----------------------------------------------------------------------------! implicit none ! input integer , intent ( in ) :: nk1 , nk2 , nk3 ! the mesh parameters real ( dp ), intent ( in ) :: kpoint ( 3 ) ! the kpoint of interest ! output integer , intent ( out ) :: i , j , k ! the triple coordinates of k_1BZ real ( dp ), intent ( out ) :: kpt_in_1BZ ( 3 ) ! the k point in the 1BZ integer , intent ( out ) :: G ( 3 ) ! the translation vector ! internal variables integer :: nG_im1 , nG_jm1 , nG_km1 integer :: im1 , jm1 , km1 ! this step kills epsilon nG_im1 = nint ( kpoint ( 1 ) * dble ( nk1 )) nG_jm1 = nint ( kpoint ( 2 ) * dble ( nk2 )) nG_km1 = nint ( kpoint ( 3 ) * dble ( nk3 )) ! this step gets rid of G im1 = modulo ( nG_im1 , nk1 ) jm1 = modulo ( nG_jm1 , nk2 ) km1 = modulo ( nG_km1 , nk3 ) ! G can be extracted. This division must be exact. G ( 1 ) = ( nG_im1 - im1 ) / nk1 G ( 2 ) = ( nG_jm1 - jm1 ) / nk2 G ( 3 ) = ( nG_km1 - km1 ) / nk3 ! finally we have the triple coordinates i = im1 + 1 j = jm1 + 1 k = km1 + 1 ! compute the k point in the 1BZ kpt_in_1BZ ( 1 ) = dble ( i - 1 ) / dble ( nk1 ) kpt_in_1BZ ( 2 ) = dble ( j - 1 ) / dble ( nk2 ) kpt_in_1BZ ( 3 ) = dble ( k - 1 ) / dble ( nk3 ) end subroutine find_k_1BZ_and_G function find_free_unit () ! ! This function finds a free input/output unit. ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2002-2009 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! implicit none ! integer :: find_free_unit integer :: io_unit logical :: opnd do io_unit = 999 , 9 , - 1 ! inquire ( unit = io_unit , opened = opnd ) if ( . not . opnd ) then find_free_unit = io_unit return end if ! end do ! stop 'NO free units available!?!' ! return ! end function find_free_unit subroutine cryst_to_cart ( nvec , vec , trmat , iflag ) !----------------------------------------------------------------------- ! ! This routine transforms the atomic positions or the k-point ! components from crystallographic to cartesian coordinates ! ( iflag=1 ) and viceversa ( iflag=-1 ). ! Output cartesian coordinates are stored in the input ('vec') array ! !----------------------------------------------------------------------- ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2001-2003 PWSCF group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! implicit none ! integer , intent ( in ) :: nvec , iflag ! nvec:  number of vectors (atomic positions or k-points) !        to be transformed from crystal to cartesian and vice versa ! iflag: gives the direction of the transformation real ( 8 ), intent ( in ) :: trmat ( 3 , 3 ) ! trmat: transformation matrix ! if iflag=1: !    trmat = at ,  basis of the real-space lattice,       for atoms   or !          = bg ,  basis of the reciprocal-space lattice, for k-points ! if iflag=-1: the opposite real ( 8 ), intent ( inout ) :: vec ( 3 , nvec ) ! coordinates of the vector (atomic positions or k-points) to be ! transformed - overwritten on output ! !    local variables ! integer :: nv , kpol ! counter on vectors ! counter on polarizations real ( 8 ) :: vau ( 3 ) ! workspace ! !     Compute the cartesian coordinates of each vectors !     (atomic positions or k-points components) ! do nv = 1 , nvec if ( iflag . eq . 1 ) then do kpol = 1 , 3 vau ( kpol ) = trmat ( kpol , 1 ) * vec ( 1 , nv ) + & trmat ( kpol , 2 ) * vec ( 2 , nv ) + & trmat ( kpol , 3 ) * vec ( 3 , nv ) enddo else do kpol = 1 , 3 vau ( kpol ) = trmat ( 1 , kpol ) * vec ( 1 , nv ) + & trmat ( 2 , kpol ) * vec ( 2 , nv ) + & trmat ( 3 , kpol ) * vec ( 3 , nv ) enddo endif do kpol = 1 , 3 vec ( kpol , nv ) = vau ( kpol ) enddo enddo ! return ! end subroutine cryst_to_cart subroutine hpsort_integer ( n , ia , p ) !------------------------------------------------------------ ! subroutine which performs heap sort on a list of integers ! and also returns an array identifying the permutation ! which sorted the array. !***************************************************** !*  Sorts an array RA of length N in ascending order * !*                by the Heapsort method             * !* ------------------------------------------------- * !* INPUTS:                                           * !*      N   size of table RA                         * !*      RA  table to be sorted                       * !* OUTPUT:                                           * !*      RA  table sorted in ascending order          * !*      P   table of indices showing transform       * !*                                                   * !* NOTE: The Heapsort method is a N Log N routine,   * !*       and can be used for very large arrays.      * !***************************************************** ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2001 PWSCF group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! implicit none integer , intent ( in ) :: n integer , intent ( inout ) :: ia ( n ) integer , intent ( out ) :: p ( n ) integer :: i , j , l , ir , iia , pp ! initialize permutation array do i = 1 , n p ( i ) = i enddo ! nothing to order if ( n < 2 ) return ! initialize indices for hiring and retirement-promotion phase l = n / 2 + 1 ir = n 10 continue ! still in hiring phase if ( l > 1 ) then l = l - 1 iia = ia ( l ) pp = p ( l ) ! in retirement-promotion phase. else ! clear a space at the end of the array iia = ia ( ir ) ! pp = p ( ir ) ! retire the top of the heap into it ia ( ir ) = ia ( 1 ) ! p ( ir ) = p ( 1 ) ! decrease the size of the corporation ir = ir - 1 ! done with the last promotion if ( ir == 1 ) then ! the least competent worker at all ! ia ( 1 ) = iia ! p ( 1 ) = pp return endif endif ! wheter in hiring or promotion phase, we i = l ! set up to place iia in its proper level j = l + l ! do while ( j <= ir ) if ( j < ir ) then ! compare to better underling if ( ia ( j ) < ia ( j + 1 ) ) then j = j + 1 elseif ( ia ( j ) == ia ( j + 1 ) ) then if ( p ( j ) < p ( j + 1 ) ) j = j + 1 endif endif ! demote iia if ( iia < ia ( j ) ) then ia ( i ) = ia ( j ) p ( i ) = p ( j ) i = j j = j + j elseif ( iia == ia ( j ) ) then ! demote iia if ( pp < p ( j ) ) then ia ( i ) = ia ( j ) p ( i ) = p ( j ) i = j j = j + j else ! set j to terminate do-while loop j = ir + 1 endif ! this is the right place for iia else ! set j to terminate do-while loop j = ir + 1 endif enddo ia ( i ) = iia p ( i ) = pp goto 10 end subroutine hpsort_integer subroutine hpsort_real ( n , ra , p ) !------------------------------------------------------------ ! subroutine which performs heap sort on a list of real numbers ! and also returns an array identifying the permutation ! which sorted the array. !***************************************************** !*  Sorts an array RA of length N in ascending order * !*                by the Heapsort method             * !* ------------------------------------------------- * !* INPUTS:                                           * !*      n   size of table RA                         * !*      ra  table to be sorted                       * !* OUTPUT:                                           * !*      ra  table sorted in ascending order          * !*      p   table of indices showing transform       * !*                                                   * !* NOTE: The Heapsort method is a N Log N routine,   * !*       and can be used for very large arrays.      * !***************************************************** ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2001 PWSCF group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! implicit none integer , intent ( in ) :: n real ( dp ), intent ( inout ) :: ra ( n ) integer , intent ( out ) :: p ( n ) integer :: i , j , l , ir , pp real ( dp ) :: rra ! initialize permutation array do i = 1 , n p ( i ) = i enddo ! nothing to order if ( n < 2 ) return ! initialize indices for hiring and retirement-promotion phase l = n / 2 + 1 ir = n 10 continue ! still in hiring phase if ( l > 1 ) then l = l - 1 rra = ra ( l ) pp = p ( l ) ! in retirement-promotion phase. else ! clear a space at the end of the array rra = ra ( ir ) ! pp = p ( ir ) ! retire the top of the heap into it ra ( ir ) = ra ( 1 ) ! p ( ir ) = p ( 1 ) ! decrease the size of the corporation ir = ir - 1 ! done with the last promotion if ( ir == 1 ) then ! the least competent worker at all ! ra ( 1 ) = rra ! p ( 1 ) = pp return endif endif ! wheter in hiring or promotion phase, we i = l ! set up to place rra in its proper level j = l + l ! do while ( j <= ir ) if ( j < ir ) then ! compare to better underling if ( ra ( j ) < ra ( j + 1 ) ) then j = j + 1 elseif ( ra ( j ) == ra ( j + 1 ) ) then if ( p ( j ) < p ( j + 1 ) ) j = j + 1 endif endif ! demote rra if ( rra < ra ( j ) ) then ra ( i ) = ra ( j ) p ( i ) = p ( j ) i = j j = j + j elseif ( rra == ra ( j ) ) then ! demote rra if ( pp < p ( j ) ) then ra ( i ) = ra ( j ) p ( i ) = p ( j ) i = j j = j + j else ! set j to terminate do-while loop j = ir + 1 endif ! this is the right place for rra else ! set j to terminate do-while loop j = ir + 1 endif enddo ra ( i ) = rra p ( i ) = pp goto 10 end subroutine hpsort_real subroutine find_r_in_WS_cell ( at , rvec_cryst , nr1 , nr2 , nr3 , rvec_WS_cryst ) !----------------------------------------------------------------------------! ! Given a real space vector in crystal coordinates rvec_cryst(3), ! which has coordinates on a nr1 x nr2 x nr3 grid, ! this subroutine finds the coordinates of the corresponding vector ! in the Wigner Seitz cell, namely the corresponding vector which is ! closest to the origin. !----------------------------------------------------------------------------! use intw_useful_constants , only : one , zero implicit none ! input real ( dp ), intent ( in ) :: at ( 3 , 3 ) ! the real space basis vectors real ( dp ), intent ( in ) :: rvec_cryst ( 3 ) ! the real space vector integer , intent ( in ) :: nr1 , nr2 , nr3 ! the real mesh parameters ! output real ( dp ), intent ( out ) :: rvec_WS_cryst ( 3 ) ! vector in the WS cell ! internal variables integer :: i , j , k ! the triple coordinates of k_1BZ integer :: Rlat ( 3 ) ! the translation vector real ( dp ) :: r_UC ( 3 ) ! temporary UC vector real ( dp ) :: r_WS ( 3 ) ! temporary WS vector real ( dp ) :: list_T ( 3 ) ! translation coefficients real ( dp ) :: T1 , T2 , T3 integer :: it1 , it2 , it3 real ( dp ) :: ai_dot_aj ( 3 , 3 ) ! inner product of basis vectors real ( dp ) :: square_norm real ( dp ) :: minimum_square_norm ! First, find the coordinates of the vector in the unit cell coordinates ! Note that the subroutine below was initially designed for reciprocal ! space, but the relevant algorithm is the same. call find_k_1BZ_and_G ( rvec_cryst , nr1 , nr2 , nr3 , i , j , k , r_UC , Rlat ) ai_dot_aj = matmul ( at (:,:), transpose ( at (:,:))) list_T (:) = ( / - one , zero , one / ) ! initialize minimum_square_norm = dot_product ( r_UC , matmul ( ai_dot_aj (:,:), r_UC )) rvec_WS_cryst (:) = r_UC (:) do it1 = 1 , 3 T1 = list_T ( it1 ) do it2 = 1 , 3 T2 = list_T ( it2 ) do it3 = 1 , 3 T3 = list_T ( it3 ) ! Define a possible vector in cartesian coordinates as ! r_WS = sum_{i=1}&#94;3 rvec_US(i) a_i ! ! its norm&#94;2 is given by r_WS*r_WS r_WS (:) = r_UC (:) + ( / T1 , T2 , T3 / ) square_norm = dot_product ( r_WS , matmul ( ai_dot_aj (:,:), r_WS )) if ( square_norm < minimum_square_norm ) then minimum_square_norm = square_norm rvec_WS_cryst (:) = r_WS (:) end if end do !it3 end do !it2 end do !it1 end subroutine find_r_in_WS_cell subroutine errore ( a , b , i ) character ( len =* ), intent ( in ) :: a , b integer :: i write ( * , * ) \"ERROR:\" , a , b , i stop end subroutine errore subroutine simpson ( mesh , func , rab , asum ) !----------------------------------------------------------------------- ! !     simpson's rule integration. On input: !       mesh = mhe number of grid points (should be odd) !       func(i)= function to be integrated !       rab(i) = r(i) * dr(i)/di * di !     For the logarithmic grid not including r=0 : !       r(i) = r_0*exp((i-1)*dx) ==> rab(i)=r(i)*dx !     For the logarithmic grid including r=0 : !       r(i) = a(exp((i-1)*dx)-1) ==> rab(i)=(r(i)+a)*dx !     Output in asum = \\sum_i c_i f(i)*rab(i) = \\int_0&#94;\\infty f(r) dr !     where c_i are alternativaly 2/3, 4/3 except c_1 = c_mesh = 1/3 ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2001 PWSCF group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! implicit none integer , intent ( in ) :: mesh real ( DP ), intent ( in ) :: rab ( mesh ), func ( mesh ) real ( DP ), intent ( out ) :: asum ! real ( DP ) :: f1 , f2 , f3 , r12 integer :: i ! !     routine assumes that mesh is an odd number so run check !     if ( mesh+1 - ( (mesh+1) / 2 ) * 2 .ne. 1 ) then !       write(*,*) '***error in subroutine radlg' !       write(*,*) 'routine assumes mesh is odd but mesh =',mesh+1 !       stop !     endif asum = 0.0d0 r12 = 1.0d0 / 1 2.0d0 f3 = func ( 1 ) * rab ( 1 ) * r12 do i = 2 , mesh - 1 , 2 f1 = f3 f2 = func ( i ) * rab ( i ) * r12 f3 = func ( i + 1 ) * rab ( i + 1 ) * r12 asum = asum + 4.0d0 * f1 + 1 6.0d0 * f2 + 4.0d0 * f3 enddo return end subroutine simpson function qe_erf ( x ) !--------------------------------------------------------------------- ! !     Error function - computed from the rational approximations of !     W. J. Cody, Math. Comp. 22 (1969), pages 631-637. ! !     for abs(x) le 0.47 erf is calculated directly !     for abs(x) gt 0.47 erf is calculated via erf(x)=1-erfc(x) ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2002-2009 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! use kinds , only : DP implicit none real ( DP ), intent ( in ) :: x real ( DP ) :: x2 , p1 ( 4 ), q1 ( 4 ) !real(DP), external :: qe_erfc real ( DP ) :: qe_erf data p1 / 2.426679552305318E2_DP , 2.197926161829415E1_DP , & 6.996383488619136_DP , - 3.560984370181538E-2_DP / data q1 / 2.150588758698612E2_DP , 9.116490540451490E1_DP , & 1.508279763040779E1_DP , 1.000000000000000_DP / ! if ( abs ( x ) > 6.0_DP ) then ! !  erf(6)=1-10&#94;(-17) cannot be distinguished from 1 ! qe_erf = sign ( 1.0_DP , x ) else if ( abs ( x ) <= 0.47_DP ) then x2 = x ** 2 qe_erf = x * ( p1 ( 1 ) + x2 * ( p1 ( 2 ) + x2 * ( p1 ( 3 ) + x2 * p1 ( 4 ) ) ) ) & / ( q1 ( 1 ) + x2 * ( q1 ( 2 ) + x2 * ( q1 ( 3 ) + x2 * q1 ( 4 ) ) ) ) else qe_erf = 1.0_DP - qe_erfc ( x ) endif endif ! return end function qe_erf function qe_erfc ( x ) !--------------------------------------------------------------------- ! !     erfc(x) = 1-erf(x)  - See comments in erf ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2002-2009 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! use kinds , only : DP implicit none real ( DP ), intent ( in ) :: x real ( DP ) :: qe_erfc real ( DP ) :: ax , x2 , xm2 , p2 ( 8 ), q2 ( 8 ), p3 ( 5 ), q3 ( 5 ), pim1 !real(DP), external :: qe_erf data p2 / 3.004592610201616E2_DP , 4.519189537118719E2_DP , & 3.393208167343437E2_DP , 1.529892850469404E2_DP , & 4.316222722205674E1_DP , 7.211758250883094_DP , & 5.641955174789740E-1_DP , - 1.368648573827167E-7_DP / data q2 / 3.004592609569833E2_DP , 7.909509253278980E2_DP , & 9.313540948506096E2_DP , 6.389802644656312E2_DP , & 2.775854447439876E2_DP , 7.700015293522947E1_DP , & 1.278272731962942E1_DP , 1.000000000000000_DP / data p3 /- 2.996107077035422E-3_DP , - 4.947309106232507E-2_DP , & - 2.269565935396869E-1_DP , - 2.786613086096478E-1_DP , & - 2.231924597341847E-2_DP / data q3 / 1.062092305284679E-2_DP , 1.913089261078298E-1_DP , & 1.051675107067932_DP , 1.987332018171353_DP , & 1.000000000000000_DP / data pim1 / 0.56418958354775629_DP / !        ( pim1= sqrt(1/pi) ) ax = abs ( x ) if ( ax > 2 6.0_DP ) then ! !  erfc(26.0)=10&#94;(-296); erfc( 9.0)=10&#94;(-37); ! qe_erfc = 0.0_DP elseif ( ax > 4.0_DP ) then x2 = x ** 2 xm2 = ( 1.0_DP / ax ) ** 2 qe_erfc = ( 1.0_DP / ax ) * exp ( - x2 ) * ( pim1 + xm2 * ( p3 ( 1 ) & + xm2 * ( p3 ( 2 ) + xm2 * ( p3 ( 3 ) + xm2 * ( p3 ( 4 ) + xm2 * p3 ( 5 ) & ) ) ) ) / ( q3 ( 1 ) + xm2 * ( q3 ( 2 ) + xm2 * ( q3 ( 3 ) + xm2 * & ( q3 ( 4 ) + xm2 * q3 ( 5 ) ) ) ) ) ) elseif ( ax > 0.47_DP ) then x2 = x ** 2 qe_erfc = exp ( - x2 ) * ( p2 ( 1 ) + ax * ( p2 ( 2 ) + ax * ( p2 ( 3 ) & + ax * ( p2 ( 4 ) + ax * ( p2 ( 5 ) + ax * ( p2 ( 6 ) + ax * ( p2 ( 7 ) & + ax * p2 ( 8 ) ) ) ) ) ) ) ) / ( q2 ( 1 ) + ax * ( q2 ( 2 ) + ax * & ( q2 ( 3 ) + ax * ( q2 ( 4 ) + ax * ( q2 ( 5 ) + ax * ( q2 ( 6 ) + ax * & ( q2 ( 7 ) + ax * q2 ( 8 ) ) ) ) ) ) ) ) else qe_erfc = 1.0_DP - qe_erf ( ax ) endif ! ! erf(-x)=-erf(x)  =>  erfc(-x) = 2-erfc(x) ! if ( x < 0.0_DP ) qe_erfc = 2.0_DP - qe_erfc ! return end function qe_erfc recursive function sphb ( n , x ) result ( sphb_ ) ! ! Spherical bessel functions ! use intw_useful_constants , only : ZERO , ONE implicit none real ( kind = dp ), intent ( in ) :: x (:) integer , intent ( in ) :: n real ( kind = dp ) :: sphb_ ( size ( x )) integer :: i0 if ( any ( x < ZERO )) stop \"ERROR: sphb\" do i0 = 1 , size ( x ) if ( abs ( x ( i0 )) > epsilon ( x ( 1 ))) exit enddo if ( n == 0 ) then sphb_ (: i0 - 1 ) = ONE sphb_ ( i0 :) = sin ( x ( i0 :)) / x ( i0 :) else if ( n == 1 ) then sphb_ (: i0 - 1 ) = ZERO sphb_ ( i0 :) = ( sin ( x ( i0 :)) / x ( i0 :) - cos ( x ( i0 :)) ) / x ( i0 :) else if ( n == 2 ) then sphb_ (: i0 - 1 ) = ZERO sphb_ ( i0 :) = ( 3.0_dp / x ( i0 :) ** 2 - 1 ) * sin ( x ( i0 :)) / x ( i0 :) - 3.0_dp * cos ( x ( i0 :)) / x ( i0 :) ** 2 else if ( n == 3 ) then sphb_ (: i0 - 1 ) = ZERO sphb_ ( i0 :) = ( 1 5.0_dp / x ( i0 :) ** 2 - 6.0_dp ) * sin ( x ( i0 :)) / x ( i0 :) ** 2 - ( 1 5.0_dp / x ( i0 :) ** 2 - 1.0_dp ) * cos ( x ( i0 :)) / x ( i0 :) else if ( n >= 4 ) then sphb_ = - sphb ( n - 2 , x ) + ( 2 * n - 1 ) * sphb ( n - 1 , x ) / x end if end function sphb subroutine real_ylmr2 ( lmax , ng , g , gg , ylm ) !----------------------------------------------------------------------- ! Real spherical harmonics ylm(G) up to l=lmax ! lmax2 = (lmax+1)&#94;2 is the total number of spherical harmonics ! Numerical recursive algorithm based on the one given in Numerical ! Recipes but avoiding the calculation of factorials that generate ! overflow for lmax > 11 !----------------------------------------------------------------------- ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2001 PWSCF group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! use kinds , only : dp use intw_useful_constants , only : pi , tpi , fpi ! implicit none ! integer , intent ( in ) :: lmax , ng real ( kind = dp ), intent ( in ) :: g ( 3 , ng ), gg ( ng ) real ( kind = dp ), intent ( out ) :: ylm ( ng ,( lmax + 1 ) ** 2 ) ! ! local variables real ( kind = dp ), parameter :: eps = 1.0d-9 real ( kind = dp ) :: cost ( ng ), sent ( ng ), phi ( ng ) real ( kind = dp ) :: Q ( ng , 0 : lmax , 0 : lmax ) real ( kind = dp ) :: c , gmod integer :: lmax2 , ig , l , m , lm if ( ng < 1 . or . lmax < 1 ) return lmax2 = ( lmax + 1 ) ** 2 if ( lmax == 0 ) then ylm (:, 1 ) = sqrt ( 1.d0 / fpi ) return end if ! !  theta and phi are polar angles, cost = cos(theta) ! !$omp parallel default(none) & !$omp shared(ng,g,gg,cost,phi,sent) & !$omp private(ig,gmod) !$omp do do ig = 1 , ng gmod = sqrt ( gg ( ig )) if ( gmod < eps ) then cost ( ig ) = 0.d0 else cost ( ig ) = g ( 3 , ig ) / gmod endif ! !  beware the arc tan, it is defined modulo pi ! if ( g ( 1 , ig ) > eps ) then phi ( ig ) = atan ( g ( 2 , ig ) / g ( 1 , ig ) ) else if ( g ( 1 , ig ) < - eps ) then phi ( ig ) = atan ( g ( 2 , ig ) / g ( 1 , ig ) ) + pi else phi ( ig ) = sign ( pi / 2.d0 , g ( 2 , ig ) ) end if sent ( ig ) = sqrt ( max ( 0 d0 , 1.d0 - cost ( ig ) ** 2 )) enddo ! !$omp end parallel ! !  Q(:,l,m) are defined as sqrt ((l-m)!/(l+m)!) * P(:,l,m) where !  P(:,l,m) are the Legendre Polynomials (0 <= m <= l) ! lm = 0 do l = 0 , lmax ! c = sqrt ( dble ( 2 * l + 1 ) / fpi ) if ( l == 0 ) then Q (:, 0 , 0 ) = 1.d0 else if ( l == 1 ) then Q (:, 1 , 0 ) = cost (:) Q (:, 1 , 1 ) =- sent (:) / sqrt ( 2.d0 ) else ! !  recursion on l for Q(:,l,m) ! do m = 0 , l - 2 Q (:, l , m ) = cost (:) * ( 2 * l - 1 ) / sqrt ( DBLE ( l * l - m * m )) * Q (:, l - 1 , m ) & - sqrt ( DBLE (( l - 1 ) * ( l - 1 ) - m * m )) / sqrt ( DBLE ( l * l - m * m )) * Q (:, l - 2 , m ) end do Q (:, l , l - 1 ) = cost (:) * sqrt ( DBLE ( 2 * l - 1 )) * Q (:, l - 1 , l - 1 ) Q (:, l , l ) = - sqrt ( DBLE ( 2 * l - 1 )) / sqrt ( DBLE ( 2 * l )) * sent (:) * Q (:, l - 1 , l - 1 ) end if ! ! Y_lm, m = 0 ! lm = lm + 1 ylm (:, lm ) = c * Q (:, l , 0 ) ! do m = 1 , l ! ! Y_lm, m > 0 ! lm = lm + 1 ylm (:, lm ) = c * sqrt ( 2.d0 ) * Q (:, l , m ) * cos ( m * phi (:)) ! ! Y_lm, m < 0 ! lm = lm + 1 ylm (:, lm ) = c * sqrt ( 2.d0 ) * Q (:, l , m ) * sin ( m * phi (:)) end do ! end do end subroutine real_ylmr2 ! subroutine complex_ylmr2(lmax, ng, g, gg, ylm) !   !----------------------------------------------------------------------- !   !     INTW project !   !     Complex spherical harmonics ylm(G) up to l=lmax !   !     lmax2 = (lmax+1)&#94;2 is the total number of spherical harmonics !   !----------------------------------------------------------------------- ! !   use kinds, only: dp !   use intw_useful_constants, only: pi, tpi, fpi ! !   implicit none ! !   integer, intent(in) :: lmax, ng !   real(kind=dp), intent(in) :: g(3,ng), gg(ng) !   complex(kind=dp), intent(out) :: ylm(ng,(lmax+1)**2) ! !   real(kind=dp), parameter :: eps = 1.0d-9 !   integer :: lmax2 ! ! !   lmax2 =(lmax+1)**2 ! !   ylm=(0.0_dp,0.0_dp) ! ! end subroutine complex_ylmr2 ! MBR 24/04/24 ! smearing functions for integrals function smeared_delta ( x , s ) !gaussian use kinds , only : dp use intw_useful_constants , only : tpi implicit none real ( dp ) :: x , s , smeared_delta if ( - 4 * s < x . and . x < 4 * s ) then smeared_delta = exp ( - 0.5_dp * ( x / s ) ** 2 ) / ( s * sqrt ( tpi )) else smeared_delta = 0.0_dp endif end function smeared_delta function smeared_lorentz ( x , s ) ! MBR 280624 use kinds , only : dp use intw_useful_constants , only : pi implicit none real ( dp ) :: x , s , smeared_lorentz smeared_lorentz = s / ( pi * ( s * s + x * x )) end function smeared_lorentz function fermi_dirac ( x , kt ) ! x = energy - e_fermi, kT = Boltzmann * temp, same units use kinds , only : dp use intw_useful_constants , only : tpi implicit none real ( dp ) :: x , kt , fermi_dirac if ( x < - 5 * kt ) then fermi_dirac = 1.0_dp else if ( x > 5 * kt ) then fermi_dirac = 0.0_dp else fermi_dirac = 1.0_dp / ( exp ( x / kt ) + 1.0_dp ) endif end function fermi_dirac function int2str ( i ) implicit none integer , intent ( in ) :: i character ( len = 16 ) :: f1 , frm , int2str write ( f1 , \"(I8)\" ) floor ( log10 ( i * 1.0 ) + 1 ) frm = \"i\" // trim ( adjustl ( f1 )) write ( int2str , \"(\" // trim ( frm ) // \")\" ) i end function int2str SUBROUTINE dosplineint ( old_mesh , old_vec , new_mesh , new_vec ) ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2004-2006 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! IMPLICIT NONE ! REAL ( DP ), INTENT ( IN ) :: old_mesh (:), new_mesh (:) REAL ( DP ), INTENT ( IN ) :: old_vec (:) REAL ( DP ), INTENT ( OUT ) :: new_vec (:) ! REAL ( DP ), ALLOCATABLE :: d2y (:) INTEGER :: i INTEGER :: old_dim , new_dim ! ! old_dim = SIZE ( old_vec ) new_dim = SIZE ( new_vec ) ! ! IF ( old_dim /= SIZE( old_mesh ) ) CALL errore( 'dosplineint', 'dimensions of old_mesh and old_vec do not match', 1 ) IF ( old_dim /= SIZE ( old_mesh ) ) stop 'ERROR: dosplineint: dimensions of old_mesh and old_vec do not match' ! ! IF ( new_dim /= SIZE( new_mesh ) ) CALL errore( 'dosplineint', 'dimensions of new_mesh and new_vec do not match', 1 ) IF ( new_dim /= SIZE ( new_mesh ) ) stop 'ERROR: dosplineint: dimensions of new_mesh and new_vec do not match' ! ALLOCATE ( d2y ( old_dim ) ) ! d2y = 0 ! CALL spline ( old_mesh , old_vec (:), 0.0_DP , 0.0_DP , d2y ) ! DO i = 1 , new_dim ! new_vec ( i ) = splint ( old_mesh , old_vec (:), d2y , new_mesh ( i ) ) ! END DO ! DEALLOCATE ( d2y ) ! END SUBROUTINE dosplineint SUBROUTINE spline ( xdata , ydata , startu , startd , d2y ) ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2004-2006 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! IMPLICIT NONE ! REAL ( DP ), INTENT ( IN ) :: xdata (:), ydata (:), startu , startd REAL ( DP ), INTENT ( OUT ) :: d2y (:) ! INTEGER :: i , k , ydim REAL ( DP ) :: p , sig REAL ( DP ), ALLOCATABLE :: u (:) ! ! ydim = SIZE ( ydata ) ! ALLOCATE ( u ( ydim ) ) ! u ( 1 ) = startu d2y ( 1 ) = startd ! DO i = 2 , ydim - 1 ! sig = ( xdata ( i ) - xdata ( i - 1 ) ) / ( xdata ( i + 1 ) - xdata ( i - 1 ) ) p = sig * d2y ( i - 1 ) + 2.0_DP d2y ( i ) = ( sig - 1.0_DP ) / p u ( i ) = ( 6.0_DP * ( ( ydata ( i + 1 ) - ydata ( i ) ) / & ( xdata ( i + 1 ) - xdata ( i ) ) - ( ydata ( i ) - ydata ( i - 1 ) ) / & ( xdata ( i ) - xdata ( i - 1 ) ) ) / & ( xdata ( i + 1 ) - xdata ( i - 1 ) ) - sig * u ( i - 1 ) ) / p ! END DO ! d2y ( ydim ) = 0 ! DO k = ydim - 1 , 1 , - 1 ! d2y ( k ) = d2y ( k ) * d2y ( k + 1 ) + u ( k ) ! END DO ! DEALLOCATE ( u ) ! END SUBROUTINE spline FUNCTION splint ( xdata , ydata , d2y , x ) ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2004-2006 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! IMPLICIT NONE ! REAL ( DP ), INTENT ( IN ) :: xdata (:), ydata (:), d2y (:) REAL ( DP ), INTENT ( IN ) :: x ! REAL ( DP ) :: splint INTEGER :: khi , klo , xdim REAL ( DP ) :: a , b , h ! ! xdim = SIZE ( xdata ) ! klo = 1 khi = xdim ! klo = MAX ( MIN ( locate ( xdata , x ), ( xdim - 1 ) ), 1 ) ! khi = klo + 1 ! h = xdata ( khi ) - xdata ( klo ) ! a = ( xdata ( khi ) - x ) / h b = ( x - xdata ( klo ) ) / h ! splint = a * ydata ( klo ) + b * ydata ( khi ) + & ( ( a ** 3 - a ) * d2y ( klo ) + ( b ** 3 - b ) * d2y ( khi ) ) * & ( h ** 2 ) / 6.0_DP END FUNCTION splint FUNCTION locate ( xx , x ) ! ! This subroutine is originally distributed as part of the Quantum Espresso code and has ! been adapted to INTW: !   Copyright (C) 2004-2006 Quantum ESPRESSO group !   Distributed under the terms of the GNU General Public License. !   See the LICENSE file in the original Quantum Espresso source for license details. !   For the original source visit: https://www.quantum-espresso.org/ ! IMPLICIT NONE ! REAL ( DP ), INTENT ( IN ) :: xx (:) REAL ( DP ), INTENT ( IN ) :: x ! INTEGER :: locate INTEGER :: n , jl , jm , ju LOGICAL :: ascnd ! ! n = SIZE ( xx ) ascnd = ( xx ( n ) >= xx ( 1 ) ) jl = 0 ju = n + 1 ! main_loop : DO ! IF ( ( ju - jl ) <= 1 ) EXIT main_loop ! jm = ( ju + jl ) / 2 ! IF ( ascnd . EQV . ( x >= xx ( jm ) ) ) THEN ! jl = jm ! ELSE ! ju = jm ! END IF ! END DO main_loop ! IF ( x == xx ( 1 ) ) THEN ! locate = 1 ! ELSE IF ( x == xx ( n ) ) THEN ! locate = n - 1 ! ELSE ! locate = jl ! END IF ! END FUNCTION locate subroutine print_threads () ! Gets total number of threads used and prints it to the output ! ! NOTE: ! At this moment INTW only uses 2 nested parallel levels ! (see MAX_NESTED_LEVELS parameter below), and the limit ! of nested active parallel levels is set explicitly with ! omp_set_max_active_levels routine (see below) to ! improve performance. #ifdef _OPENMP use omp_lib , only : omp_get_num_threads , omp_get_num_procs , & omp_set_max_active_levels #endif implicit none #ifdef _OPENMP integer , parameter :: MAX_NESTED_LEVELS = 2 integer :: nthreads_level1 , nthreads_level2 , nthreads_total ! Get thread number in each parallel level !$omp parallel !$omp master nthreads_level1 = omp_get_num_threads () !$omp end master !$omp parallel !$omp master nthreads_level2 = omp_get_num_threads () !$omp end master !$omp end parallel !$omp end parallel ! Total thread number nthreads_total = nthreads_level1 * nthreads_level2 ! Print thread number if ( nthreads_total == 1 ) then write ( * , '(\"|     Running parallel version with \",I5,\" thread    |\")' ) nthreads_total else write ( * , '(\"|     Running parallel version with \",I5,\" threads   |\")' ) nthreads_total endif ! Print warning if number of cores is smaller than thread number if ( nthreads_total > omp_get_num_procs ()) & write ( * , '(\"|     WARNING: Only \",I5,\" cores available           |\")' ) omp_get_num_procs () ! Set max nested parallel levels if ( nthreads_level1 == 1 . or . nthreads_level2 == 1 ) then call omp_set_max_active_levels ( 1 ) else call omp_set_max_active_levels ( MAX_NESTED_LEVELS ) endif #else write ( * , '(\"|     Running serial version                        |\")' ) #endif end subroutine print_threads subroutine print_date_time ( status ) ! Gets current date and time, and prints it to the output implicit none character ( len = 18 ), intent ( in ) :: status integer , dimension ( 8 ) :: values integer :: iyear , imonth , iday , ihour , imin , isec character ( len = 3 ), parameter :: months ( 12 ) = ( / 'Jan' , 'Feb' , 'Mar' , 'Apr' , 'May' , 'Jun' , & 'Jul' , 'Aug' , 'Sep' , 'Oct' , 'Nov' , 'Dec' / ) ! Get the current date and time call date_and_time ( VALUES = values ) iyear = values ( 1 ) imonth = values ( 2 ) iday = values ( 3 ) ihour = values ( 5 ) imin = values ( 6 ) isec = values ( 7 ) ! Print the date and time with the status write ( * , '(\"|     \",A18,\": \",I2.2,\"-\",A3,\"-\",I4.4,\" \",I2.2,\":\",I2.2,\":\",I2.2,\"      |\")' ) & adjustl ( status ), iday , months ( imonth ), iyear , ihour , imin , isec end subroutine print_date_time end module intw_utility","tags":"","url":"sourcefile/utility.f90.html"},{"title":"a2F_on_trFS.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! program a2F_on_trFS !! display: none !! !! Calculate Eliashberg function from electron-phonon coupling !! matrix elements interpolated on a triangulated Fermi surface. !! !! ### Details !! !! a2F integral = double loop on kpoints of the FS triangulation. !! The ep element calculated for q=k'-k is read from a file. !! The needed phonons and dynamical matrices calculated by QE are !! read in and then interpolated as in the method of: !! F. Giustino et al, Phys. Rev. B 76, 165108 (2007) !! !! MBR 26/04/2024 !! !! #### Input parameters !! !! ```{.txt} !! &input !!     outdir                = 'directory' !!     prefix                = 'prefix' !!     TR_symmetry           = T or F !!     use_exclude_bands     = 'none', 'wannier' or 'custom' !!     include_bands_initial = integer !!     include_bands_final   = integer !! / !! &ph !!     qlist           = 'file' !!     read_for_dynmat = 'fc' or 'dynq' !!     fc_mat          = 'file' !!     nq1             = integer !!     nq2             = integer !!     nq3             = integer !!     nqirr           = integer !!     apply_asr       = T or F !! / !! &DOS_ph !!     nomega    = integer !!     omega_ini = real !!     omega_fin = real !!     osmear_q  = real !!     omega_cut = real !! / !! &elphon !!     ep_interp_bands     = 'intw_bands' or 'ef_crossing' !!     nfs_sheets_initial  = integer !!     nfs_sheets_final    = integer !! / !! ``` !! !! See [[intw_input_parameters]] module for the description of each parameter. !! use kinds , only : dp use intw_version , only : print_intw_version use intw_useful_constants , only : cmplx_1 , cmplx_0 , cmplx_i , Ha_to_Ry , tpi , eps_8 , eps_6 use intw_utility , only : get_timing , print_threads , print_date_time , find_free_unit , & cryst_to_cart , generate_kmesh , & smeared_delta , smeared_lorentz , fermi_dirac use intw_matrix_vector , only : ainv , area_vec use intw_input_parameters , only : outdir , prefix , read_input , & nq1 , nq2 , nq3 , nqirr , fc_mat , & nomega , omega_ini , omega_fin , osmear_q , omega_cut , & read_for_dynmat , & ep_interp_bands , nfs_sheets_initial , nfs_sheets_final use intw_reading , only : read_parameters_data_file , & nspin , lspin , at , volume0 , alat , nat , ityp , amass , & num_bands_intw , nsym , tau use intw_ph , only : nqmesh , qmesh , QE_folder_nosym_q , QE_folder_sym_q , & symlink_q , q_irr_cryst , & read_ph_information use intw_ph_interpolate , only : dyn_q , w2_q , u_q , dyn_diagonalize_1q , & dyn_q_to_dyn_r , dyn_interp_1q , & allocate_and_build_ws_irvec_qtau , & allocate_and_build_dyn_qmesh , & allocate_and_build_dyn_qmesh_from_fc use intw_symmetries , only : rtau , rtau_cryst , rtau_index , rot_atoms , find_size_of_irreducible_k_set , & set_symmetry_relations , find_inverse_symmetry_matrices_indices implicit none logical :: read_status logical :: full_mesh_q , IBZ_q character ( 5 ) :: is_loc , comenta character ( 100 ) :: file_off , file_a2f integer :: unit_off , unit_a2f integer :: nkpt_tr_tot , nkpt_tr_ibz_tot integer :: qmesh_nqirr integer :: is , js , ik , ik1 , iq , i , j , k , iface , ir1 , ir2 , ir3 integer :: nfs_sheets_tot ! number of sheets considered integer , allocatable :: nfs_sheet (:), & ! band indices of the sheets (num_bands_intw set) nkpt_tr (:), & ! number of kpoints in each FS sheet nkpt_tr_ibz (:), & ! number of kpoints in each FS sheet irreducible BZ wedge nface_tr (:), & ! number of faces in each FS sheet nface_tr_ibz (:) ! number of faces in each IFS real ( dp ) :: k1 ( 3 ), k2 ( 3 ), k3 ( 3 ), kwei , vol1bz real ( dp ), allocatable :: kpts_tr (:,:), kpts_tr_area (:), vk_tr (:,:), vabsk_tr (:), & kpts_tr_ibz (:,:), kpts_tr_ibz_area (:), vk_tr_ibz (:,:), vabsk_tr_ibz (:) real ( dp ), allocatable :: area_ibz (:), area_fbz (:), factor_area_ibz (:) logical :: have_ep character ( 256 ) :: file_ep integer :: ib , iat , imode , ikp , unit_ep integer :: iomega , iks , ish , iksp , ishp , ibp real ( dp ) :: omega , omega_step , rfacq , dosef , dsk_vk_2 real ( dp ) :: qpoint ( 3 ), kpoint ( 3 ), kpoint_p ( 3 ) real ( dp ), allocatable :: alpha2F (:,:), w2_qint (:), w_qint (:), lambda (:) complex ( dp ), allocatable :: gep_int (:) complex ( dp ), allocatable :: dyn_qint (:,:), u_qint (:,:) complex ( dp ), allocatable :: aep_mat_el (:,:,:,:,:) ! From mat_inv_four_t, see IGG's comments ! TODO add to useful_constants real ( dp ), parameter :: pmass = 182 2.88848426_dp , aumev = 2721 1.396d0 ! timing real ( dp ) :: time1 , time2 20 format ( A ) 30 format ( A , F8 . 2 , 6 X , A ) !================================================================================ ! Beginning !================================================================================ call get_timing ( time1 ) write ( * , 20 ) '=====================================================' write ( * , 20 ) '|                program a2F_on_triFS               |' write ( * , 20 ) '|         Eliashberg function calculation           |' write ( * , 20 ) '|    from interpolated ep elements on the FS        |' write ( * , 20 ) '|         ---------------------------------         |' call print_intw_version () call print_threads () call print_date_time ( \"Start of execution\" ) write ( * , 20 ) '=====================================================' !================================================================================ ! Read the input file !================================================================================ call read_input ( read_status ) if ( read_status ) stop !================================================================================ ! Read the parameters from the SCF calculation !================================================================================ write ( * , 20 ) '| - Reading calculation parameters...               |' call read_parameters_data_file () !================================================================================ ! Print spin information !================================================================================ if ( lspin ) then write ( * , 20 ) '| - Spin-polarized calculation nspin = 2            |' else write ( * , 20 ) '| - Paramagnetic calculation nspin = 1              |' endif write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Choose Fermi surface sheets according to ep_interp_bands !================================================================================ if ( ep_interp_bands == 'intw_bands' ) then nfs_sheets_tot = num_bands_intw allocate ( nfs_sheet ( nfs_sheets_tot )) do ib = 1 , num_bands_intw nfs_sheet ( ib ) = ib end do else if ( ep_interp_bands == 'ef_crossing' ) then nfs_sheets_tot = nfs_sheets_final - nfs_sheets_initial + 1 allocate ( nfs_sheet ( nfs_sheets_tot )) do ib = 1 , nfs_sheets_tot nfs_sheet ( ib ) = nfs_sheets_initial + ib - 1 end do end if !================================================================================ ! Set symmetry arrays !================================================================================ write ( * , 20 ) '| - Setting symmetry arrays...                      |' ! Set the rotation table for each atom and symmetry allocate ( rtau_index ( nat , nsym )) allocate ( rtau ( 3 , nsym , nat )) allocate ( rtau_cryst ( 3 , nsym , nat )) call rot_atoms ( nat , nsym , tau ) ! Compute the indices of the inverse rotation matrices call find_inverse_symmetry_matrices_indices () write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Read prefix.off and velocity file(s) !================================================================================ write ( * , 20 ) '=====================================================' write ( * , 20 ) '| - Reading .off and v_k files...                   |' allocate ( nkpt_tr ( nfs_sheets_tot ), nface_tr ( nfs_sheets_tot )) allocate ( nkpt_tr_ibz ( nfs_sheets_tot ), nface_tr_ibz ( nfs_sheets_tot )) ! open all sheet files just to see dimensions of kpoint lists do is = 1 , nfs_sheets_tot if ( is < 10 ) write ( is_loc , \"(i1)\" ) nfs_sheet ( is ) if ( 10 <= is . and . is < 100 ) write ( is_loc , \"(i2)\" ) nfs_sheet ( is ) file_off = trim ( outdir ) // trim ( prefix ) // trim ( '.' ) // trim ( adjustl ( is_loc )) // trim ( '_FS_tri.off' ) write ( * , '(A)' ) '|     ' // file_off ( 1 : max ( 45 , len ( trim ( file_off )))) // ' |' unit_off = find_free_unit () open ( unit_off , file = file_off , status = 'old' ) read ( unit_off , * ) comenta read ( unit_off , * ) nkpt_tr ( is ), nface_tr ( is ), k ! number of vertices and faces (ignore edges) close ( unit_off ) ! open the IBZ off file and search for dimension nkpt_tr_ibz(is). ! Its vertices coincide with the first nkpt_tr_ibz(is) vertices of the full off vertex list. file_off = trim ( outdir ) // trim ( prefix ) // trim ( '.' ) // trim ( adjustl ( is_loc )) // trim ( '_IBZ_FS_tri.off' ) unit_off = find_free_unit () open ( unit_off , file = file_off , status = 'old' ) read ( unit_off , * ) comenta read ( unit_off , * ) nkpt_tr_ibz ( is ), nface_tr_ibz ( is ), k ! number of vertices and faces (ignore rest) close ( unit_off ) end do ! total number of k-points to be calculated nkpt_tr_tot = sum ( nkpt_tr ) nkpt_tr_ibz_tot = sum ( nkpt_tr_ibz ) write ( * , 20 ) '|   Number of k-points (total vertices):            |' write ( * , '(A1,3X,I6,42X,A1)' ) '|' , nkpt_tr_tot , '|' write ( * , 20 ) '|   Number of k-points in IBZ (total vertices):     |' write ( * , '(A1,3X,I6,42X,A1)' ) '|' , nkpt_tr_ibz_tot , '|' write ( * , 20 ) '|   Number of faces (total triangles):              |' write ( * , '(A1,3X,I6,42X,A1)' ) '|' , sum ( nface_tr ), '|' write ( * , 20 ) '|   Number of faces in IBZ (total triangles):       |' write ( * , '(A1,3X,I6,42X,A1)' ) '|' , sum ( nface_tr_ibz ), '|' allocate ( kpts_tr_ibz ( 3 , nkpt_tr_ibz_tot ), kpts_tr_ibz_area ( nkpt_tr_ibz_tot )) allocate ( kpts_tr ( 3 , nkpt_tr_tot ), kpts_tr_area ( nkpt_tr_tot )) allocate ( vk_tr_ibz ( 3 , nkpt_tr_ibz_tot ), vabsk_tr_ibz ( nkpt_tr_ibz_tot )) allocate ( vk_tr ( 3 , nkpt_tr_tot ), vabsk_tr ( nkpt_tr_tot )) kpts_tr_ibz_area = 0.0_dp kpts_tr_area = 0.0_dp ! open .off files again to read k-points and read also velocity files ik1 = 0 do is = 1 , nfs_sheets_tot if ( is < 10 ) write ( is_loc , \"(i1)\" ) nfs_sheet ( is ) if ( 10 <= is . and . is < 100 ) write ( is_loc , \"(i2)\" ) nfs_sheet ( is ) ! .off file for this sheet file_off = trim ( outdir ) // trim ( prefix ) // trim ( '.' ) // trim ( adjustl ( is_loc )) // trim ( '_FS_tri.off' ) unit_off = find_free_unit () open ( unit_off , file = file_off , status = 'old' ) read ( unit_off , * ) comenta read ( unit_off , * ) i , j , k ! number vertices, faces and edges (I will ignore edges) ! read(unit_off,'(/)') ! DUDA... This will depend on how the line break is written in the file, I think... if ( ( i /= nkpt_tr ( is )) . or . ( j /= nface_tr ( is )) ) then write ( * , * ) 'Error reading ' , file_off , '. Stopping.' stop end if ! read vertices do ik = 1 , nkpt_tr ( is ) read ( unit_off , * ) kpts_tr (:, ik1 + ik ) ! units in the trFS.off file are cartesian 2pi/alat (\"tpiba\" for QE) end do ! Read (triangular) faces on this sheet. ! Each face contributes with 1/3 of its area to the effective area of each of its vertices. ! Calculate the are on the go and add the contribution to each vertex, storing for global indices (i.e. ik1+ik). do iface = 1 , nface_tr ( is ) read ( unit_off , * ) i , ir1 , ir2 , ir3 ! indices ik of the vertices of the face, indexed from 0 ir1 = ir1 + 1 ir2 = ir2 + 1 ir3 = ir3 + 1 ! now, ik of the vertices of the face, indexed from 1 if ( i /= 3 ) then write ( * , * ) 'Error reading ' , file_off , 'Only triangles allowed. Stopping.' stop end if ! triangle vertex vectors (cartesian 2pi/alat) k1 = kpts_tr (:, ik1 + ir1 ) k2 = kpts_tr (:, ik1 + ir2 ) k3 = kpts_tr (:, ik1 + ir3 ) ! get spanned area and add contribution to each vertex ! function copied from FSH/modules/geometry.f90 kwei = area_vec ( k2 - k1 , k3 - k1 ) / 3.0_dp kpts_tr_area ( ik1 + ir1 ) = kpts_tr_area ( ik1 + ir1 ) + kwei kpts_tr_area ( ik1 + ir2 ) = kpts_tr_area ( ik1 + ir2 ) + kwei kpts_tr_area ( ik1 + ir3 ) = kpts_tr_area ( ik1 + ir3 ) + kwei end do close ( unit_off ) ! velocity for this sheet (use same unit) file_off = trim ( outdir ) // trim ( prefix ) // trim ( '.' ) // trim ( adjustl ( is_loc )) // trim ( '_FS_tri_v_k.dat' ) unit_off = find_free_unit () open ( unit_off , file = file_off , status = 'old' ) read ( unit_off , * ) i if ( i /= nkpt_tr ( is ) ) then write ( * , * ) 'Error reading ' , file_off , '. Stopping.' stop end if do ik = 1 , nkpt_tr ( is ) read ( unit_off , * ) i , vk_tr (:, ik1 + ik ), vabsk_tr ( ik1 + ik ) ! velocity xyz and its modulus. DUDA 2pi/alat??? end do close ( unit_off ) ! accumulate ik global index for the reading of next sheet ik1 = ik1 + nkpt_tr ( is ) end do ! MBR correction 100724 ! now do the same with IBZ .off files to obtain the triangle areas there ik1 = 0 do is = 1 , nfs_sheets_tot if ( is < 10 ) write ( is_loc , \"(i1)\" ) nfs_sheet ( is ) if ( 10 <= is . and . is < 100 ) write ( is_loc , \"(i2)\" ) nfs_sheet ( is ) ! .off file for this sheet file_off = trim ( outdir ) // trim ( prefix ) // trim ( '.' ) // trim ( adjustl ( is_loc )) // trim ( '_IBZ_FS_tri.off' ) unit_off = find_free_unit () open ( unit_off , file = file_off , status = 'old' ) read ( unit_off , * ) comenta read ( unit_off , * ) i , j , k ! number vertices, faces and edges (I will ignore edges) ! read(unit_off,'(/)') ! DUDA... This will depend on how the line break is written in the file, I think... if ( ( i /= nkpt_tr_ibz ( is )) . or . ( j /= nface_tr_ibz ( is )) ) then write ( * , * ) 'Error reading ' , file_off , '. Stopping.' stop end if ! read vertices (actually, these are repeated from the first nkpt_tr_ibz(is) lines of the full BZ file) do ik = 1 , nkpt_tr_ibz ( is ) read ( unit_off , * ) kpts_tr_ibz (:, ik1 + ik ) ! units in the trFS.off file are cartesian 2pi/alat (\"tpiba\" for QE) end do ! Read (triangular) faces on this sheet. ! Each face contributes with 1/3 of its area to the effective area of each of its vertices. ! Calculate the are on the go and add the contribution to each vertex, storing for global indices (i.e. ik1+ik). do iface = 1 , nface_tr_ibz ( is ) read ( unit_off , * ) i , ir1 , ir2 , ir3 ! indices ik of the vertices of the face, indexed from 0 ir1 = ir1 + 1 ir2 = ir2 + 1 ir3 = ir3 + 1 ! now, ik of the vertices of the face, indexed from 1 if ( i /= 3 ) then write ( * , * ) 'Error reading ' , file_off , 'Only triangles allowed. Stopping.' stop end if ! triangle vertex vectors (cartesian 2pi/alat) k1 = kpts_tr_ibz (:, ik1 + ir1 ) k2 = kpts_tr_ibz (:, ik1 + ir2 ) k3 = kpts_tr_ibz (:, ik1 + ir3 ) ! get spanned area and add contribution to each vertex ! function copied from FSH/modules/geometry.f90 kwei = area_vec ( k2 - k1 , k3 - k1 ) / 3.0_dp kpts_tr_ibz_area ( ik1 + ir1 ) = kpts_tr_ibz_area ( ik1 + ir1 ) + kwei kpts_tr_ibz_area ( ik1 + ir2 ) = kpts_tr_ibz_area ( ik1 + ir2 ) + kwei kpts_tr_ibz_area ( ik1 + ir3 ) = kpts_tr_ibz_area ( ik1 + ir3 ) + kwei end do close ( unit_off ) ! velocity for this sheet (use same unit) file_off = trim ( outdir ) // trim ( prefix ) // trim ( '.' ) // trim ( adjustl ( is_loc )) // trim ( '_IBZ_FS_tri_v_k.dat' ) unit_off = find_free_unit () open ( unit_off , file = file_off , status = 'old' ) read ( unit_off , * ) i if ( i /= nkpt_tr_ibz ( is ) ) then write ( * , * ) 'Error reading ' , file_off , '. Stopping.' stop end if do ik = 1 , nkpt_tr_ibz ( is ) read ( unit_off , * ) i , vk_tr_ibz (:, ik1 + ik ), vabsk_tr_ibz ( ik1 + ik ) ! velocity xyz and its modulus (in units 2pi/alat, Hartree a.u.) end do close ( unit_off ) ! accumulate ik global index for the reading of next sheet ik1 = ik1 + nkpt_tr_ibz ( is ) end do write ( * , 20 ) '|   ...reading done                                 |' ! Calculate triangle areas for calculating the a2F integral later allocate ( area_fbz ( nfs_sheets_tot ), area_ibz ( nfs_sheets_tot ), factor_area_ibz ( nfs_sheets_tot )) area_ibz = 0.0_dp ik = 0 do ish = 1 , nfs_sheets_tot do iks = 1 , nkpt_tr_ibz ( ish ) ik = ik + 1 area_ibz ( ish ) = area_ibz ( ish ) + kpts_tr_ibz_area ( ik ) end do end do area_fbz = 0.0_dp ik = 0 do ish = 1 , nfs_sheets_tot do iks = 1 , nkpt_tr ( ish ) ik = ik + 1 area_fbz ( ish ) = area_fbz ( ish ) + kpts_tr_area ( ik ) end do end do do ish = 1 , nfs_sheets_tot factor_area_ibz ( ish ) = area_fbz ( ish ) / area_ibz ( ish ) end do write ( * , '(A36,F12.6,4X,A1)' ) '|   FS area in full BZ (tpiba&#94;2) =   ' , sum ( area_fbz (:)), '|' do ish = 1 , nfs_sheets_tot write ( * , '(A10,I3,F12.6,27X,A1)' ) '|      is ' , ish , area_fbz ( ish ), '|' enddo write ( * , '(A36,F12.6,4X,A1)' ) '|   FS area in irr  BZ (tpiba&#94;2) =   ' , sum ( area_ibz (:)), '|' do ish = 1 , nfs_sheets_tot write ( * , '(A10,I3,F12.6,27X,A1)' ) '|      is ' , ish , area_ibz ( ish ), '|' enddo write ( * , '(A36,F12.6,4X,A1)' ) '|   FS area ratio (full / irr BZ) = ' , sum ( factor_area_ibz (:)), '|' do ish = 1 , nfs_sheets_tot write ( * , '(A10,I3,F12.6,27X,A1)' ) '|      is ' , ish , factor_area_ibz ( ish ), '|' enddo ! N(EF) from sum over vertices, all sheets, using full triangulated mesh dosef = 0.0_dp do ik = 1 , nkpt_tr_tot dosef = dosef + kpts_tr_area ( ik ) * ( tpi / alat ) ** 2 / ( vabsk_tr ( ik ) * Ha_to_Ry ) ! velocities in Hartree a.u., pass to Ry end do vol1bz = tpi ** 3 / volume0 dosef = dosef / vol1bz ! in Ry&#94;-1 write ( * , '(A29,F12.6,11X,A1)' ) '|   Volume of BZ (bohr&#94;-3) = ' , vol1bz , '|' write ( * , '(A29,F12.6,11X,A1)' ) '|   DOS at FS (Ry&#94;-1) =      ' , dosef , '|' write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Read all the information about phonons and prepare for interpolation of phonons: ! Calculate dynamical matrices in qmesh and transform to real space !================================================================================ write ( * , 20 ) '| - Reading phonon info...                          |' ! Read q-points and irreducible patterns call read_ph_information () !================================================================================ ! Build the phonon q-mesh !================================================================================ write ( * , 20 ) '| - Building q-mesh...                              |' nqmesh = nq1 * nq2 * nq3 allocate ( qmesh ( 3 , nqmesh )) call generate_kmesh ( qmesh , nq1 , nq2 , nq3 ) ! Find the size of the irreducible set of q-points (IBZ) call find_size_of_irreducible_k_set ( nq1 , nq2 , nq3 , qmesh_nqirr ) !================================================================================ ! Set symmetry relations between irreducible q-points and full q-mesh !================================================================================ allocate ( QE_folder_nosym_q ( nqmesh )) allocate ( QE_folder_sym_q ( nqmesh )) allocate ( symlink_q ( nqmesh , 2 )) call set_symmetry_relations ( nq1 , nq2 , nq3 , nqirr , q_irr_cryst , & QE_folder_nosym_q , QE_folder_sym_q , symlink_q , & full_mesh_q , IBZ_q ) !================================================================================ ! Check that the number of q-points corresponds to either a full mesh or the IBZ !================================================================================ if ( full_mesh_q . and . IBZ_q ) then write ( * , 20 ) '| - The qpoints present in the QE folders           |' write ( * , 20 ) '|   are consistent with a full 1BZ and a            |' write ( * , 20 ) '|   IBZ has also been found.                        |' else if ( IBZ_q ) then write ( * , 20 ) '| - The qpoints present in the QE folders           |' write ( * , 20 ) '|   are consistent with an IBZ.                     |' else write ( * , 20 ) '**********************************************************' write ( * , 20 ) '* The qpoints present in the QE folders are not consistent' write ( * , 20 ) '* with the parameters of the input file!                 ' write ( * , 20 ) '**********************************************************' write ( * , 20 ) '* debug information:                                *' write ( * , * ) '*        nqpoints_QE = ' , nqirr write ( * , * ) '*        nqmesh      = ' , nqmesh write ( * , * ) '*        qmesh_nqirr = ' , qmesh_nqirr stop end if !================================================================================ ! Get dynamical matrices. Two options to get dyn_q: !  - Read dyn files. !  - Read the force constants and transfor to q space !================================================================================ write ( * , 20 ) '| - Reading dynamical matrices...                   |' if ( read_for_dynmat == 'fc' ) then ! read force constants call allocate_and_build_dyn_qmesh_from_fc ( fc_mat ) else if ( read_for_dynmat == 'dynq' ) then ! read dyn files call allocate_and_build_dyn_qmesh () end if ! diagonalize do iq = 1 , nqmesh qpoint = qmesh (:, iq ) call dyn_diagonalize_1q ( 3 * nat , dyn_q (:,:, iq ), u_q (:,:, iq ), w2_q (:, iq )) end do !================================================================================ ! Wigner-Seitz cells !================================================================================ write ( * , 20 ) '| - Building WS cells...                            |' ! This Wigner-Seitz mesh will be needed to interpolate phonons below ! (q->R space will be done on that grid of nrpts_q lattice points). call allocate_and_build_ws_irvec_qtau () !================================================================================ ! Transform dynamical matrices to real space (force constants) !================================================================================ write ( * , 20 ) '| - Computing force constants...                    |' call dyn_q_to_dyn_r () ! test decay of dyn_r elements with distance ! do ir=1,nrpts_q !   rcart = real(irvec_q(:,ir),dp) !   call cryst_to_cart(1, rcart, at, 1) !   rcart = rcart * alat ! bohr units !   write(1000,'(i5,f16.6,8e16.4)') ir, sqrt ( sum(rcart*rcart) ), & !           abs(dyn_r(1,1,ir)), abs(dyn_r(1,2,ir)), abs(dyn_r(1,4,ir)), abs(dyn_r(1,5,ir)) ! end do write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Read ep elements file !================================================================================ write ( * , 20 ) '| - Reading ep_mat files...                         |' file_ep = trim ( outdir ) // trim ( prefix ) // trim ( '_ep_interp.dat' ) inquire ( file = file_ep , exist = have_ep ) if (. not . have_ep ) then write ( * , * ) '!      e-p elements interpolated and written to file:         !' write ( * , * ) trim ( file_ep ) write ( * , * ) '!      e-p elements file does not exist:                      !' write ( * , * ) '!      Stopping                                               !' stop else ! Note, indices ikp,ik include all the calculated sheets allocate ( aep_mat_el ( nkpt_tr_tot , nkpt_tr_ibz_tot , nspin , nspin , 3 * nat )) unit_ep = find_free_unit () open ( unit_ep , file = file_ep , status = 'old' ) read ( unit_ep , * ) comenta do ik = 1 , nkpt_tr_ibz_tot do ikp = 1 , nkpt_tr_tot do js = 1 , nspin do is = 1 , nspin read ( unit_ep , fmt = \"(6i6,100e16.6)\" ) ibp , iksp , j , ib , iks , i ,& ( aep_mat_el ( ikp , ik , js , is , iat ), iat = 1 , 3 * nat ) if ( i /= ik ) stop \"ik wrong\" if ( j /= ikp ) stop \"ikp wrong\" end do end do end do end do close ( unit_ep ) end if write ( * , 20 ) '|   ...reading done                                 |' write ( * , 20 ) '|         ---------------------------------         |' !================================================================================ ! Calculate a2F integral !================================================================================ ! phonon arrays allocate ( dyn_qint ( 3 * nat , 3 * nat ), u_qint ( 3 * nat , 3 * nat ), w2_qint ( 3 * nat ), w_qint ( 3 * nat )) ! ep elements allocate ( gep_int ( 3 * nat )) ! integrals allocate ( alpha2F ( 3 * nat , nomega ), lambda ( 3 * nat )) alpha2F = 0.0_dp lambda = 0.0_dp ! Energy range for Eliashberg is read from intw.in ! with Ry units throughout. ! Step in energy for integrals and phonon DOS: omega_step = ( omega_fin - omega_ini ) / real ( nomega - 1 , dp ) write ( * , 20 ) '| - Calculating a2F...                              |' ! ik, ikp indices implicitly contain the FS sheet index, i.e. the band indices ib, ib' ! to be selected, so instead of iterating over nkpt_tr_tot, I separate over sheets ik = 0 ik1 = 0 do ish = 1 , nfs_sheets_tot ib = nfs_sheet ( ish ) ! band index for k do iks = 1 , nkpt_tr_ibz ( ish ) ! ik is the k-index over nkpt_tr_tot in the Irreducible BZ ik = ik + 1 kpoint = kpts_tr_ibz (:, ik ) ! this is cartesians x 2pi/alat. Transform to cryst. call cryst_to_cart ( 1 , kpoint , at , - 1 ) ikp = 0 do ishp = 1 , nfs_sheets_tot ibp = nfs_sheet ( ishp ) ! band index for k' do iksp = 1 , nkpt_tr ( ishp ) ikp = ikp + 1 ! k'-index over nkpt_tr_tot kpoint_p = kpts_tr (:, ikp ) ! this is cartesians x 2pi/alat. Transform to cryst. call cryst_to_cart ( 1 , kpoint_p , at , - 1 ) qpoint = kpoint_p - kpoint ! interpolate phonon: call dyn_interp_1q ( qpoint , dyn_qint ) call dyn_diagonalize_1q ( 3 * nat , dyn_qint , u_qint , w2_qint ) w_qint = sign ( sqrt ( abs ( w2_qint )), w2_qint ) ! u_qint contains the polarization vector (each column is a mode) ! phonon frequency in a.u.: pass to Ry w_qint = w_qint * Ha_to_Ry ! Generate ep elements with the added mass factor and polarization vector ! component for each mode and sum over modes. ! In the eigenvector matrix u_qint, each column is a mode. Rows are individual atom displacements. ! The matrix elements g are given for atom displacements and I want them as a ! function of modes to compare with QE a2F.dos* files ! band indices to be used are the FS sheet indices given at the beginning of the loop. ! I select only those ones for the interpolated elements gep_int = cmplx_0 do imode = 1 , 3 * nat ! if ( w_qint ( imode ) > eps_8 ) then ! stable mode frequency do iat = 1 , 3 * nat k = ( iat - 1 ) / 3 + 1 ! atom index rfacq = 2.0_dp * w_qint ( imode ) * amass ( ityp ( k )) * ( pmass / Ha_to_Ry ) ! pmass is in Ha a.u., so pass to Ry gep_int ( imode ) = gep_int ( imode ) + & sum ( aep_mat_el ( ikp , ik ,:,:, iat )) * u_qint ( iat , imode ) / sqrt ( rfacq ) end do end if ! ! for testing: ! write(2000, fmt=\"(5i6,2e16.6)\") ikp, ik, ibp, ib, imode, w_qint(imode), abs(gep_int(imode)) ! end do ! Sum over modes and weight with areas and velocities v_k * v_k' for contribution of k',k pair to a2F. ! Mind, the areas were in (tpi/alat)**2 units. ! Add weight of this irreducible wedge (IBZ) to the integral using factor_area_ibz. dsk_vk_2 = kpts_tr_ibz_area ( ik ) * factor_area_ibz ( ish ) * kpts_tr_area ( ikp ) * & ( tpi / alat ) ** 4 / ( vabsk_tr_ibz ( ik ) * vabsk_tr ( ikp ) * Ha_to_Ry * Ha_to_Ry ) ! velocities in Hartree a.u., pass to Ry do iomega = 1 , nomega ! frequencies omega = omega_ini + omega_step * real ( iomega - 1 , dp ) do imode = 1 , 3 * nat ! smear with a gaussian rfacq = smeared_delta ( omega - w_qint ( imode ), osmear_q ) ! smear omega(q) rfacq = rfacq - smeared_delta ( omega + w_qint ( imode ), osmear_q ) ! add antisymmetric term at -wq to remove divergence at w=0 ! or with a lorentzian ! rfacq = smeared_lorentz(omega-w_qint(imode), osmear_q) ! smear omega(q) ! rfacq = rfacq - smeared_lorentz(omega+w_qint(imode), osmear_q) ! add antisymmetric term at -wq to remove divergence at w=0 alpha2F ( imode , iomega ) = alpha2F ( imode , iomega ) + & ( abs ( gep_int ( imode ))) ** 2 * rfacq * dsk_vk_2 end do ! imode end do ! iomega end do ! k' (kpoint) end do ! k' (sheet) end do ! k (kpoint) end do ! k (sheet) ! divide by the N(E_F) factor and by 1BZ-volume&#94;2 (because of k and k' integrals) alpha2F = alpha2F / dosef / vol1bz ** 2 ! Filter w -> 0 if ( omega_cut > 0.0_dp ) then do imode = 1 , 3 * nat ! Find a2F(omega_cut) do iomega = 1 , nomega omega = omega_ini + omega_step * real ( iomega - 1 , dp ) if ( omega > omega_cut ) then omega_cut = omega rfacq = alpha2F ( imode , iomega ) exit endif enddo ! Apply filter do iomega = 1 , nomega omega = omega_ini + omega_step * real ( iomega - 1 , dp ) alpha2F ( imode , iomega ) = rfacq * ( omega / omega_cut ) ** 2 * fermi_dirac ( omega - omega_cut , 0.1_dp * omega_cut ) & + alpha2F ( imode , iomega ) * ( 1.0_dp - fermi_dirac ( omega - omega_cut , 0.1_dp * omega_cut ) ) enddo enddo endif ! Save a2F file_a2f = trim ( outdir ) // trim ( prefix ) // trim ( '_a2F_interp.dat' ) unit_a2f = find_free_unit () open ( unit_a2f , file = file_a2f , status = 'unknown' ) write ( unit_a2f , '(A)' ) '#omega(Ry)  alpha2F(total)    alpha2F(1:nmode)' ! do iomega = 1 , nomega ! frequencies omega = omega_ini + ( iomega - 1 ) * omega_step write ( unit_a2f , '(e16.4,2x,100e16.4)' ) omega , sum ( alpha2F (:, iomega )), alpha2F (:, iomega ) end do ! Calculate lambda (mode resolved) lambda = 0.0_dp do iomega = 2 , nomega ! skip omega=0 value omega = omega_ini + ( iomega - 1 ) * omega_step lambda (:) = lambda (:) + alpha2F (:, iomega ) / omega end do lambda = 2.0_dp * lambda * omega_step ! Save lambda write ( unit_a2f , * ) '# lambda = 2 \\int dw a2F(w)/w for each mode' write ( unit_a2f , '(a,i3,a,20e14.4)' ) '# imode = ' , imode , ', lambda = ' , lambda (:) write ( unit_a2f , * ) '# total lambda = ' , sum ( lambda ) close ( unit_a2f ) write ( * , 20 ) '| - a2F calculated and written to file:             |' write ( * , 20 ) \"|   \" // file_a2f ( 1 : max ( 47 , len ( trim ( file_a2f )))) // \" |\" write ( * , 20 ) '=====================================================' !================================================================================ ! Finish !================================================================================ call get_timing ( time2 ) write ( * , 20 ) '|                      ALL DONE                     |' write ( * , 30 ) '|     Total time: ' , time2 - time1 , ' seconds            |' call print_date_time ( 'End of execution  ' ) write ( * , 20 ) '=====================================================' end program a2F_on_trFS","tags":"","url":"sourcefile/a2f_on_trfs.f90.html"},{"title":"kinds.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module kinds !! display: none !! !! This module defines kind parameters for specifying the precision !! of real and integer variables. !! implicit none INTEGER , PARAMETER :: DP = selected_real_kind ( 14 , 200 ) INTEGER , PARAMETER :: sgl = selected_real_kind ( 6 , 30 ) INTEGER , PARAMETER :: SP = sgl INTEGER , PARAMETER :: i4b = selected_int_kind ( 9 ) end module kinds","tags":"","url":"sourcefile/kinds.f90.html"},{"title":"matrix_elements.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_matrix_elements !! display: none !! !! This module contains subroutines for computing matrix elements of operators !! between wave functions, particularly for plane wave matrix elements. !! use kinds , only : dp implicit none ! ! subroutines public :: get_plane_wave_matrix_element_convolution_map , & get_plane_wave_matrix_element_FFT , & compute_index_interpolation_mesh , & get_spin_component , & wfc_G_from_1D_to_3D ! private ! contains subroutine get_plane_wave_matrix_element_convolution_map ( G , list_iG_1 , ngk1 , list_iG_2 , ngk2 , wfc_1 , wfc_2 , pw_mat_el ) !-------------------------------------------------------------------------------------------------- ! Given two wavefunctions wfc_1 and wfc_2, this subroutine computes ! !              < wfc_1 | e&#94;{-i G r} | wfc_2 > ! ! where wfc is the periodic part of the wavefunction: !              u(r) = sum_G' e&#94;{i G' r} wfc(G'); ! ! which leads to !              < wfc_1 | e&#94;{-i G r} | wfc_2 > = sum_G1 wfc_1(G1)&#94;* wfc_2(G1+G). ! ! The computation is done over all bands. ! ! The G-vectors are referenced by their indices in list_iG1, list_iG2, ! which refer to the global list gvec(1:3,1:nG), which should be defined ! BEFORE using this subroutine. !-------------------------------------------------------------------------------- use intw_useful_constants , only : zero , one , cmplx_0 use intw_reading , only : nGk_max , gvec , nspin , num_bands_intw use intw_fft , only : find_iG implicit none ! I/O variables integer , intent ( in ) :: G ( 3 ), ngk1 , ngk2 integer , intent ( in ) :: list_iG_1 ( nGk_max ), list_iG_2 ( nGk_max ) complex ( dp ), intent ( in ) :: wfc_1 ( nGk_max , num_bands_intw , nspin ), wfc_2 ( nGk_max , num_bands_intw , nspin ) complex ( dp ), intent ( out ) :: pw_mat_el ( num_bands_intw , num_bands_intw , nspin , nspin ) ! local variables integer :: i , j , ibnd , jbnd , is , js , iG_1 pw_mat_el = cmplx_0 !$omp parallel do reduction(+: pw_mat_el) & !$omp default(none) & !$omp shared(num_bands_intw, nspin, nGk_max, gvec, G) & !$omp shared(list_iG_1, ngk1, wfc_1, list_iG_2, wfc_2) & !$omp private(i, j, iG_1, ibnd, jbnd, is, js) do i = 1 , nGk1 ! call find_iG ( gvec (:, list_iG_1 ( i )) + G , iG_1 ) ! j = findloc ( list_iG_2 , iG_1 , DIM = 1 ) ! if ( j == 0 ) cycle ! do js = 1 , nspin do is = 1 , nspin do jbnd = 1 , num_bands_intw do ibnd = 1 , num_bands_intw ! pw_mat_el ( ibnd , jbnd , is , js ) = pw_mat_el ( ibnd , jbnd , is , js ) & + conjg ( wfc_1 ( i , ibnd , is )) * wfc_2 ( j , jbnd , js ) ! enddo !ibnd enddo !jbnd enddo !is enddo !js ! enddo ! i loop !$omp end parallel do end subroutine get_plane_wave_matrix_element_convolution_map subroutine get_plane_wave_matrix_element_FFT ( G , list_iG_1 , list_iG_2 , wfc_1 , wfc_2 , pw_mat_el ) !------------------------------------------------------------------------ ! Given two wavefunctions wfc_1 and wfc_2, this subroutine computes ! !              < wfc_1 | e&#94;{-i G r} | wfc_2 > ! ! where wfc is the periodic part of the wavefunction: !              u(r) = sum_G' e&#94;{i G' r} wfc(G'); ! ! which leads to !              < wfc_1 | e&#94;{-i G r} | wfc_2 > = sum_G1 wfc_1(G1)&#94;* wfc_2(G1+G) ! ! The computation is done over all bands. ! ! The G-vectors are referenced by their indices in list_iG1, list_iG2, ! which refer to the global list gvec(1:3,1:nG), which should be defined ! BEFORE using this subroutine. ! ! The matrix element is obtained using the FFT routines. !------------------------------------------------------------------------- use intw_fft , only : wfc_from_g_to_r , nl , find_iG use intw_reading , only : nr1 , nr2 , nr3 , nGk_max , nspin , num_bands_intw use intw_useful_constants , only : zero , one , cmplx_0 implicit none external :: cfftnd !I/O variables integer , intent ( in ) :: G ( 3 ) integer , intent ( in ) :: list_iG_1 ( nGk_max ), list_iG_2 ( nGk_max ) complex ( dp ), intent ( in ) :: wfc_1 ( nGk_max , num_bands_intw , nspin ), wfc_2 ( nGk_max , num_bands_intw , nspin ) complex ( dp ), intent ( inout ) :: pw_mat_el ( num_bands_intw , num_bands_intw , nspin , nspin ) !local variables integer :: iG , iG_fft , ir integer :: ibnd , jbnd , is , js complex ( dp ) :: wfc_r1 ( nr1 * nr2 * nr3 ), wfc_r2 ( nr1 * nr2 * nr3 ) complex ( dp ) :: uu ( nr1 * nr2 * nr3 ) pw_mat_el = cmplx_0 ! ! find the index of G in the global list gvec ! call find_iG ( G , iG ) ! ! find its scalar FFT index ! iG_fft = nl ( iG ) ! !loop on spin (diagonal is, js) ! do is = 1 , nspin do js = 1 , nspin ! ! loop on bands ! do ibnd = 1 , num_bands_intw ! ! fourier- transform the 1st wavefunction ! call wfc_from_g_to_r ( list_iG_1 , wfc_1 (:, ibnd , is ), wfc_r1 ) ! do jbnd = 1 , num_bands_intw ! ! fourier- transform the 2nd wavefunction ! call wfc_from_g_to_r ( list_iG_2 , wfc_2 (:, jbnd , js ), wfc_r2 ) ! ! compute the product in real space ! do ir = 1 , nr1 * nr2 * nr3 ! uu ( ir ) = conjg ( wfc_r1 ( ir )) * wfc_r2 ( ir ) ! enddo !ir ! ! FFT to G in place ! call cfftnd(3,nr,1,uu) ! CONVENTION BY ASIER ! call cfftnd ( 3 , ( / nr1 , nr2 , nr3 / ), - 1 , uu ) ! OPPOSITE CONVENTION ! this convention reproduces ! the results of pw2wannier EXACTLY ! ! extract the desired component ! pw_mat_el ( ibnd , jbnd , is , js ) = pw_mat_el ( ibnd , jbnd , is , js ) + uu ( iG_fft ) ! Sum is over the spin. ! enddo !jbnd enddo !ibnd enddo !js enddo !is end subroutine get_plane_wave_matrix_element_FFT subroutine compute_index_interpolation_mesh ( iqpt , list_ikpt1 , list_G1 , list_ikpt2 , list_G2 ) !----------------------------------------------------------------------------! ! This routine will be useful in computing matrix elements of the form: !              < psi{n1 k} | e&#94;{-i (G+q) r} | psi_{n2 k+q} >. ! ! Assume: !              k   = k1 + G1 !              k+q = k2 + G2 ! ! where k1,k2 are in the mesh describing the 1BZ. ! ! This subroutine, given the index of a qpoint, computes G1, G2, k1, k2 ! for all k in a mesh appropriate for cubic interpolation. !-------------------------------------------------------------------------------- use intw_input_parameters , only : nk1 , nk2 , nk3 use intw_useful_constants , only : zero , one use intw_utility , only : triple_to_joint_index_g , joint_to_triple_index_g implicit none ! triple indices integer :: i_k , j_k , k_k ! triple indices for k integer :: i_k1 , j_k1 , k_k1 ! triple indices for k1 integer :: i_k2 , j_k2 , k_k2 ! triple indices for k2 integer :: i_kq , j_kq , k_kq ! triple indices for k+q integer :: i_q , j_q , k_q ! triple indices for q ! scalar indices integer :: ikpt1 ! scalar index for k1 integer :: ikpt2 ! scalar index for k2 integer :: iqpt ! scalar index for q integer :: icm ! i cubic mesh: loop index over the extended mesh integer :: G1 ( 3 ) integer :: G2 ( 3 ) integer :: list_G1 ( 3 ,( nk1 + 3 ) * ( nk2 + 3 ) * ( nk3 + 3 )) integer :: list_G2 ( 3 ,( nk1 + 3 ) * ( nk2 + 3 ) * ( nk3 + 3 )) integer :: list_ikpt1 (( nk1 + 3 ) * ( nk2 + 3 ) * ( nk3 + 3 )) integer :: list_ikpt2 (( nk1 + 3 ) * ( nk2 + 3 ) * ( nk3 + 3 )) ! find the triple of indices which corresponds to iqpt call joint_to_triple_index_g ( nk1 , nk2 , nk3 , iqpt , i_q , j_q , k_q ) ! loop over the mesh points for a cubic interpolation, ! including the extra layers. ! the third index, k, loops fastest! ! loop over the extended mesh, indentifying G1,G2, ikpt1 ikpt2 icm = 0 do i_k = 0 , nk1 + 2 G1 ( 1 ) = floor ( 1.0_dp * ( i_k - 1 ) / nk1 ) i_k1 = i_k - nk1 * G1 ( 1 ) i_kq = i_k + i_q G2 ( 1 ) = floor ( 1.0_dp * ( i_kq - 1 ) / nk1 ) i_k2 = i_kq - nk1 * G2 ( 1 ) do j_k = 0 , nk2 + 2 G1 ( 2 ) = floor ( 1.0_dp * ( j_k - 1 ) / nk2 ) j_k1 = j_k - nk2 * G1 ( 2 ) j_kq = j_k + j_q G2 ( 2 ) = floor ( 1.0_dp * ( j_kq - 1 ) / nk2 ) j_k2 = j_kq - nk2 * G2 ( 2 ) do k_k = 0 , nk3 + 2 G1 ( 3 ) = floor ( 1.0_dp * ( k_k - 1 ) / nk3 ) k_k1 = k_k - nk3 * G1 ( 3 ) k_kq = k_k + k_q G2 ( 3 ) = floor ( 1.0_dp * ( k_kq - 1 ) / nk3 ) k_k2 = k_kq - nk3 * G2 ( 3 ) ! find the indices call triple_to_joint_index_g ( nk1 , nk2 , nk3 , ikpt1 , i_k1 , j_k1 , k_k1 ) call triple_to_joint_index_g ( nk1 , nk2 , nk3 , ikpt2 , i_k2 , j_k2 , k_k2 ) icm = icm + 1 ! increment the mesh index ! save list_ikpt1 ( icm ) = ikpt1 list_ikpt2 ( icm ) = ikpt2 list_G1 (:, icm ) = G1 list_G2 (:, icm ) = G2 end do end do end do end subroutine compute_index_interpolation_mesh subroutine get_spin_component ( wfc , spin ) !------------------------------------------------------------------------------- ! Given wavefunction wfc, this subroutine computes ! !              < wfc | sigma_alpha | wfc > ! ! where wfc is the periodic part of the wavefunction: !              u(r) = sum_G e&#94;{i G r} wfc(G); ! ! The computation is done over all bands. !-------------------------------------------------------------------------------- use intw_useful_constants , only : zero , one , cmplx_0 , sig_x , sig_y , sig_z use intw_reading , only : nGk_max , nspin , num_bands_intw implicit none !I/O variables complex ( dp ), intent ( in ) :: wfc ( nGk_max , num_bands_intw , nspin ) complex ( dp ), intent ( out ) :: spin ( num_bands_intw , 3 ) !local variables integer :: ibnd , is , js , iG spin = cmplx_0 ! do iG = 1 , nGk_max ! do ibnd = 1 , num_bands_intw do is = 1 , nspin do js = 1 , nspin ! spin ( ibnd , 1 ) = spin ( ibnd , 1 ) + 0.5d0 * conjg ( wfc ( iG , ibnd , is )) * sig_x ( is , js ) * wfc ( iG , ibnd , js ) ! spin ( ibnd , 2 ) = spin ( ibnd , 2 ) + 0.5d0 * conjg ( wfc ( iG , ibnd , is )) * sig_y ( is , js ) * wfc ( iG , ibnd , js ) ! spin ( ibnd , 3 ) = spin ( ibnd , 3 ) + 0.5d0 * conjg ( wfc ( iG , ibnd , is )) * sig_z ( is , js ) * wfc ( iG , ibnd , js ) ! enddo !js enddo !is enddo !ibnd ! enddo !iG end subroutine get_spin_component subroutine wfc_G_from_1D_to_3D ( list_iG , wfc_G_1D , wfc_G_3D ) !-------------------------------------------------------- ! This subroutine puts a wavefunction, which is indexed ! by a scalar iG index, into a 3D array where the G ! vector is identified by a triple index. !-------------------------------------------------------- use intw_reading , only : nr1 , nr2 , nr3 , nGk_max , nspin , num_bands_intw use intw_useful_constants , only : zero , one , cmplx_0 use intw_utility , only : joint_to_triple_index_g use intw_fft , only : nl implicit none ! input integer , intent ( in ) :: list_iG ( nGk_max ) complex ( dp ), intent ( in ) :: wfc_G_1D ( nGk_max , num_bands_intw , nspin ) ! output complex ( dp ), intent ( out ) :: wfc_G_3D ( nr1 , nr2 , nr3 , num_bands_intw , nspin ) ! computation variables integer :: i , iG integer :: i_joint integer :: n1 , n2 , n3 ! initialize output array wfc_G_3D = cmplx_0 ! loop on all G vectors in the array do i = 1 , nGk_max ! identify the G vector by its index, as stored in list_iG iG = list_iG ( i ) if ( iG == 0 ) exit ! extract the scalar FFT index of this G vector i_joint = nl ( iG ) ! compute the triple index corresponding to iG call joint_to_triple_index_g ( nr1 , nr2 , nr3 , i_joint , n1 , n2 , n3 ) ! dump 1D wavefunction in 3D array ! careful! the wavefunction is indexed by i, not iG! wfc_G_3D ( n1 , n2 , n3 ,:,:) = wfc_G_1D ( i ,:,:) enddo end subroutine wfc_G_from_1D_to_3D end module intw_matrix_elements","tags":"","url":"sourcefile/matrix_elements.f90.html"},{"title":"interpolate_phonons.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! program interpolate_phonons !! display: none !! !! Interpolate phonon dispersion and DOS using Fourier interpolation. !! !! ### Details !! !! Uses atom-pair-adapted WS vectors to interpolate dynamical matrices. !! !! MBR June 2024 !! !! #### Input parameters !! !! ```{.txt} !! &input !!     outdir                = 'directory' !!     prefix                = 'prefix' !!     TR_symmetry           = T or F !!     use_exclude_bands     = 'none', 'wannier' or 'custom' !!     include_bands_initial = integer !!     include_bands_final   = integer !! / !! &ph !!     qlist           = 'file' !!     read_for_dynmat = 'fc' or 'dynq' !!     fc_mat          = 'file' !!     nq1             = integer !!     nq2             = integer !!     nq3             = integer !!     nqirr           = integer !!     apply_asr       = T or F !! / !! &DOS_ph !!     nq1_dosph = integer !!     nq2_dosph = integer !!     nq3_dosph = integer !!     nomega    = integer !!     omega_ini = real !!     omega_fin = real !!     osmear_q  = real !! / !! Q_PATH !!     nqpath nqspecial !!     label(1) qspecial_x(1) qspecial_y(1) qspecial_z(1) !!     label(2) qspecial_x(2) qspecial_y(2) qspecial_z(2) !!     ... !!     label(nqspecial) qspecial_x(nqspecial) qspecial_y(nqspecial) qspecial_z(nqspecial) !! ``` !! !! See [[intw_input_parameters]] module for the description of each parameter. !! #ifdef _OPENMP use omp_lib , only : omp_set_max_active_levels #endif use kinds , only : dp use intw_version , only : print_intw_version use intw_useful_constants , only : Ha_to_eV , tpi use intw_utility , only : get_timing , print_threads , print_date_time , find_free_unit , & generate_kmesh , cryst_to_cart , generate_and_allocate_kpath use intw_input_parameters , only : read_input , read_cards , & outdir , prefix , & nq1 , nq2 , nq3 , nqirr , fc_mat , & exist_qpath , nqpath , nqspecial , qspecial , & nq1_dosph , nq2_dosph , nq3_dosph , & nomega , omega_ini , omega_fin , osmear_q , read_for_dynmat use intw_reading , only : read_parameters_data_file , & nat , bg , at , tpiba , nsym , tau use intw_ph , only : nqmesh , qmesh , QE_folder_nosym_q , QE_folder_sym_q , & symlink_q , q_irr_cryst , & read_ph_information use intw_ph_interpolate , only : dyn_q , w2_q , u_q , dyn_diagonalize_1q , & dyn_q_to_dyn_r , dyn_interp_1q , & allocate_and_build_ws_irvec_qtau , & allocate_and_build_dyn_qmesh , & allocate_and_build_dyn_qmesh_from_fc , & interpolated_phonon_DOS use intw_symmetries , only : rtau , rtau_cryst , rtau_index , rot_atoms , find_size_of_irreducible_k_set , & set_symmetry_relations , find_inverse_symmetry_matrices_indices implicit none character ( 256 ) :: phband_file_name logical :: read_status logical :: full_mesh_q , IBZ_q integer :: iq , iomega , imode integer :: qmesh_nqirr integer :: ph_unit integer , allocatable :: qspecial_indices (:) real ( dp ) :: omega_step , omega real ( dp ) :: qpoint ( 3 ) real ( dp ), allocatable :: qpath (:,:), dqpath (:), dosph (:,:) real ( dp ), allocatable :: w2_qint (:), w_qint (:) complex ( dp ), allocatable :: dyn_qint (:,:), u_qint (:,:) ! timing real ( dp ) :: time1 , time2 20 format ( A ) 30 format ( A , F8 . 2 , 6 X , A ) ! ! !================================================================================ ! Beginning !================================================================================ ! call get_timing ( time1 ) ! write ( * , 20 ) '=====================================================' write ( * , 20 ) '|            program interpolate_phonons            |' write ( * , 20 ) '|         ---------------------------------         |' call print_intw_version () #ifdef _OPENMP call omp_set_max_active_levels ( 1 ) ! This utility usea a single active parallel level #endif call print_threads () call print_date_time ( \"Start of execution\" ) write ( * , 20 ) '=====================================================' ! ! !================================================================================ ! Read the necessary information from standard input file !================================================================================ ! call read_input ( read_status ) ! if ( read_status ) stop ! ! generate q-list for phonon bands plot with special points in Q_PATH call read_cards () if (. not . exist_qpath ) then write ( * , * ) 'Q_PATH not found. Phonon bands/DOS cannot be interpolated. Stopping.' stop end if ! ! !================================================================================ ! Read the parameters from the DFT calculation !================================================================================ ! write ( * , 20 ) '| - Reading calculation parameters...               |' ! call read_parameters_data_file () ! ! !================================================================================ ! Read phonon information !================================================================================ ! write ( * , 20 ) '| - Reading phonon info...                          |' ! ! Read q-points and irreducible patterns call read_ph_information () ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Build the phonon q-mesh !================================================================================ ! write ( * , 20 ) '| - Building q-mesh...                              |' ! nqmesh = nq1 * nq2 * nq3 allocate ( qmesh ( 3 , nqmesh )) ! call generate_kmesh ( qmesh , nq1 , nq2 , nq3 ) ! ! !================================================================================ ! Set symmetry arrays !================================================================================ ! write ( * , 20 ) '| - Setting symmetry arrays...                      |' ! ! Set the rotation table for each atom and symmetry allocate ( rtau_index ( nat , nsym )) allocate ( rtau ( 3 , nsym , nat )) allocate ( rtau_cryst ( 3 , nsym , nat )) ! call rot_atoms ( nat , nsym , tau ) ! ! Compute the indices of the inverse rotation matrices call find_inverse_symmetry_matrices_indices () ! ! !================================================================================ ! Symmetry relations between irreducible q-points and full q-mesh !================================================================================ ! allocate ( QE_folder_nosym_q ( nqmesh )) allocate ( QE_folder_sym_q ( nqmesh )) allocate ( symlink_q ( nqmesh , 2 )) ! ! Find the size of the irreducible set of q-points (IBZ) call find_size_of_irreducible_k_set ( nq1 , nq2 , nq3 , qmesh_nqirr ) ! call set_symmetry_relations ( nq1 , nq2 , nq3 , nqirr , q_irr_cryst , & QE_folder_nosym_q , QE_folder_sym_q , symlink_q , & full_mesh_q , IBZ_q ) ! ! !================================================================================ ! Check that the number of kpoints corresponds to either a full mesh or the IBZ !================================================================================ ! if ( full_mesh_q . and . IBZ_q ) then write ( * , 20 ) '| - The qpoints present in the QE folders           |' write ( * , 20 ) '|   are consistent with a full 1BZ and a            |' write ( * , 20 ) '|   IBZ has also been found.                        |' else if ( IBZ_q ) then write ( * , 20 ) '| - The qpoints present in the QE folders           |' write ( * , 20 ) '|   are consistent with an IBZ.                     |' else write ( * , * ) '**********************************************************' write ( * , * ) '* The qpoints present in the QE folders are not consistent' write ( * , * ) '* with the parameters of the input file!                 ' write ( * , * ) '**********************************************************' write ( * , * ) '* debug information:                                *' write ( * , * ) '*        nqpoints_QE = ' , nqirr write ( * , * ) '*        nqmesh      = ' , nqmesh write ( * , * ) '*        qmesh_nqirr = ' , qmesh_nqirr stop end if ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Get dynamical matrices. Two options to get dyn_q: !  - Read dyn files. !  - Read the force constants and transfor to q space !================================================================================ ! write ( * , 20 ) '| - Reading dynamical matrices...                   |' ! if ( read_for_dynmat == 'fc' ) then ! read force constants call allocate_and_build_dyn_qmesh_from_fc ( fc_mat ) else if ( read_for_dynmat == 'dynq' ) then ! read dyn files call allocate_and_build_dyn_qmesh () end if ! ! diagonalize do iq = 1 , nqmesh qpoint = qmesh (:, iq ) call dyn_diagonalize_1q ( 3 * nat , dyn_q (:,:, iq ), u_q (:,:, iq ), w2_q (:, iq )) end do ! ! !================================================================================ ! Wigner-Seitz cells !================================================================================ ! write ( * , 20 ) '| - Building WS cells...                            |' ! call allocate_and_build_ws_irvec_qtau () ! ! !================================================================================ ! Transform dynamical matrices to real space (force constants) !================================================================================ ! write ( * , 20 ) '| - Computing force constants...                    |' ! call dyn_q_to_dyn_r () ! ! test decay of dyn_r elements with distance ! do ir=1,nrpts_q !   rcart = real(irvec_q(:,ir),dp) !   call cryst_to_cart(1, rcart, at, 1) !   rcart = rcart * alat ! bohr units !   write(1000,'(i5,f16.6,8e16.4)') ir, sqrt ( sum(rcart*rcart) ), & !           abs(dyn_r(1,1,ir)), abs(dyn_r(1,2,ir)), abs(dyn_r(1,4,ir)), abs(dyn_r(1,5,ir)) ! end do ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Build qpoint path to plot bands. ! The nqpath number of points from the input might fluctuate. ! Use qspecial_indices option to print out the special q-points ! along the path (useful for plotting). !================================================================================ ! write ( * , 20 ) '| - Building q-path...                              |' ! call generate_and_allocate_kpath ( at , bg , tpiba , nqpath , nqspecial , qspecial , & qpath , dqpath , qspecial_indices ) ! ! !================================================================================ ! Interpolate on qpath for bands plot !================================================================================ ! write ( * , 20 ) '| - Computing phonon dispersion...                  |' ! allocate ( dyn_qint ( 3 * nat , 3 * nat ), u_qint ( 3 * nat , 3 * nat ), w2_qint ( 3 * nat ), w_qint ( 3 * nat )) ! phband_file_name = trim ( outdir ) // trim ( prefix ) // \".qbnd_int\" ph_unit = find_free_unit () open ( ph_unit , file = phband_file_name , status = 'unknown' ) write ( ph_unit , '(A)' ) '# q-point   omega(imode=1)[meV]  omega(2)[meV]   omega(3)[meV] ...' do iq = 1 , nqpath qpoint = qpath (:, iq ) call dyn_interp_1q ( qpoint , dyn_qint ) call dyn_diagonalize_1q ( 3 * nat , dyn_qint , u_qint , w2_qint ) ! freqs are given in a.u w_qint = sign ( sqrt ( abs ( w2_qint )), w2_qint ) * Ha_to_eV * 100 0.0_dp write ( ph_unit , '(100e14.6)' ) dqpath ( iq ), ( w_qint ( imode ), imode = 1 , 3 * nat ) ! meV ! write(ph_unit,'(100e14.6)') dqpath(iq)/tpiba, (w_qint(imode)*8.065610_dp, imode=1,3*nat) ! Matdyn (cm&#94;-1) ! write(ph_unit,'(100e14.6)') dqpath(iq)/tpi, (w_qint(imode)/4.135665538536_dp, imode=1,3*nat) ! Phonopy (tHz) end do ! deallocate ( dyn_qint , u_qint , w2_qint , w_qint ) ! ! Print special q-points information in the phonon bands file write ( ph_unit , * ) '#' write ( ph_unit , * ) '#Special q-points in the .qbnd_int file are:' do iq = 1 , nqspecial write ( ph_unit , '(a,3f10.4,a,i4,e14.6)' ) '#' , qspecial (:, iq ), ' --> ' , qspecial_indices ( iq ), dqpath ( qspecial_indices ( iq )) end do write ( ph_unit , * ) '#' ! close ( ph_unit ) ! write ( * , 20 ) '|   Phonon dispersion computed and written to:      |' write ( * , 20 ) \"|   \" // phband_file_name ( 1 : max ( 47 , len ( trim ( phband_file_name )))) // \" |\" ! write ( * , 20 ) '|         ---------------------------------         |' ! ! !================================================================================ ! Interpolate on fine q-grid for bands plot ! Parameters of DOS plot from namelist /DOS_ph/ !================================================================================ ! write ( * , 20 ) '| - Computing phonon DOS...                         |' ! allocate ( dosph ( 3 * nat , nomega )) ! call interpolated_phonon_DOS ( nq1_dosph , nq2_dosph , nq3_dosph , omega_ini , omega_fin , osmear_q , nomega , dosph ) ! ! Write DOS to file phband_file_name = trim ( outdir ) // trim ( prefix ) // \".qdos_int\" ph_unit = find_free_unit () open ( ph_unit , file = phband_file_name , status = 'unknown' ) ! write ( ph_unit , '(A)' ) '# omega[Ry]  phonon-DOS(total)  PDOS(imode=1)  PDOS(imode=2)  PDOS(imode=3) ...' ! omega_step = ( omega_fin - omega_ini ) / real ( nomega - 1 , dp ) do iomega = 1 , nomega omega = omega_ini + omega_step * real ( iomega - 1 , dp ) write ( ph_unit , '(100e14.6)' ) omega , sum ( dosph (:, iomega )), ( dosph ( imode , iomega ), imode = 1 , 3 * nat ) end do ! close ( ph_unit ) ! write ( * , 20 ) '| - DOS sum test:                                   |' write ( * , '(A19,I10,23X,A1)' ) '|   Number of modes = ' , 3 * nat , '|' write ( * , '(A19,F10.6,23X,A1)' ) '|   DOS integral = ' , omega_step * sum ( dosph (:,:)), '|' ! write ( * , 20 ) '|   Phonon DOS computed and written to:             |' write ( * , 20 ) '|   ' // phband_file_name ( 1 : max ( 47 , len ( trim ( phband_file_name )))) // ' |' ! write ( * , 20 ) '=====================================================' ! ! !================================================================================ ! Finish !================================================================================ ! call get_timing ( time2 ) ! write ( * , 20 ) '|                      ALL DONE                     |' write ( * , 30 ) '|     Total time: ' , time2 - time1 , ' seconds            |' call print_date_time ( 'End of execution  ' ) write ( * , 20 ) '=====================================================' end program interpolate_phonons","tags":"","url":"sourcefile/interpolate_phonons.f90.html"},{"title":"mesh_opt.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module triFS_mesh_opt !! display: none !! !! This module contains all the necessary subroutines for optimizing a !! triangulated FS mesh for [[triFS]] utility. !! use kinds , only : dp implicit none public :: mesh_optimization , newton_rap , check_border , vertices_related_by_SplusG , rotate_to_SplusG , & v2edge , edge_collapse , faces_vectors , inner_faces , find_neighbours , find_neighbours_vertex_list , & rm_3tri_vrtx , collapse_triangles , collapse_condition , tangential_relaxation , mean_barycenter private contains subroutine mesh_optimization ( collapse , relax , newton_raphson , collapse_criteria , relax_iter , newton_iter , & relax_vinface , eps_vinface , eps_dupv , verbose , ef , nrpts , irvec , ndegen , ham_r , & alat , at , bg , nsym , s , TR_sym , n_bnd , nfaces_IBZ , faces_IBZ_as_vert , vert_IBZ , & n_tri , n_vert , v_coord , v_index , v_veloc ) use triFS_isosurface , only : write_IBZ_isosurface , velocity_on_IBZ implicit none ! I/O logical , intent ( in ) :: collapse , relax ! Mesh optimization options integer , intent ( in ) :: newton_raphson real ( dp ), intent ( in ) :: collapse_criteria integer , intent ( in ) :: relax_iter , newton_iter logical , intent ( in ) :: relax_vinface real ( dp ), intent ( in ) :: eps_vinface , eps_dupv logical , intent ( in ) :: verbose real ( dp ), intent ( in ) :: ef ! Energy of isosurface integer , intent ( in ) :: nrpts , irvec ( 3 , nrpts ), ndegen ( nrpts ) ! Wannier/Fourier space variables integer , intent ( in ) :: n_bnd complex ( dp ), intent ( in ) :: ham_r ( n_bnd , n_bnd , nrpts ) ! Hamiltonian in Wannier basis real ( dp ), intent ( in ) :: alat , at ( 3 , 3 ), bg ( 3 , 3 ) ! real and reciprocal lattice vectors integer , intent ( in ) :: nsym , s ( 3 , 3 , nsym ) ! symmetry variables logical , intent ( in ) :: TR_sym ! time-reversal symmetry integer , intent ( in ) :: nfaces_IBZ integer , intent ( in ) :: faces_IBZ_as_vert (:,:) ! vertex indeces of IBZ big tetra faces real ( dp ), intent ( in ) :: vert_IBZ (:,:) ! IBZ big tetra vertex coordinates integer , intent ( inout ) :: n_tri ( n_bnd ), n_vert ( n_bnd ) real ( dp ), intent ( inout ) :: v_coord (:,:,:), v_veloc (:,:,:) integer , intent ( inout ) :: v_index (:,:,:) ! Local character ( len = 25 ) :: tag_in integer :: ibnd ! Variables of isosurface on IBZ integer :: n_vert_aux ( n_bnd ), n_tri_aux ( n_bnd ) real ( dp ) :: v_coord_aux ( 3 , maxval ( n_vert ), n_bnd ) integer :: v_index_aux ( 3 , maxval ( n_tri ), n_bnd ) ! !--------------- Newton-Raphson relaxation before improvement (optional) ! if ( newton_raphson == 2 . and . ( collapse . or . relax )) then ! write ( * , '(\"|         ---------------------------------         |\")' ) write ( * , '(\"| - Newton-Raphson relaxation of FS...              |\")' ) ! call newton_rap ( eps_dupv , eps_vinface , ef , nrpts , irvec , ndegen , ham_r , alat , at , bg , & nsym , s , TR_sym , n_bnd , newton_iter , nfaces_IBZ , faces_IBZ_as_vert , & vert_IBZ , n_vert , v_coord , verbose ) ! write ( * , '(\"|         ---------------------------------         |\")' ) ! ! write Newton-relaxed isosurface on IBZ tag_in = \"newton_IBZ_FS_tri\" call write_IBZ_isosurface ( tag_in , n_bnd , . false .) ! end if ! !--------------- Edge-collapse ! if ( collapse ) then ! write ( * , '(\"|         ---------------------------------         |\")' ) write ( * , '(\"| - Edge collapse of triangulated mesh...           |\")' ) ! n_vert_aux = n_vert n_tri_aux = n_tri v_coord_aux = v_coord v_index_aux = v_index ! call edge_collapse ( collapse_criteria , nfaces_IBZ , faces_IBZ_as_vert , vert_IBZ , & n_bnd , n_vert_aux , n_tri_aux , v_coord_aux , v_index_aux , & n_vert , n_tri , v_coord , v_index , & verbose ) ! write ( * , '(\"|         ---------------------------------         |\")' ) ! ! write collapsed isosurface on IBZ tag_in = \"collapsed_IBZ_FS_tri\" call write_IBZ_isosurface ( tag_in , n_bnd , . false .) ! end if ! !--------------- Tangential relaxation ! if ( relax ) then ! write ( * , '(\"|         ---------------------------------         |\")' ) write ( * , '(\"| - Tangential relaxation of triangulated mesh...   |\")' ) ! do ibnd = 1 , n_bnd ! if ( n_vert ( ibnd ). eq . 0 ) cycle ! write ( * , '(\"|                                                   |\")' ) write ( * , '(\"|   Relaxing band \",I4,\"                              |\")' ) ibnd ! call tangential_relaxation ( relax_vinface , eps_vinface , eps_dupv , relax_iter , & nrpts , irvec , ndegen , alat , at , bg , nsym , s , TR_sym , & n_bnd , ham_r , ibnd , nfaces_IBZ , faces_IBZ_as_vert , vert_IBZ , & n_vert ( ibnd ), n_tri ( ibnd ), v_coord (:,:, ibnd ), v_index (:,:, ibnd ), & verbose ) ! end do ! write ( * , '(\"|         ---------------------------------         |\")' ) ! ! write relaxed isosurface on IBZ tag_in = \"relaxed_IBZ_FS_tri\" call write_IBZ_isosurface ( tag_in , n_bnd , . false .) ! end if ! !--------------- Newton-Raphson relaxation after improvement ! if ( newton_raphson >= 1 ) then ! write ( * , '(\"|         ---------------------------------         |\")' ) write ( * , '(\"| - Newton-Raphson relaxation of FS...              |\")' ) ! call newton_rap ( eps_dupv , eps_vinface , ef , nrpts , irvec , ndegen , ham_r , alat , at , bg , & nsym , s , TR_sym , n_bnd , newton_iter , nfaces_IBZ , faces_IBZ_as_vert , & vert_IBZ , n_vert , v_coord , verbose ) ! end if ! ! Compute velocity on improved isosurface on IBZ ! call velocity_on_IBZ ( n_bnd , n_vert , v_coord , nrpts , irvec , ndegen , alat , at , bg , nsym , s , TR_sym , ham_r , v_veloc ) ! write ( * , '(\"|         ---------------------------------         |\")' ) ! ! write improved isosurface on IBZ tag_in = \"opt_IBZ_FS_tri\" call write_IBZ_isosurface ( tag_in , n_bnd , . false .) end subroutine mesh_optimization subroutine newton_rap ( eps_dupv , eps_vinface , ef , nrpts , irvec , ndegen , ham_r , alat , ag , bg , & nsym , s , TR_sym , n_bnd , newton_iter , nibz_faces , faces_ibz , & verts_ibz , n_vert , v_coord , verb ) use intw_useful_constants , only : tpi use intw_matrix_vector , only : ainv , norma , cross use triFS_isosurface , only : calculate_energy_sym , velocity_sym implicit none ! I/O real ( dp ), intent ( in ) :: eps_dupv , eps_vinface real ( dp ), intent ( in ) :: ef integer , intent ( in ) :: nrpts , irvec ( 3 , nrpts ), ndegen ( nrpts ) ! Wannier/Fourier space variables integer , intent ( in ) :: n_bnd complex ( dp ), intent ( in ) :: ham_r ( n_bnd , n_bnd , nrpts ) ! Hamiltonian in Wannier basis real ( dp ), intent ( in ) :: alat , ag ( 3 , 3 ), bg ( 3 , 3 ) ! real and reciprocal lattice vectors integer , intent ( in ) :: nsym , s ( 3 , 3 , nsym ) ! symmetry variables logical , intent ( in ) :: TR_sym ! time-reversal symmetry integer , intent ( in ) :: newton_iter , nibz_faces integer , intent ( in ) :: faces_ibz (:,:) ! vertex indeces of IBZ big tetra faces real ( dp ), intent ( in ) :: verts_ibz (:,:) ! IBZ big tetra vertex coordinates integer , intent ( in ) :: n_vert (:) real ( dp ), intent ( inout ) :: v_coord (:,:,:) logical , intent ( in ) :: verb ! Parameters real ( dp ), parameter :: lambda = 0.1_dp ! Local real ( dp ) :: vface ( 3 , 3 , nibz_faces ) real ( dp ) :: eig_int ( n_bnd ), v_w ( 3 ), vcoord_crys ( 3 ) real ( dp ) :: unit_u ( 3 ) integer :: i_iter , ibnd , iv , jv , i , j real ( dp ) :: norma_vw logical :: vert_on_border ( maxval ( n_vert ), nibz_faces ), vert_on_corner ( maxval ( n_vert )) logical :: has_SplusG ( maxval ( n_vert )), SplusG_pair ( maxval ( n_vert ), maxval ( n_vert ), nsym , - 1 : 1 , - 1 : 1 , - 1 : 1 , 2 ) logical :: vertex_related ( maxval ( n_vert )), relaxed_vertex ( maxval ( n_vert )) ! real(dp) :: unit_u1(3) ! Define vectors of IBZ big tetra faces do i = 1 , nibz_faces vface ( 1 : 3 , 1 , i ) = verts_ibz ( 1 : 3 , faces_ibz ( 2 , i )) - verts_ibz ( 1 : 3 , faces_ibz ( 1 , i )) vface ( 1 : 3 , 2 , i ) = verts_ibz ( 1 : 3 , faces_ibz ( 3 , i )) - verts_ibz ( 1 : 3 , faces_ibz ( 1 , i )) vface ( 1 : 3 , 3 , i ) = verts_ibz ( 1 : 3 , faces_ibz ( 1 , i )) end do ! Loop over different FS sheets do ibnd = 1 , n_bnd ! if ( n_vert ( ibnd ). eq . 0 ) cycle ! write ( * , '(\"|                                                   |\")' ) write ( * , '(\"|   Relaxing band \",I4,\"                              |\")' ) ibnd !--------------- Check which vertices are on border of IBZ ! call check_border ( n_vert ( ibnd ), v_coord (:,:, ibnd ), nibz_faces , vface , & eps_vinface , vert_on_border , vert_on_corner , verb ) !--------------- Detect which vertices have SplusG pairs ! has_SplusG = . false . vertex_related = . false . SplusG_pair = . false . do iv = 1 , n_vert ( ibnd ) ! if ( vertex_related ( iv )) cycle ! a pair of this vertex has been already assigned ! do jv = 1 , n_vert ( ibnd ) ! if ( jv . eq . iv ) cycle ! call vertices_related_by_SplusG ( eps_dupv , v_coord ( 1 : 3 , iv , ibnd ), v_coord ( 1 : 3 , jv , ibnd ), & bg , nsym , s , TR_sym , & SplusG_pair ( iv , jv ,:,:,:,:,:)) ! if ( ANY ( SplusG_pair ( iv , jv ,:,:,:,:,:))) then ! if ( verb ) write ( * , '(\"|     Vertices \",I4,\" and \",I4,\" are related            |\")' ) iv , jv has_SplusG ( iv ) = . true . vertex_related ( jv ) = . true . ! end if end do ! jv end do ! iv !--------------- NR iterations on vertices ! do i_iter = 1 , newton_iter ! write ( * , '(\"|     Newton-Raphson relaxation, iter \",I4,\" / \",I4,\"   |\")' ) i_iter , newton_iter relaxed_vertex = . false . v_loop : do iv = 1 , n_vert ( ibnd ) ! if ( relaxed_vertex ( iv )) cycle ! if ( ANY ( SplusG_pair ( iv , iv ,:,:,:,:,:))) cycle ! don't relax vertex which has S+G with itself. ! vcoord_crys ( 1 : 3 ) = matmul ( ainv ( bg ), v_coord ( 1 : 3 , iv , ibnd )) ! Vertex in crystal coordinates ! ! Compute energy and velocity of vertex call calculate_energy_sym ( nsym , s , TR_sym , n_bnd , nrpts , ndegen , irvec , ham_r , vcoord_crys , eig_int ) call velocity_sym ( nrpts , irvec , ndegen , alat , ag , bg , nsym , s , TR_sym , n_bnd , ibnd , ham_r , v_w , vcoord_crys ) ! ! When vertex lies on face project velocity to face-plane j_loop : do j = 1 , nibz_faces ! if ( vert_on_border ( iv , j ) . and . . not . vert_on_corner ( iv )) then unit_u (:) = cross ( vface (:, 2 , j ), vface (:, 1 , j )) ! normal vector of face unit_u (:) = unit_u (:) / norma ( unit_u ) v_w ( 1 : 3 ) = v_w ( 1 : 3 ) - dot_product ( v_w , unit_u ) * unit_u ( 1 : 3 ) exit j_loop endif end do j_loop ! ! When vert lies on corner between two faces project velocity to intersection vector if ( vert_on_corner ( iv )) then ! !cycle v_loop ! f_loop : do j = 1 , nibz_faces ! if ( vert_on_border ( iv , j )) then ! !unit_u1(:) = cross(vface(:,2,j), vface(:,1,j)) !unit_u1(:) = unit_u1(:) / norma( unit_u1 ) ! do i = 1 , nibz_faces ! if ( i . eq . j ) cycle if ( vert_on_border ( iv , i )) then ! ! Project velocity to corner vector, i.e. edge of the intersection between the two faces call v2edge ( eps_vinface , iv , nibz_faces , i , j , vface , v_w ) ! exit f_loop ! end if ! vert_on_border2 end do ! face_loop2 end if ! vert_on_border1 end do f_loop end if ! vert_on_face ! norma_vw = norma ( v_w ( 1 : 3 )) ! norm of velocity of vertex v_w = matmul ( ainv ( bg ), v_w ) ! Change velocity to crystal coordinates ! vcoord_crys ( 1 : 3 ) = vcoord_crys ( 1 : 3 ) - lambda * v_w ( 1 : 3 ) / norma_vw ** 2 * ( eig_int ( ibnd ) - ef ) / tpi ! move vertex v_coord ( 1 : 3 , iv , ibnd ) = matmul ( bg , vcoord_crys ( 1 : 3 )) ! transform moved vertex to cartesian coordinates relaxed_vertex ( iv ) = . true . ! ! Move any symmetry related vertex accordingly if ( has_SplusG ( iv )) then ! do jv = 1 , n_vert ( ibnd ) if ( ANY ( SplusG_pair ( iv , jv ,:,:,:,:,:))) then ! jv is pair of iv ! v_coord ( 1 : 3 , jv , ibnd ) = rotate_to_SplusG ( v_coord ( 1 : 3 , iv , ibnd ), bg , nsym , s , SplusG_pair ( iv , jv ,:,:,:,:,:)) relaxed_vertex ( jv ) = . true . ! end if end do ! jv end if ! has_SplusG(iv) ! enddo v_loop ! ! Set all vertices as not relaxed again for next loop relaxed_vertex (:) = . false . ! enddo ! i_iter ! enddo ! ibnd end subroutine newton_rap subroutine check_border ( n_vert , vert_coord , nibz_faces , vface , epsvert , vert_on_border , vert_on_corner , verb ) use intw_matrix_vector , only : ainv , norma , cross implicit none ! I/O integer , intent ( in ) :: n_vert , nibz_faces real ( dp ), intent ( in ) :: vert_coord (:,:), vface (:,:,:) real ( dp ), intent ( in ) :: epsvert logical , intent ( out ) :: vert_on_border (:,:), vert_on_corner (:) logical , intent ( in ) :: verb ! Local variables logical :: inner_face ( nibz_faces ) integer :: j , iv , k real ( dp ) :: coord ( 3 ), face ( 3 , 3 ), coef ( 3 ) ! Check which tetra faces are inner face call inner_faces ( nibz_faces , vface , inner_face ) vert_on_border = . false . vert_on_corner = . false . do iv = 1 , n_vert do j = 1 , nibz_faces ! Do not consider inner faces if ( inner_face ( j )) cycle ! Write coordinate vector of the vertex in terms of tetra face vectors ! 3rd vector is first node, zero unless the face is BZ border. Later changed to normal vector of face. coord ( 1 : 3 ) = vert_coord ( 1 : 3 , iv ) - vface ( 1 : 3 , 3 , j ) face (:, 1 ) = vface (:, 1 , j ) face (:, 2 ) = vface (:, 2 , j ) face (:, 3 ) = cross ( vface (:, 2 , j ), vface (:, 1 , j )) face (:, 3 ) = face (:, 3 ) / norma ( face (:, 3 )) coef ( 1 : 3 ) = matmul ( ainv ( face ( 1 : 3 , 1 : 3 )), coord ( 1 : 3 )) ! Coordinate vector of the vertex is perpendicular to normal vector of face if ( abs ( coef ( 3 )). lt . epsvert ) then ! Coordinate vector of the vertex lies in the face plane if ( coef ( 1 ). ge . 0.0_dp - epsvert . and . coef ( 1 ). le . 1.0_dp + epsvert & . and . coef ( 2 ). ge . 0.0_dp - epsvert . and . coef ( 2 ). le . 1.0_dp + epsvert & !) then . and . sum ( coef ( 1 : 2 )) - 1.0_dp . lt . epsvert ) then !print*, \"Vertex\", iv, \"is on tetra face\", j !print*, \"vert iv on face j:\", iv, j vert_on_border ( iv , j ) = . true . end if end if end do k = 0 do j = 1 , nibz_faces if ( vert_on_border ( iv , j )) k = k + 1 end do if ( k . ge . 2 ) then if ( verb ) write ( * , '(\"|     Vert \",I4,\" on corner!                          |\")' ) iv vert_on_corner ( iv ) = . true . end if end do end subroutine check_border subroutine vertices_related_by_SplusG ( epsvert , ivertex , jvertex , bg , nsym , s , TR_sym , relation ) use intw_matrix_vector , only : ainv , norma implicit none ! I/O real ( dp ), intent ( in ) :: epsvert real ( dp ), intent ( in ) :: ivertex ( 3 ), jvertex ( 3 ), bg ( 3 , 3 ) integer , intent ( in ) :: nsym , s ( 3 , 3 , nsym ) logical , intent ( in ) :: TR_sym logical , intent ( out ) :: relation ( nsym , - 1 : 1 , - 1 : 1 , - 1 : 1 , 2 ) ! true if ivertex and jvertex are related ! Local integer :: isym , ig , jg , kg real ( dp ) :: ivert_crys ( 3 ), rot_ivertex ( 3 ) ! Initialize relation = . false . ! ivertex in crystal coords ivert_crys = matmul ( ainv ( bg ), ivertex ) do isym = 1 , nsym do ig = - 1 , 1 do jg = - 1 , 1 do kg = - 1 , 1 ! if ( ig . eq . 0 . and . jg . eq . 0 . and . kg . eq . 0 ) cycle ! rot_ivertex ( 1 : 3 ) = matmul ( bg , & matmul ( dble ( s (:,:, isym )), ivert_crys ) & + real (( / ig , jg , kg / ), dp ) ) ! ! check with jvertex if ( norma ( rot_ivertex (:) - jvertex (:)) . lt . epsvert ) then relation ( isym , ig , jg , kg , 1 ) = . true . return end if ! TR symmetry if ( TR_sym ) then ! rot_ivertex ( 1 : 3 ) = matmul ( bg , & - matmul ( dble ( s (:,:, isym )), ivert_crys ) & + real (( / ig , jg , kg / ), dp ) ) ! ! check with jvertex if ( norma ( rot_ivertex (:) - jvertex (:)) . lt . epsvert ) then relation ( isym , ig , jg , kg , 2 ) = . true . return end if ! end if ! TR_sym ! end do ! kg end do ! jg end do ! ig end do ! isym end subroutine vertices_related_by_SplusG function rotate_to_SplusG ( ivertex , bg , nsym , s , which_SplusG ) use intw_matrix_vector , only : ainv implicit none ! I/O real ( dp ), intent ( in ) :: ivertex ( 3 ), bg ( 3 , 3 ) integer , intent ( in ) :: nsym , s ( 3 , 3 , nsym ) logical , intent ( in ) :: which_SplusG ( nsym , - 1 : 1 , - 1 : 1 , - 1 : 1 , 2 ) ! Local real ( dp ) :: rotate_to_SplusG ( 3 ) integer :: isym , ig , jg , kg real ( dp ) :: ivert_crys ( 3 ) ! ivertex in crystal coords ivert_crys = matmul ( ainv ( bg ), ivertex ) do isym = 1 , nsym do ig = - 1 , 1 do jg = - 1 , 1 do kg = - 1 , 1 ! if ( ig . eq . 0 . and . jg . eq . 0 . and . kg . eq . 0 ) cycle ! if ( which_SplusG ( isym , ig , jg , kg , 1 )) then ! rotate_to_SplusG ( 1 : 3 ) = matmul ( bg , & matmul ( dble ( s (:,:, isym )), ivert_crys ) & + real (( / ig , jg , kg / ), dp ) ) ! else if ( which_SplusG ( isym , ig , jg , kg , 2 )) then ! rotate_to_SplusG ( 1 : 3 ) = matmul ( bg , & - matmul ( dble ( s (:,:, isym )), ivert_crys ) & + real (( / ig , jg , kg / ), dp ) ) ! end if ! end do ! kg end do ! jg end do ! ig end do ! isym end function rotate_to_SplusG subroutine v2edge ( epsvert , iv , nfaces , iface , jface , vface , v_w ) use intw_matrix_vector , only : norma , cross implicit none ! I/O real ( dp ), intent ( in ) :: epsvert integer , intent ( in ) :: iv , nfaces , iface , jface real ( dp ), intent ( in ) :: vface ( 3 , 3 , nfaces ) real ( dp ), intent ( inout ) :: v_w ( 3 ) if ( sum ( abs ( cross ( vface (:, 1 , jface ), vface (:, 1 , iface )))) . lt . epsvert ) then if ( dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 1 , iface ) ) . gt . epsvert ) then v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 1 , iface ) ) * vface ( 1 : 3 , 1 , iface ) / norma ( vface ( 1 : 3 , 1 , iface )) else v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), - vface ( 1 : 3 , 1 , iface ) ) * ( - vface ( 1 : 3 , 1 , iface )) / norma ( - vface ( 1 : 3 , 1 , iface )) end if else if ( sum ( abs ( cross ( vface (:, 1 , jface ), vface (:, 2 , iface )))) . lt . epsvert ) then if ( dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 2 , iface ) ) . gt . 1.0E-6_dp ) then v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 2 , iface ) ) * vface ( 1 : 3 , 2 , iface ) / norma ( vface ( 1 : 3 , 2 , iface )) else v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), - vface ( 1 : 3 , 2 , iface ) ) * ( - vface ( 1 : 3 , 2 , iface )) / norma ( - vface ( 1 : 3 , 2 , iface )) end if else if ( sum ( abs ( cross ( vface (:, 2 , jface ), vface (:, 1 , iface )))) . lt . epsvert ) then if ( dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 1 , iface ) ) . gt . 1.0E-6_dp ) then v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 1 , iface ) ) * vface ( 1 : 3 , 1 , iface ) / norma ( vface ( 1 : 3 , 1 , iface )) else v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), - vface ( 1 : 3 , 1 , iface ) ) * ( - vface ( 1 : 3 , 1 , iface )) / norma ( - vface ( 1 : 3 , 1 , iface )) end if else if ( sum ( abs ( cross ( vface (:, 2 , jface ), vface (:, 2 , iface )))) . lt . epsvert ) then if ( dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 2 , iface ) ) . gt . 1.0E-6_dp ) then v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 2 , iface ) ) * vface ( 1 : 3 , 2 , iface ) / norma ( vface ( 1 : 3 , 2 , iface )) else v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), - vface ( 1 : 3 , 2 , iface ) ) * ( - vface ( 1 : 3 , 2 , iface )) / norma ( - vface ( 1 : 3 , 2 , iface )) end if else if ( sum ( abs ( cross ( vface (:, 2 , jface ) - vface (:, 1 , jface ), vface (:, 1 , iface )))) . lt . epsvert ) then if ( dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 1 , iface ) ) . gt . 1.0E-6_dp ) then v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 1 , iface ) ) * vface ( 1 : 3 , 1 , iface ) / norma ( vface ( 1 : 3 , 1 , iface )) else v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), - vface ( 1 : 3 , 1 , iface ) ) * ( - vface ( 1 : 3 , 1 , iface )) / norma ( - vface ( 1 : 3 , 1 , iface )) end if else if ( sum ( abs ( cross ( vface (:, 2 , jface ) - vface (:, 1 , jface ), vface (:, 2 , iface )))) . lt . epsvert ) then if ( dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 2 , iface ) ) . gt . 1.0E-6_dp ) then v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 2 , iface ) ) * vface ( 1 : 3 , 2 , iface ) / norma ( vface ( 1 : 3 , 2 , iface )) else v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), - vface ( 1 : 3 , 2 , iface ) ) * ( - vface ( 1 : 3 , 2 , iface )) / norma ( - vface ( 1 : 3 , 2 , iface )) end if else if ( sum ( abs ( cross ( vface (:, 1 , jface ), vface (:, 2 , iface ) - vface (:, 1 , iface )))) . lt . epsvert ) then if ( dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 1 , iface ) ) . gt . 1.0E-6_dp ) then v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 1 , jface ) ) * vface ( 1 : 3 , 1 , jface ) / norma ( vface ( 1 : 3 , 1 , jface )) else v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), - vface ( 1 : 3 , 1 , jface ) ) * ( - vface ( 1 : 3 , 1 , jface )) / norma ( - vface ( 1 : 3 , 1 , jface )) end if else if ( sum ( abs ( cross ( vface (:, 2 , jface ), vface (:, 2 , iface ) - vface (:, 1 , iface )))) . lt . epsvert ) then if ( dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 1 , iface ) ) . gt . 1.0E-6_dp ) then v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), vface ( 1 : 3 , 2 , jface ) ) * vface ( 1 : 3 , 2 , jface ) / norma ( vface ( 1 : 3 , 2 , jface )) else v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), - vface ( 1 : 3 , 2 , jface ) ) * ( - vface ( 1 : 3 , 2 , jface )) / norma ( - vface ( 1 : 3 , 2 , jface )) end if else if ( sum ( abs ( cross ( vface (:, 2 , jface ) - vface (:, 2 , jface ), vface (:, 2 , iface ) - vface (:, 1 , iface )))) . lt . epsvert ) then if ( dot_product ( v_w ( 1 : 3 ), ( vface (:, 2 , iface ) - vface (:, 1 , iface )) ) . gt . 1.0E-6_dp ) then v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), ( vface (:, 2 , iface ) - vface (:, 1 , iface )) ) * ( vface (:, 2 , iface ) - vface (:, 1 , iface )) / norma (( vface (:, 2 , iface ) - vface (:, 1 , iface ))) else v_w ( 1 : 3 ) = dot_product ( v_w ( 1 : 3 ), ( - vface (:, 2 , iface ) + vface (:, 1 , iface )) ) * ( - vface (:, 2 , iface ) + vface (:, 1 , iface )) / norma (( - vface (:, 2 , iface ) + vface (:, 1 , iface ))) end if else print * , \"Something went wrong!\" print * , iv , iface , jface stop end if end subroutine v2edge subroutine edge_collapse ( eps , nibz_faces , faces_ibz , verts_ibz , n_bnd , in_nvert , in_ntri , dif_vert_coord , dif_vert_index , new_nvert , new_ntri , new_dif_vert_coord , new_dif_vert_index , verb ) use intw_matrix_vector , only : ainv , norma , cross implicit none ! I/O variables real ( dp ), intent ( in ) :: eps integer , intent ( in ) :: nibz_faces ! number of faces on IBZ integer , intent ( in ) :: faces_ibz (:,:) ! vertex indeces of IBZ big tetra faces real ( dp ), intent ( in ) :: verts_ibz (:,:) ! IBZ big tetra vertex coordinates integer , intent ( in ) :: n_bnd , in_nvert ( n_bnd ), in_ntri ( n_bnd ) ! input number of triangles, vertices real ( dp ), intent ( inout ) :: dif_vert_coord (:,:,:) ! input vertex coords which will be changed integer , intent ( inout ) :: dif_vert_index (:,:,:) ! input triangle indices which will be changed integer , intent ( out ) :: new_nvert ( n_bnd ), new_ntri ( n_bnd ) ! output number of vertices and triangles after simplification real ( dp ), intent ( out ) :: new_dif_vert_coord (:,:,:) ! output vertices coordinates integer , intent ( out ) :: new_dif_vert_index (:,:,:) ! output triangle vertices logical , intent ( in ) :: verb ! Parameters real ( dp ), parameter :: epsvert = 1.0E-6_dp integer , parameter :: nghmax = 500 , tri_elim_iter = 1000 , dummy_tri_iter = 1000 ! Local variables logical :: inner_face ( nibz_faces ) real ( dp ) :: coef ( 3 ), coord ( 3 ), face ( 3 , 3 ) real ( dp ) :: vface ( 3 , 3 , nibz_faces ) logical :: vert_on_border ( maxval ( in_nvert ), nibz_faces ), vert_on_corner ( maxval ( in_nvert )) integer :: neighbour_triangles ( maxval ( in_ntri ), 3 , nghmax ) integer :: i , iv , j , ij , it , ntri_aux , nvert_aux , iter , f , k , ibnd integer :: rmvd_vrtx , rmvd_tri1 , rmvd_tri2 !--------------- Define vectors of IBZ big tetra faces ! call faces_vectors ( nibz_faces , faces_ibz , verts_ibz , vface ) !--------------- Check which tetra faces are inner ! call inner_faces ( nibz_faces , vface , inner_face ) !--------------- Collapse edges ! I cannot use check_border subr as vertex list is changing constantly... ! new_nvert = 0 new_ntri = 0 new_dif_vert_coord = 0.0_dp new_dif_vert_index = 0 do ibnd = 1 , n_bnd ! if ( in_nvert ( ibnd ). eq . 0 ) cycle ! write ( * , '(\"|                                                   |\")' ) write ( * , '(\"|   Collapsing band \",I4,\"                            |\")' ) ibnd ! new_ntri ( ibnd ) = in_ntri ( ibnd ) new_nvert ( ibnd ) = in_nvert ( ibnd ) ! write ( * , '(\"|     Number of triangles: \",I4,\"                     |\")' ) new_ntri ( ibnd ) write ( * , '(\"|     Number of vertices:  \",I4,\"                     |\")' ) new_nvert ( ibnd ) ! do iter = 1 , tri_elim_iter ! write ( * , '(\"|     Edge collapse, iter \",I4,\" / \",I4,\"               |\")' ) iter , tri_elim_iter ntri_aux = new_ntri ( ibnd ) nvert_aux = new_nvert ( ibnd ) ! if ( verb ) write ( * , '(\"|       Number of triangles: \",I4,\"                   |\")' ) ntri_aux if ( verb ) write ( * , '(\"|       Number of vertices:  \",I4,\"                   |\")' ) nvert_aux ! !--------------- Remove vertices with three neighbours ! ! Check which vertex should be removed if ( verb ) write ( * , '(\"|       Removing dummy triangles...                 |\")' ) do it = 1 , dummy_tri_iter ! if ( verb ) write ( * , '(\"|       iter \",I4,\" / \",I4,\"                            |\")' ) it , dummy_tri_iter ! ! Assign neighbours call find_neighbours ( ntri_aux , dif_vert_index (:,:, ibnd ), neighbour_triangles , nghmax ) ! ! Check which vertices are on tetra faces vert_on_border = . false . vert_on_corner = . false . do iv = 1 , nvert_aux do j = 1 , nibz_faces ! !!! JL remove not considering inner faces. I think it makes the difference when S+G symmetries ! Do not consider inner faces if ( inner_face ( j )) cycle !!! JL ! ! Write coordinate vector of the vertex in terms of tetra face vectors ! 3rd vector is first node, zero unless the face is BZ border. Later changed to normal vector of face. coord ( 1 : 3 ) = dif_vert_coord ( 1 : 3 , iv , ibnd ) - vface ( 1 : 3 , 3 , j ) face (:, 1 ) = vface (:, 1 , j ) face (:, 2 ) = vface (:, 2 , j ) face (:, 3 ) = cross ( vface (:, 2 , j ), vface (:, 1 , j )) face (:, 3 ) = face (:, 3 ) / norma ( face (:, 3 )) coef ( 1 : 3 ) = matmul ( ainv ( face ( 1 : 3 , 1 : 3 )), coord ( 1 : 3 )) ! Coordinate vector of the vertex is perpendicular to normal vector of face !if(abs(dot_product(face(:,3),coord(:))).lt.epsvert) then if ( abs ( coef ( 3 )). lt . epsvert ) then ! Coordinate vector of the vertex lies in the face plane if ( coef ( 1 ). ge . 0.0_dp - epsvert . and . coef ( 1 ). le . 1.0_dp + epsvert & . and . coef ( 2 ). ge . 0.0_dp - epsvert . and . coef ( 2 ). le . 1.0_dp + epsvert & !) then . and . sum ( coef ( 1 : 2 )) - 1.0_dp . lt . epsvert ) then !print*, \"vert iv on face j:\", iv, j vert_on_border ( iv , j ) = . true . end if end if end do k = 0 do j = 1 , nibz_faces if ( vert_on_border ( iv , j )) k = k + 1 end do if ( k . ge . 2 ) then vert_on_corner ( iv ) = . true . end if end do ! rmvd_vrtx = 0 rmvd_tri1 = 0 rmvd_tri2 = 0 f = 0 call rm_3tri_vrtx ( ntri_aux , dif_vert_index (:,:, ibnd ), neighbour_triangles , nghmax , nibz_faces , & vert_on_border , rmvd_vrtx , rmvd_tri1 , rmvd_tri2 , f ) ! if ( f == 0 ) exit ! Define new vertex coordinates and lists new_nvert ( ibnd ) = 0 do iv = 1 , nvert_aux if ( iv == rmvd_vrtx ) cycle new_nvert ( ibnd ) = new_nvert ( ibnd ) + 1 dif_vert_coord (:, new_nvert ( ibnd ), ibnd ) = dif_vert_coord (:, iv , ibnd ) end do new_ntri ( ibnd ) = 0 do i = 1 , ntri_aux if ( i == rmvd_tri1 ) cycle if ( i == rmvd_tri2 ) cycle new_ntri ( ibnd ) = new_ntri ( ibnd ) + 1 dif_vert_index (:, new_ntri ( ibnd ), ibnd ) = dif_vert_index (:, i , ibnd ) do ij = 1 , 3 if ( dif_vert_index ( ij , new_ntri ( ibnd ), ibnd ). gt . rmvd_vrtx ) dif_vert_index ( ij , new_ntri ( ibnd ), ibnd ) = dif_vert_index ( ij , new_ntri ( ibnd ), ibnd ) - 1 end do end do nvert_aux = new_nvert ( ibnd ) ntri_aux = new_ntri ( ibnd ) end do ! if ( verb ) write ( * , '(\"|       Number of triangles: \",I4,\"                   |\")' ) ntri_aux if ( verb ) write ( * , '(\"|       Number of vertices:  \",I4,\"                   |\")' ) nvert_aux ! !--------------- Collapse vertices ! if ( verb ) write ( * , '(\"|       Collapsing vertices...                      |\")' ) ! ! Assign neighbours call find_neighbours ( ntri_aux , dif_vert_index (:,:, ibnd ), neighbour_triangles , nghmax ) ! ! Collapse triangles and create new mesh call collapse_triangles ( eps , ntri_aux , nvert_aux , dif_vert_index (:,:, ibnd ), dif_vert_coord (:,:, ibnd ), & vert_on_border , nibz_faces , nghmax , neighbour_triangles , & new_ntri ( ibnd ), new_nvert ( ibnd ), new_dif_vert_coord (:,:, ibnd ), new_dif_vert_index (:,:, ibnd ), verb ) ! !--------------- Re-assign vertex and index coordinates ! do iv = 1 , new_nvert ( ibnd ) dif_vert_coord (:, iv , ibnd ) = new_dif_vert_coord (:, iv , ibnd ) end do dif_vert_index (:,:, ibnd ) = new_dif_vert_index (:,:, ibnd ) ! if ( verb ) write ( * , '(\"|       Number of triangles: \",I4,\"                   |\")' ) new_ntri ( ibnd ) if ( verb ) write ( * , '(\"|       Number of vertices:  \",I4,\"                   |\")' ) new_nvert ( ibnd ) ! if ( ntri_aux == new_ntri ( ibnd )) then write ( * , '(\"|     No triangle obeys collapse criteria           |\")' ) write ( * , '(\"|     Edge collapse loop finished                   |\")' ) exit end if ! end do ! write ( * , '(\"|     New number of triangles: \",I4,\"                 |\")' ) new_ntri ( ibnd ) write ( * , '(\"|     New number of vertices:  \",I4,\"                 |\")' ) new_nvert ( ibnd ) ! enddo end subroutine edge_collapse subroutine faces_vectors ( nibz_faces , faces_ibz , verts_ibz , vface ) ! Reads four corners of tetra and outputst two vectors of each face, ! with the origin at Gamma (always set as the first tetra node by convention) implicit none ! I/O integer , intent ( in ) :: nibz_faces integer , intent ( in ) :: faces_ibz (:,:) ! vertex indeces of IBZ big tetra faces real ( dp ), intent ( in ) :: verts_ibz (:,:) ! IBZ big tetra vertex coordinates real ( dp ), intent ( out ) :: vface ( 3 , 3 , nibz_faces ) ! Local integer :: i do i = 1 , nibz_faces vface ( 1 : 3 , 1 , i ) = verts_ibz ( 1 : 3 , faces_ibz ( 2 , i )) - verts_ibz ( 1 : 3 , faces_ibz ( 1 , i )) vface ( 1 : 3 , 2 , i ) = verts_ibz ( 1 : 3 , faces_ibz ( 3 , i )) - verts_ibz ( 1 : 3 , faces_ibz ( 1 , i )) vface ( 1 : 3 , 3 , i ) = verts_ibz ( 1 : 3 , faces_ibz ( 1 , i )) end do end subroutine faces_vectors subroutine inner_faces ( nibz_faces , vface , inner_face ) ! Checks which tetra faces are inner use intw_matrix_vector , only : norma implicit none ! I/O integer , intent ( in ) :: nibz_faces real ( dp ), intent ( in ) :: vface (:,:,:) logical , intent ( out ) :: inner_face ( nibz_faces ) ! Local integer :: i , j ! Parameter real ( dp ), parameter :: epsvert = 1.0E-5_dp inner_face = . false . do i = 1 , nibz_faces do j = 1 , nibz_faces if ( j . eq . i ) cycle if (( norma ( vface (:, 1 , i ) - vface (:, 1 , j )). lt . epsvert & . and . norma ( vface (:, 2 , i ) - vface (:, 2 , j )). lt . epsvert & . and . norma ( vface (:, 3 , i )). lt . epsvert & . and . norma ( vface (:, 3 , j )). lt . epsvert ) & . or . ( norma ( vface (:, 1 , i ) - vface (:, 2 , j )). lt . epsvert & . and . norma ( vface (:, 2 , i ) - vface (:, 1 , j )). lt . epsvert & . and . norma ( vface (:, 3 , i )). lt . epsvert & . and . norma ( vface (:, 3 , j )). lt . epsvert ) ) then print * , \"Face\" , i , \"is inner face\" inner_face ( i ) = . true . exit end if end do end do end subroutine inner_faces subroutine find_neighbours ( in_ntri , vindex , neighbour_triangles , nghmax ) implicit none ! I/O integer , intent ( in ) :: in_ntri integer , dimension (:,:), intent ( in ) :: vindex integer , dimension (:,:,:), intent ( out ) :: neighbour_triangles integer , intent ( in ) :: nghmax ! Local integer :: i , iv , j , jv , ngh neighbour_triangles = 0 ! Loop over vertices do i = 1 , in_ntri do iv = 1 , 3 ! Find neighbour triangles of each vertex ngh = 0 do j = 1 , in_ntri if ( j . eq . i ) cycle ! Skip the triangle itself do jv = 1 , 3 if ( ngh . ge . nghmax ) then print * , \"ERROR:Maximum number of neighbours reached\" stop else if ( vindex ( iv , i ). eq . vindex ( jv , j )) then ngh = ngh + 1 neighbour_triangles ( i , iv , ngh ) = j ! j is a neighbour triangle of vertex (i,iv) end if end do end do end do end do end subroutine find_neighbours subroutine find_neighbours_vertex_list ( ntri , n_vert , vindex , neighbour_triangles , nghmax ) implicit none integer , intent ( in ) :: ntri , n_vert integer , dimension (:,:), intent ( in ) :: vindex integer , dimension (:,:), intent ( out ) :: neighbour_triangles integer , intent ( in ) :: nghmax !Local variables integer :: iv , j , jv , ngh neighbour_triangles = 0 !Loop over vertices do iv = 1 , n_vert ! Find neighbour triangles of each vertex ngh = 0 do j = 1 , ntri do jv = 1 , 3 if ( ngh . ge . nghmax ) then print * , \"ERROR:Maximum number of neighbours reached\" stop else if ( iv . eq . vindex ( jv , j )) then ngh = ngh + 1 neighbour_triangles ( iv , ngh ) = j ! j is a neighbour triangle of vertex iv end if end do end do end do end subroutine find_neighbours_vertex_list subroutine rm_3tri_vrtx ( ntri , vindex , neighbours , nghmax , faces , border_vert , rmvd_vrtx , rmvd_tri1 , rmvd_tri2 , n ) ! Removes problematic vertices which are shared by three triangles implicit none ! I/O integer , intent ( in ) :: ntri integer , dimension (:,:), intent ( inout ) :: vindex integer , dimension (:,:,:), intent ( in ) :: neighbours integer , intent ( in ) :: nghmax integer , intent ( in ) :: faces logical , dimension (:,:), intent ( in ) :: border_vert integer , intent ( out ) :: rmvd_vrtx , rmvd_tri1 , rmvd_tri2 , n ! Local integer :: i , j , iv , jv , k , f n = 0 i_loop : do i = 1 , ntri iv_loop : do iv = 1 , 3 k = 0 do j = 1 , nghmax if ( neighbours ( i , iv , j ) == 0 ) exit k = k + 1 end do ! j if ( k == 2 ) then ! Two neighbours because the triangle itself is skipped in find_neighbours do f = 1 , faces if ( border_vert ( vindex ( iv , i ), f )) then cycle iv_loop ! If vertex with three neigh is on border ignore end if end do ! Re-assign position of removed vertex. The new vertex position is the vertex of the neighbour triangle which is not shared with the modified triangle do jv = 1 , 3 if ( vindex ( jv , neighbours ( i , iv , 1 )). ne . vindex ( 1 , i ) . and . vindex ( jv , neighbours ( i , iv , 1 )). ne . vindex ( 2 , i ) . and . vindex ( jv , neighbours ( i , iv , 1 )). ne . vindex ( 3 , i )) then rmvd_vrtx = vindex ( iv , i ) vindex ( iv , i ) = vindex ( jv , neighbours ( i , iv , 1 )) exit end if end do ! jv rmvd_tri1 = neighbours ( i , iv , 1 ) rmvd_tri2 = neighbours ( i , iv , 2 ) n = n + 1 ! if (verbose) write(*,'(\"|       Vertex \",I4,\" has three neighbours            |\")') vindex(iv,i) exit i_loop end if end do iv_loop end do i_loop ! if (verbose) write(*,'(\"|       Number of triangles with three vertex: \",I4,\" |\")') n end subroutine rm_3tri_vrtx subroutine collapse_triangles ( eps , ntri_old , nvert_old , vindex , vcoord , vert_border , ntetraf , nghmax , neighbour_triangles , & ntri_new , nvert_new , new_vcoord , new_vindex , verb ) ! Subroutine that performs edge collapse and triangle re-assignation. ! Needs clean up... use intw_matrix_vector , only : norma , cross implicit none ! I/O real ( dp ), intent ( in ) :: eps integer , intent ( in ) :: ntri_old , nvert_old integer , dimension (:,:), intent ( inout ) :: vindex real ( dp ), dimension (:,:), intent ( inout ) :: vcoord logical , dimension (:,:), intent ( in ) :: vert_border integer , intent ( in ) :: ntetraf integer , intent ( in ) :: nghmax integer , dimension (:,:,:), intent ( in ) :: neighbour_triangles integer , intent ( out ) :: ntri_new , nvert_new real ( dp ), dimension (:,:), intent ( out ) :: new_vcoord integer , dimension (:,:), intent ( out ) :: new_vindex logical , intent ( in ) :: verb !Local variables integer :: i , iv , ij , m , mj , j , jv , f , k1 , k2 , collapsed_edge , eliminated_vertex logical , dimension ( ntri_old ) :: triangle_elimination real ( dp ), dimension ( 3 ) :: oldv1 , oldv2 , oldnormal , newv1 , newv2 , newnormal real ( dp ), dimension ( 3 , nvert_old ) :: old_vcoord , aux_vcoord ntri_new = ntri_old eliminated_vertex = huge ( eliminated_vertex ) triangle_elimination = . false . old_vcoord = vcoord (:, 1 : nvert_old ) aux_vcoord = vcoord (:, 1 : nvert_old ) ! tri_loop : do i = 1 , ntri_old ! Loop over triangles ! Check if triangle fulfils collapse condition call collapse_condition ( vindex ( 1 , i ), vindex ( 2 , i ), vindex ( 3 , i ), vcoord (:,:), eps , collapsed_edge ) !--------------- Go over all possibilities of collapse... ! !--------------- Edge 1-2 of the triangle is small ! if ( collapsed_edge == 1 ) then ! no vertex is on tetra face, move if ( ( ALL (. not . vert_border ( vindex ( 1 , i ),:)) & . and . ALL (. not . vert_border ( vindex ( 2 , i ),:))) & !! or both vertices are on same tetra face !.or. ANY(vert_border(vindex(1,i),:) .and. vert_border(vindex(2,i),:)) & ) then ! loop to check if any vertex is on two tetra-faces, i.e. corner of IBZ k1 = 0 k2 = 0 do f = 1 , ntetraf if ( vert_border ( vindex ( 1 , i ), f )) k1 = k1 + 1 if ( vert_border ( vindex ( 2 , i ), f )) k2 = k2 + 1 if ( k1 . ge . 2 . or . k2 . ge . 2 ) cycle tri_loop end do if ( verb ) write ( * , '(\"|       Triangle \",I4,\" collapsed from edge \",I4,\"      |\")' ) i , 12 aux_vcoord (:, vindex ( 2 , i )) = ( old_vcoord (:, vindex ( 1 , i )) + old_vcoord (:, vindex ( 2 , i )) ) / 2.d0 aux_vcoord (:, vindex ( 1 , i )) = ( old_vcoord (:, vindex ( 1 , i )) + old_vcoord (:, vindex ( 2 , i )) ) / 2.d0 ! Check if collapse would lead to flip of any neighbour triangle of vertex1 do ij = 1 , nghmax if ( neighbour_triangles ( i , 1 , ij ) == 0 ) exit oldv1 (:) = old_vcoord (:, vindex ( 2 , neighbour_triangles ( i , 1 , ij ))) - old_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 1 , ij ))) oldv2 (:) = old_vcoord (:, vindex ( 3 , neighbour_triangles ( i , 1 , ij ))) - old_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 1 , ij ))) oldnormal (:) = cross ( oldv2 (:), oldv1 (:)) if ( norma ( oldnormal ) > tiny ( 1.0_dp )) oldnormal (:) = oldnormal (:) / norma ( oldnormal ) newv1 (:) = aux_vcoord (:, vindex ( 2 , neighbour_triangles ( i , 1 , ij ))) - aux_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 1 , ij ))) newv2 (:) = aux_vcoord (:, vindex ( 3 , neighbour_triangles ( i , 1 , ij ))) - aux_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 1 , ij ))) newnormal (:) = cross ( newv2 (:), newv1 (:)) if ( norma ( newnormal ) > tiny ( 1.0_dp )) newnormal (:) = newnormal (:) / norma ( newnormal ) if ( dot_product ( oldnormal , newnormal ). lt . 0.0_dp ) then if ( verb ) write ( * , '(\"Triangle will not collapse to avoid flip of a neighbour triangle\")' ) cycle tri_loop end if end do ! Check if collapse would lead to flip of any neighbour triangle of vertex2 do ij = 1 , nghmax if ( neighbour_triangles ( i , 2 , ij ) == 0 ) exit oldv1 (:) = old_vcoord (:, vindex ( 2 , neighbour_triangles ( i , 2 , ij ))) - old_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 2 , ij ))) oldv2 (:) = old_vcoord (:, vindex ( 3 , neighbour_triangles ( i , 2 , ij ))) - old_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 2 , ij ))) oldnormal (:) = cross ( oldv2 (:), oldv1 (:)) if ( norma ( oldnormal ) > tiny ( 1.0_dp )) oldnormal (:) = oldnormal (:) / norma ( oldnormal ) newv1 (:) = aux_vcoord (:, vindex ( 2 , neighbour_triangles ( i , 2 , ij ))) - aux_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 2 , ij ))) newv2 (:) = aux_vcoord (:, vindex ( 3 , neighbour_triangles ( i , 2 , ij ))) - aux_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 2 , ij ))) newnormal (:) = cross ( newv2 (:), newv1 (:)) if ( norma ( newnormal ) > tiny ( 1.0_dp )) newnormal (:) = newnormal (:) / norma ( newnormal ) if ( dot_product ( oldnormal , newnormal ). lt . 0.0_dp ) then if ( verb ) write ( * , '(\"Triangle will not collapse to avoid flip of a neighbour triangle\")' ) cycle tri_loop end if end do ! Collapse triangle sharing the removed edge (opposite triangle) do ij = 1 , nghmax j = neighbour_triangles ( i , 1 , ij ) if ( j == 0 ) exit do mj = 1 , nghmax m = neighbour_triangles ( i , 2 , mj ) if ( m == 0 ) exit ! Triangle m is neighbour of the two collapsed vertices, i.e. is the opposite triangle if ( m == j ) then if ( ANY ( vert_border ( vindex ( 1 , m ),:)) & . or . ANY ( vert_border ( vindex ( 2 , m ),:)) & . or . ANY ( vert_border ( vindex ( 3 , m ),:)) & ) then if ( verb ) write ( * , '(\"Triangle will not be collapsed as its opposite is on a tetra face\")' ) cycle tri_loop end if if ( verb ) write ( * , '(\"Triangle \",I4,\" is opposite triangle of \",I4,\" and will be collapsed\")' ) j , i triangle_elimination ( m ) = . true . ntri_new = ntri_new - 1 end if end do end do ! Re-assign coordinate of vertex1 vcoord (:, vindex ( 1 , i )) = ( old_vcoord (:, vindex ( 1 , i )) + old_vcoord (:, vindex ( 2 , i )) ) / 2.d0 ! Collapse triangle triangle_elimination ( i ) = . true . ntri_new = ntri_new - 1 ! Remove vertex2, become vertex1 eliminated_vertex = vindex ( 2 , i ) ! Re-define index of vertices of neighbour triangles of collapsed vertex2 do ij = 1 , nghmax j = neighbour_triangles ( i , 2 , ij ) if ( j == 0 ) exit if (. not . triangle_elimination ( j )) then do jv = 1 , 3 if ( vindex ( 2 , i ). eq . vindex ( jv , j ) ) then if ( verb ) write ( * , '(\"Re-locating vertex \",I4,\" of triangle \",I4,\" neighbour of \",I4)' ) jv , j , i vindex ( jv , j ) = vindex ( 1 , i ) end if end do end if end do ! -- Exit just to remove one triangle for the moment exit ! -- else cycle end if !--------------- Edge 1-3 of the triangle is small ! else if ( collapsed_edge == 2 ) then ! no vertex is on tetra face, forward if ( ( ALL (. not . vert_border ( vindex ( 1 , i ),:)) & . and . ALL (. not . vert_border ( vindex ( 3 , i ),:))) & !! or both vertices are on same tetra face !.or. ANY(vert_border(vindex(1,i),:) .and. vert_border(vindex(3,i),:)) & ) then ! loop to check if any vertex is on two tetra-faces, i.e. corner of irrBZ k1 = 0 k2 = 0 do f = 1 , ntetraf if ( vert_border ( vindex ( 1 , i ), f )) k1 = k1 + 1 if ( vert_border ( vindex ( 3 , i ), f )) k2 = k2 + 1 if ( k1 . ge . 2 . or . k2 . ge . 2 ) cycle tri_loop end do if ( verb ) write ( * , '(\"|       Triangle \",I4,\" collapsed from edge \",I4,\"      |\")' ) i , 13 aux_vcoord (:, vindex ( 3 , i )) = ( old_vcoord (:, vindex ( 1 , i )) + old_vcoord (:, vindex ( 3 , i )) ) / 2.d0 aux_vcoord (:, vindex ( 1 , i )) = ( old_vcoord (:, vindex ( 1 , i )) + old_vcoord (:, vindex ( 3 , i )) ) / 2.d0 ! Check if collapse would lead to flip of any neighbour triangle of vertex1 do ij = 1 , nghmax if ( neighbour_triangles ( i , 1 , ij ) == 0 ) exit oldv1 (:) = old_vcoord (:, vindex ( 2 , neighbour_triangles ( i , 1 , ij ))) - old_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 1 , ij ))) oldv2 (:) = old_vcoord (:, vindex ( 3 , neighbour_triangles ( i , 1 , ij ))) - old_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 1 , ij ))) oldnormal (:) = cross ( oldv2 (:), oldv1 (:)) if ( norma ( oldnormal ) > tiny ( 1.0_dp )) oldnormal (:) = oldnormal (:) / norma ( oldnormal ) newv1 (:) = aux_vcoord (:, vindex ( 2 , neighbour_triangles ( i , 1 , ij ))) - aux_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 1 , ij ))) newv2 (:) = aux_vcoord (:, vindex ( 3 , neighbour_triangles ( i , 1 , ij ))) - aux_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 1 , ij ))) newnormal (:) = cross ( newv2 (:), newv1 (:)) if ( norma ( newnormal ) > tiny ( 1.0_dp )) newnormal (:) = newnormal (:) / norma ( newnormal ) if ( dot_product ( oldnormal , newnormal ). lt . 0.0_dp ) then if ( verb ) write ( * , '(\"Triangle will not collapse to avoid flip of a neighbour triangle\")' ) cycle tri_loop end if end do ! Check if collapse would lead to flip of any neighbour triangle of vertex3 do ij = 1 , nghmax if ( neighbour_triangles ( i , 3 , ij ) == 0 ) exit oldv1 (:) = old_vcoord (:, vindex ( 2 , neighbour_triangles ( i , 3 , ij ))) - old_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 3 , ij ))) oldv2 (:) = old_vcoord (:, vindex ( 3 , neighbour_triangles ( i , 3 , ij ))) - old_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 3 , ij ))) oldnormal (:) = cross ( oldv2 (:), oldv1 (:)) if ( norma ( oldnormal ) > tiny ( 1.0_dp )) oldnormal (:) = oldnormal (:) / norma ( oldnormal ) newv1 (:) = aux_vcoord (:, vindex ( 2 , neighbour_triangles ( i , 3 , ij ))) - aux_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 3 , ij ))) newv2 (:) = aux_vcoord (:, vindex ( 3 , neighbour_triangles ( i , 3 , ij ))) - aux_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 3 , ij ))) newnormal (:) = cross ( newv2 (:), newv1 (:)) if ( norma ( newnormal ) > tiny ( 1.0_dp )) newnormal (:) = newnormal (:) / norma ( newnormal ) if ( dot_product ( oldnormal , newnormal ). lt . 0.0_dp ) then if ( verb ) write ( * , '(\"Triangle will not collapse to avoid flip of a neighbour triangle\")' ) if ( verb ) print * , dot_product ( oldnormal , newnormal ) cycle tri_loop end if end do ! Collapse triangle sharing the removed edge (opposite triangle) do ij = 1 , nghmax j = neighbour_triangles ( i , 1 , ij ) if ( j == 0 ) exit do mj = 1 , nghmax m = neighbour_triangles ( i , 3 , mj ) if ( m == 0 ) exit ! Triangle m is neighbour of the two collapsed vertices, i.e. is the opposite triangle if ( m == j ) then if ( ANY ( vert_border ( vindex ( 1 , m ),:)) & . or . ANY ( vert_border ( vindex ( 2 , m ),:)) & . or . ANY ( vert_border ( vindex ( 3 , m ),:)) & ) then if ( verb ) write ( * , '(\"Triangle will not be collapsed as its opposite is on a tetra face\")' ) cycle tri_loop end if if ( verb ) write ( * , '(\"Triangle \",I4,\" is opposite triangle of \",I4,\" and will be collapsed\")' ) j , i triangle_elimination ( m ) = . true . ntri_new = ntri_new - 1 end if end do end do ! Re-assign coordinate of vertex1 vcoord (:, vindex ( 1 , i )) = ( old_vcoord (:, vindex ( 1 , i )) + old_vcoord (:, vindex ( 3 , i )) ) / 2.d0 ! Collapse triangle triangle_elimination ( i ) = . true . ntri_new = ntri_new - 1 ! Remove vertex3, become vertex1 eliminated_vertex = vindex ( 3 , i ) ! Re-define index of vertices of neighbour triangles of collapsed vertex2 do ij = 1 , nghmax j = neighbour_triangles ( i , 3 , ij ) if ( j == 0 ) exit if (. not . triangle_elimination ( j )) then do jv = 1 , 3 if ( vindex ( 3 , i ). eq . vindex ( jv , j ) ) then if ( verb ) write ( * , '(\"Re-locating vertex \",I4,\" of triangle \",I4,\" neighbour of \",I4)' ) jv , j , i vindex ( jv , j ) = vindex ( 1 , i ) end if end do ! jv end if end do ! ij ! -- Exit just to remove one triangle for the moment exit ! -- else ! at least one vertex is on tetra face, cycle ! cycle ! end if ! vertex on tetra face or not ! Edge 2-3 of the triangle is small ! else if ( collapsed_edge == 3 ) then ! no vertex is on tetra face, move if ( ( ALL (. not . vert_border ( vindex ( 2 , i ),:)) & . and . ALL (. not . vert_border ( vindex ( 3 , i ),:))) & !! or both vertices are on same tetra face !.or. ANY(vert_border(vindex(3,i),:) .and. vert_border(vindex(2,i),:)) & ) then ! loop to check if any vertex is on two tetra-faces, i.e. corner of irrBZ k1 = 0 k2 = 0 do f = 1 , ntetraf if ( vert_border ( vindex ( 2 , i ), f )) k1 = k1 + 1 if ( vert_border ( vindex ( 3 , i ), f )) k2 = k2 + 1 if ( k1 . ge . 2 . or . k2 . ge . 2 ) cycle tri_loop end do if ( verb ) write ( * , '(\"|       Triangle \",I4,\" collapsed from edge \",I4,\"      |\")' ) i , 23 aux_vcoord (:, vindex ( 3 , i )) = ( old_vcoord (:, vindex ( 2 , i )) + old_vcoord (:, vindex ( 3 , i )) ) / 2.d0 aux_vcoord (:, vindex ( 2 , i )) = ( old_vcoord (:, vindex ( 2 , i )) + old_vcoord (:, vindex ( 3 , i )) ) / 2.d0 ! Check if collapse would lead to flip of any neighbour triangle of vertex2 do ij = 1 , nghmax if ( neighbour_triangles ( i , 2 , ij ) == 0 ) exit oldv1 (:) = old_vcoord (:, vindex ( 2 , neighbour_triangles ( i , 2 , ij ))) - old_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 2 , ij ))) oldv2 (:) = old_vcoord (:, vindex ( 3 , neighbour_triangles ( i , 2 , ij ))) - old_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 2 , ij ))) oldnormal (:) = cross ( oldv2 (:), oldv1 (:)) if ( norma ( oldnormal ) > tiny ( 1.0_dp )) oldnormal (:) = oldnormal (:) / norma ( oldnormal ) newv1 (:) = aux_vcoord (:, vindex ( 2 , neighbour_triangles ( i , 2 , ij ))) - aux_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 2 , ij ))) newv2 (:) = aux_vcoord (:, vindex ( 3 , neighbour_triangles ( i , 2 , ij ))) - aux_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 2 , ij ))) newnormal (:) = cross ( newv2 (:), newv1 (:)) if ( norma ( newnormal ) > tiny ( 1.0_dp )) newnormal (:) = newnormal (:) / norma ( newnormal ) if ( dot_product ( oldnormal , newnormal ). lt . 0.0_dp ) then if ( verb ) write ( * , '(\"Triangle will not collapse to avoid flip of a neighbour triangle\")' ) cycle tri_loop end if end do ! Check if collapse would lead to flip of any neighbour triangle of vertex3 do ij = 1 , nghmax if ( neighbour_triangles ( i , 3 , ij ) == 0 ) exit oldv1 (:) = old_vcoord (:, vindex ( 2 , neighbour_triangles ( i , 3 , ij ))) - old_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 3 , ij ))) oldv2 (:) = old_vcoord (:, vindex ( 3 , neighbour_triangles ( i , 3 , ij ))) - old_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 3 , ij ))) oldnormal (:) = cross ( oldv2 (:), oldv1 (:)) if ( norma ( oldnormal ) > tiny ( 1.0_dp )) oldnormal (:) = oldnormal (:) / norma ( oldnormal ) newv1 (:) = aux_vcoord (:, vindex ( 2 , neighbour_triangles ( i , 3 , ij ))) - aux_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 3 , ij ))) newv2 (:) = aux_vcoord (:, vindex ( 3 , neighbour_triangles ( i , 3 , ij ))) - aux_vcoord (:, vindex ( 1 , neighbour_triangles ( i , 3 , ij ))) newnormal (:) = cross ( newv2 (:), newv1 (:)) if ( norma ( newnormal ) > tiny ( 1.0_dp )) newnormal (:) = newnormal (:) / norma ( newnormal ) if ( dot_product ( oldnormal , newnormal ). lt . 0.0_dp ) then if ( verb ) write ( * , '(\"Triangle will not collapse to avoid flip of a neighbour triangle\")' ) cycle tri_loop end if end do ! Collapse triangle sharing the removed edge do ij = 1 , nghmax j = neighbour_triangles ( i , 2 , ij ) if ( j == 0 ) exit do mj = 1 , nghmax m = neighbour_triangles ( i , 3 , mj ) if ( m == 0 ) exit ! Triangle m is neighbour of the two collapsed vertices, i.e. is the opposite triangle if ( m == j ) then if ( ANY ( vert_border ( vindex ( 1 , m ),:)) & . or . ANY ( vert_border ( vindex ( 2 , m ),:)) & . or . ANY ( vert_border ( vindex ( 3 , m ),:)) & ) then if ( verb ) write ( * , '(\"Triangle will not be collapsed as its opposite is on a tetra face\")' ) cycle tri_loop end if if ( verb ) write ( * , '(\"Triangle \",I4,\" is opposite triangle of \",I4,\" and will be collapsed\")' ) j , i triangle_elimination ( m ) = . true . ntri_new = ntri_new - 1 end if end do end do ! Re-assign coordinate of vertex2 vcoord (:, vindex ( 2 , i )) = ( old_vcoord (:, vindex ( 2 , i )) + old_vcoord (:, vindex ( 3 , i )) ) / 2.d0 ! Collapse triangle triangle_elimination ( i ) = . true . ntri_new = ntri_new - 1 ! Remove vertex3, become vertex2 eliminated_vertex = vindex ( 3 , i ) ! Re-define index of vertices of neighbour triangles of collapsed vertex2 do ij = 1 , nghmax j = neighbour_triangles ( i , 3 , ij ) if ( j == 0 ) exit if (. not . triangle_elimination ( j )) then do jv = 1 , 3 if ( vindex ( 3 , i ). eq . vindex ( jv , j ) ) then if ( verb ) write ( * , '(\"Re-locating vertex \",I4,\" of triangle \",I4,\" neighbour of \",I4)' ) jv , j , i vindex ( jv , j ) = vindex ( 2 , i ) end if end do end if end do ! -- Exit just to remove one triangle for the moment exit ! -- else ! at least one vertex is on tetra face, cycle ! cycle ! end if ! any vertex at IBZ face or not end if ! loop over edge_collapse possibilities end do tri_loop ! Define new vertex coordinate and lists ! nvert_new = 0 do iv = 1 , nvert_old if ( iv . eq . eliminated_vertex ) cycle nvert_new = nvert_new + 1 new_vcoord (:, nvert_new ) = vcoord (:, iv ) end do j = 0 do i = 1 , ntri_old if ( triangle_elimination ( i )) cycle j = j + 1 new_vindex (:, j ) = vindex (:, i ) do ij = 1 , 3 if ( new_vindex ( ij , j ). gt . eliminated_vertex ) new_vindex ( ij , j ) = new_vindex ( ij , j ) - 1 end do end do end subroutine collapse_triangles subroutine collapse_condition ( vindex1 , vindex2 , vindex3 , vcoord , eps , clpsd_edge ) use intw_matrix_vector , only : norma implicit none ! I/O integer , intent ( in ) :: vindex1 , vindex2 , vindex3 real ( dp ), dimension (:,:), intent ( in ) :: vcoord real ( dp ), intent ( in ) :: eps integer , intent ( out ) :: clpsd_edge clpsd_edge = 0 if ( norma ( vcoord (:, vindex1 ) - vcoord (:, vindex2 )) / & ( norma ( vcoord (:, vindex1 ) - vcoord (:, vindex2 )) + & norma ( vcoord (:, vindex1 ) - vcoord (:, vindex3 )) + & norma ( vcoord (:, vindex2 ) - vcoord (:, vindex3 ))) . lt . eps ) then clpsd_edge = 1 else if ( norma ( vcoord (:, vindex1 ) - vcoord (:, vindex3 )) / & ( norma ( vcoord (:, vindex1 ) - vcoord (:, vindex2 )) + & norma ( vcoord (:, vindex1 ) - vcoord (:, vindex3 )) + & norma ( vcoord (:, vindex2 ) - vcoord (:, vindex3 ))) . lt . eps ) then clpsd_edge = 2 else if ( norma ( vcoord (:, vindex2 ) - vcoord (:, vindex3 )) / & ( norma ( vcoord (:, vindex1 ) - vcoord (:, vindex2 )) + & norma ( vcoord (:, vindex1 ) - vcoord (:, vindex3 )) + & norma ( vcoord (:, vindex2 ) - vcoord (:, vindex3 ))) . lt . eps ) then clpsd_edge = 3 end if end subroutine collapse_condition subroutine tangential_relaxation ( relax_vinface , eps_vinface , eps_dupv , niter , nrpts , irvec , ndegen , alat , ag , bg , & nsym , s , TR_sym , n_bnd , ham_r , ibnd , nibz_faces , ibz_faces , verts_ibz , & n_vert , n_tri , v_coord , v_index , verbose ) use intw_matrix_vector , only : ainv , norma , cross use triFS_isosurface , only : velocity implicit none !I/O variables logical , intent ( in ) :: relax_vinface real ( dp ), intent ( in ) :: eps_vinface , eps_dupv integer , intent ( in ) :: niter logical , intent ( in ) :: verbose integer , intent ( in ) :: nrpts , irvec ( 3 , nrpts ), ndegen ( nrpts ) ! Wannier/Fourier space variables real ( dp ), intent ( in ) :: alat , ag ( 3 , 3 ), bg ( 3 , 3 ) ! real and reciprocal lattice vectors integer , intent ( in ) :: nsym , s ( 3 , 3 , nsym ) ! symmetry variables logical , intent ( in ) :: TR_sym ! time-reversal symmetry integer , intent ( in ) :: n_bnd ! number of Wannier functions on hr complex ( dp ), intent ( in ) :: ham_r ( n_bnd , n_bnd , nrpts ) ! Hamiltonian in Wannier basis integer , intent ( in ) :: ibnd , n_vert , n_tri , nibz_faces integer , intent ( in ) :: ibz_faces (:,:) ! IBZ big tetra faces real ( dp ), intent ( in ) :: verts_ibz (:,:) ! IBZ big tetra vertex coordinates integer , intent ( in ) :: v_index (:,:) real ( dp ), intent ( inout ) :: v_coord (:,:) ! Parameters integer , parameter :: nghmax = 500 real ( dp ), parameter :: lambda = 0.1_dp ! Parameter controling vertex movement ! Local variables integer :: j , iv , jv , it integer :: neighbours ( n_vert , nghmax ) logical :: vert_on_corner ( n_vert ) logical :: vert_on_border ( n_vert , nibz_faces ) real ( dp ) :: vert_normal ( 3 , n_vert ), vface ( 3 , 3 , nibz_faces ), face ( 3 , 3 ) real ( dp ) :: meanbary ( 3 ), v_w ( 3 ), vcoord_crys ( 3 ), dvec ( 3 ) logical :: has_SplusG ( n_vert ), SplusG_pair ( n_vert , n_vert , nsym , - 1 : 1 , - 1 : 1 , - 1 : 1 , 2 ) logical :: vertex_related ( n_vert ), relaxed_vertex ( n_vert ) !--------------- Define vectors of IBZ big tetra faces ! call faces_vectors ( nibz_faces , ibz_faces , verts_ibz , vface ) !--------------- Find neighbour triangles of each vertex ! call find_neighbours_vertex_list ( n_tri , n_vert , v_index , neighbours , nghmax ) !--------------- Check which vertices are on border of IBZ ! call check_border ( n_vert , v_coord , nibz_faces , vface , & eps_vinface , vert_on_border , vert_on_corner , verbose ) !--------------- Detect which vertices have SplusG pairs ! has_SplusG = . false . vertex_related = . false . SplusG_pair = . false . do iv = 1 , n_vert ! if ( vertex_related ( iv )) cycle ! a pair of this vertex has been already assigned ! do jv = 1 , n_vert ! if ( jv . eq . iv ) cycle ! call vertices_related_by_SplusG ( eps_dupv , v_coord ( 1 : 3 , iv ), v_coord ( 1 : 3 , jv ), bg , & nsym , s , TR_sym , SplusG_pair ( iv , jv ,:,:,:,:,:)) ! if ( ANY ( SplusG_pair ( iv , jv ,:,:,:,:,:))) then ! if ( verbose ) write ( * , '(\"|     Vertices \",I4,\" and \",I4,\" are related            |\")' ) iv , jv has_SplusG ( iv ) = . true . vertex_related ( jv ) = . true . ! end if end do ! jv end do ! iv !--------------- Vertex relocation ! do it = 1 , niter ! if ( it == 1 ) then write ( * , '(\"|     Tangential relaxation, iter \",I5,\" / \",I5,\"     |\")' ) it , niter else if ( it == 10 ) then write ( * , '(\"|     Tangential relaxation, iter \",I5,\" / \",I5,\"     |\")' ) it , niter else if ( it == 100 ) then write ( * , '(\"|     Tangential relaxation, iter \",I5,\" / \",I5,\"     |\")' ) it , niter else if ( it == 1000 ) then write ( * , '(\"|     Tangential relaxation, iter \",I5,\" / \",I5,\"     |\")' ) it , niter else if ( it == niter ) then write ( * , '(\"|     Tangential relaxation, iter \",I5,\" / \",I5,\"     |\")' ) it , niter else if ( it == 100000 ) then stop \"ERROR: Max number of iterations achived\" end if ! relaxed_vertex (:) = . false . v_loop : do iv = 1 , n_vert ! if ( relaxed_vertex ( iv )) cycle ! if ( ANY ( SplusG_pair ( iv , iv ,:,:,:,:,:))) cycle ! don't relax vertex which has S+G with itself. ! ! Compute normal vector of vertex with the velocity vector vcoord_crys ( 1 : 3 ) = matmul ( ainv ( bg ), v_coord ( 1 : 3 , iv )) !call velocity_sym(nrpts, irvec, ndegen, ag, bg, nsym, s, TR_sym, n_bnd, ibnd, ham_r, v_w, vcoord_crys) !! JL - abiadura simetrizatu gabe, bakarrik plano tangentziala lortzeko da. v_w = 0.0_dp call velocity ( nrpts , irvec , ndegen , alat , ag , bg , n_bnd , ibnd , ham_r , v_w , vcoord_crys ) v_w = matmul ( transpose ( ag ), v_w ) v_w = matmul ( bg , v_w ) !!! JL vert_normal ( 1 : 3 , iv ) = v_w ( 1 : 3 ) / norma ( v_w ( 1 : 3 )) ! ! Obtain mean value of barycenters of neighbour triangles call mean_barycenter ( iv , neighbours , nghmax , v_index , v_coord , meanbary ) ! ! Define displacement vector ! if ( vert_on_corner ( iv )) then ! don't move vertices on corners dvec (:) = 0.0_dp else if ( ANY ( vert_on_border ( iv ,:))) then if ( relax_vinface ) then ! restrict movement to the face plane do j = 1 , nibz_faces if ( vert_on_border ( iv , j )) then face (:, 1 ) = vface (:, 1 , j ) face (:, 2 ) = vface (:, 2 , j ) face (:, 3 ) = cross ( vface (:, 2 , j ), vface (:, 1 , j )) face (:, 3 ) = face (:, 3 ) / norma ( face (:, 3 )) !dvec(:) = lambda * ( (meanbary(:)-v_coord(:,iv)) - dot_product(vert_normal(:,iv),(meanbary(:)-v_coord(:,iv)))*vert_normal(:,iv) ) dvec (:) = ( ( meanbary (:) - v_coord (:, iv )) - dot_product ( vert_normal (:, iv ), ( meanbary (:) - v_coord (:, iv ))) * vert_normal (:, iv ) ) !write(*,'(6E18.10)'), dvec(:), dot_product(face(:,3),dvec(:))*face(:,3) dvec (:) = ( dvec (:) - dot_product ( face (:, 3 ), dvec (:)) * face (:, 3 ) ) ! Motelago mugitu aurpegietako bertizeak dvec (:) = lambda / 4.0_dp * dvec (:) end if ! vert_on_border(iv,j) end do !j else ! do not relax vertices at faces dvec (:) = 0.0_dp end if ! relax_vinface else ! vertex is not on face, move normally dvec (:) = lambda * ( ( meanbary (:) - v_coord (:, iv )) - dot_product ( vert_normal (:, iv ), ( meanbary (:) - v_coord (:, iv ))) * vert_normal (:, iv ) ) end if ! ! safety condition to avoid errors if ( sum ( abs ( dvec (:))). gt . 1 0.0_dp ) then print * , \"Displacement is too big, something went wrong!!\" dvec = 0.0_dp end if ! !! Print displacements if needed !if (verbose) then !  if(it==1) print*, dvec(:) !  if(it==10) print*, dvec(:) !  if(it==100) print*, dvec(:) !  if(it==200) print*, dvec(:) !  if(it==1000) print*, dvec(:) !  if(it==10000) print*, dvec(:) !  if(it==100000) print*, dvec(:) !end if ! ! Move vertex v_coord (:, iv ) = v_coord (:, iv ) + dvec (:) relaxed_vertex ( iv ) = . true . ! ! Move any symmetry related vertex accordingly if ( has_SplusG ( iv )) then ! do jv = 1 , n_vert if ( ANY ( SplusG_pair ( iv , jv ,:,:,:,:,:))) then ! jv is pair of iv ! v_coord ( 1 : 3 , jv ) = rotate_to_SplusG ( v_coord ( 1 : 3 , iv ), bg , nsym , s , SplusG_pair ( iv , jv ,:,:,:,:,:)) relaxed_vertex ( jv ) = . true . ! end if end do ! jv end if ! has_SplusG(iv) ! end do v_loop end do ! niter end subroutine tangential_relaxation subroutine mean_barycenter ( vi , neighbour_triangles , nghmax , vindex , vcoord , mean_bary ) use intw_matrix_vector , only : cross implicit none ! I/O integer , intent ( in ) :: vi integer , dimension (:,:), intent ( in ) :: neighbour_triangles integer , intent ( in ) :: nghmax integer , dimension (:,:), intent ( in ) :: vindex real ( dp ), dimension (:,:), intent ( in ) :: vcoord real ( dp ), dimension ( 3 ), intent ( out ) :: mean_bary ! Local integer :: ni , ngh real ( dp ) :: tri_area , sum_area real ( dp ), dimension ( 3 ) :: bary , v1 , v2 ngh = 0 mean_bary (:) = 0.0_dp sum_area = 0.0_dp do ni = 1 , nghmax if ( neighbour_triangles ( vi , ni ) == 0 ) exit ngh = ngh + 1 bary (:) = ( vcoord (:, vindex ( 1 , neighbour_triangles ( vi , ngh ))) & + vcoord (:, vindex ( 2 , neighbour_triangles ( vi , ngh ))) & + vcoord (:, vindex ( 3 , neighbour_triangles ( vi , ngh )))) / 3.0_dp v1 (:) = ( vcoord (:, vindex ( 2 , neighbour_triangles ( vi , ngh ))) - vcoord (:, vindex ( 1 , neighbour_triangles ( vi , ngh ))) ) v2 (:) = ( vcoord (:, vindex ( 3 , neighbour_triangles ( vi , ngh ))) - vcoord (:, vindex ( 1 , neighbour_triangles ( vi , ngh ))) ) tri_area = sqrt ( sum ( cross ( v1 , v2 ) ** 2 )) / 2.0_dp !tri_area = 1.0_dp sum_area = sum_area + tri_area mean_bary (:) = mean_bary (:) + tri_area * bary (:) end do mean_bary (:) = mean_bary (:) / sum_area end subroutine mean_barycenter end module triFS_mesh_opt","tags":"","url":"sourcefile/mesh_opt.f90.html"},{"title":"all_wfcs.f90 – INTW","text":"Source Code ! ! Copyright (C) 2024 INTW group ! ! This file is part of INTW. ! ! INTW is free software: you can redistribute it and/or modify ! it under the terms of the GNU General Public License as published by ! the Free Software Foundation, either version 3 of the License, or ! (at your option) any later version. ! ! INTW is distributed in the hope that it will be useful, ! but WITHOUT ANY WARRANTY; without even the implied warranty of ! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the ! GNU General Public License for more details. ! ! You should have received a copy of the GNU General Public License ! along with this program. If not, see <https://www.gnu.org/licenses/>. ! module intw_allwfcs !! display: none !! !! This module contains variables and subroutines for obtaining wave functions. !! !! ### Details !! !! Wave functions for irreducible k points are read and stored, and wave functions !! for general k points are obtained using symmetry. !! use kinds , only : dp implicit none ! variables public :: eig_all_irr , wfc_k_all_irr , list_iG_all_irr , ngk_all_irr ! subroutines public :: allocate_and_get_all_irreducible_wfc , get_psi_general_k_all_wfc private real ( dp ), allocatable :: eig_all_irr (:,:) ! Eigenvalues for each band and irreducible k point complex ( dp ), allocatable :: wfc_k_all_irr (:,:,:,:) ! Wave function components (also spin component) for each band and irreducible k point integer , allocatable :: list_iG_all_irr (:,:) ! G vector indices of the wave function components for each irreducible k point integer , allocatable :: ngk_all_irr (:) ! Number of components of the wave functions for each irreducible k point contains subroutine allocate_and_get_all_irreducible_wfc () use intw_reading , only : nGk_max , nkpoints_QE , get_K_folder_data , nspin , num_bands_intw use intw_useful_constants , only : cmplx_0 , ZERO implicit none integer :: list_iG ( nGk_max ) real ( dp ) :: QE_eig ( num_bands_intw ) complex ( dp ) :: wfc_g ( nGk_max , num_bands_intw , nspin ) integer :: i_folder , ispin , iG , ibnd ! ! Allocate eigenvalue and wfc related arrays ! if ( allocated ( eig_all_irr )) deallocate ( eig_all_irr ) allocate ( eig_all_irr ( nkpoints_QE , num_bands_intw )) eig_all_irr = ZERO ! if ( allocated ( wfc_k_all_irr )) deallocate ( wfc_k_all_irr ) allocate ( wfc_k_all_irr ( nkpoints_QE , nGk_max , num_bands_intw , nspin )) wfc_k_all_irr = cmplx_0 ! if ( allocated ( list_iG_all_irr )) deallocate ( list_iG_all_irr ) allocate ( list_iG_all_irr ( nkpoints_QE , nGk_max )) list_iG_all_irr = 0 ! if ( allocated ( ngk_all_irr )) deallocate ( ngk_all_irr ) allocate ( ngk_all_irr ( nkpoints_QE )) ngk_all_irr = 0 ! ! Read all irreducible k points ! do i_folder = 1 , nkpoints_QE ! call get_K_folder_data ( i_folder , list_iG , wfc_g , QE_eig , ngk_all_irr ( i_folder )) ! eig_all_irr ( i_folder ,:) = QE_eig (:) ! list_iG_all_irr ( i_folder , 1 : ngk_all_irr ( i_folder )) = list_iG ( 1 : ngk_all_irr ( i_folder )) ! do iG = 1 , ngk_all_irr ( i_folder ) do ispin = 1 , nspin do ibnd = 1 , num_bands_intw ! wfc_k_all_irr ( i_folder , iG , ibnd , ispin ) = wfc_g ( iG , ibnd , ispin ) ! enddo ! ibnd enddo ! ispin enddo ! iG ! enddo ! i_folder end subroutine allocate_and_get_all_irreducible_wfc subroutine get_psi_general_k_all_wfc ( kpoint , ngk , list_iG_k , wfc_k , eig_k ) use intw_reading , only : s , ftau , nGk_max , nspin , kpoints_QE , num_bands_intw use intw_input_parameters , only : nk1 , nk2 , nk3 use intw_symmetries , only : full_mesh , symlink , QE_folder_sym , QE_folder_nosym , & apply_TR_to_wfc , rotate_wfc use intw_utility , only : find_k_1BZ_and_G , triple_to_joint_index_g use intw_fft , only : wfc_by_expigr use intw_useful_constants , only : eps_5 , ZERO implicit none !I/O variables real ( dp ), intent ( in ) :: kpoint ( 3 ) ! General k point in crystal coordinates for which wave functions are desired integer , intent ( out ) :: ngk ! Number of components of the wave functions integer , intent ( out ) :: list_iG_k ( nGk_max ) ! G vector indices of the wave function components complex ( dp ), intent ( out ) :: wfc_k ( nGk_max , num_bands_intw , nspin ) ! Wave function components (also spin component) for all bands real ( dp ), intent ( out ), optional :: eig_k ( num_bands_intw ) ! Eigenvalues for all band !local variables integer :: ikpt , i_folder integer :: i_sym , TR integer :: i_1bz , j_1bz , k_1bz integer :: sym ( 3 , 3 ), G_sym ( 3 ), G_plus ( 3 ) real ( dp ) :: ftau_sym ( 3 ) real ( dp ) :: kpoint_1BZ ( 3 ), k_irr ( 3 ), ktest ( 3 ) integer :: list_iG_irr ( nGk_max ) complex ( dp ) :: wfc_k_irr ( nGk_max , num_bands_intw , nspin ) call find_k_1BZ_and_G ( kpoint , nk1 , nk2 , nk3 , i_1bz , j_1bz , k_1bz , kpoint_1bz , G_plus ) ! call triple_to_joint_index_g ( nk1 , nk2 , nk3 , ikpt , i_1bz , j_1bz , k_1bz ) ! if ( full_mesh ) then ! ! Use the full BZ, no symmetry! ! i_folder = QE_folder_nosym ( ikpt ) k_irr = kpoints_QE (:, i_folder ) ! ngk = ngk_all_irr ( ikpt ) list_iG_k (:) = list_iG_all_irr ( ikpt ,:) wfc_k (:,:,:) = wfc_k_all_irr ( ikpt ,:,:,:) if ( present ( eig_k )) eig_k (:) = eig_all_irr ( ikpt ,:) ! G_sym = nint ( kpoint - k_irr ) ! call wfc_by_expigr ( num_bands_intw , nspin , G_sym , list_iG_k , wfc_k ) ! else ! ! Use the IBZ and symmetry! ! ! This is the irreducible point ! connected to aimed kpoint i_folder = QE_folder_sym ( ikpt ) k_irr = kpoints_QE (:, i_folder ) ! ! The symmetry which takes kpoints_QE(:,i_folder) into aimed kpoint. ! sym * kpoints_QE = kpoint i_sym = symlink ( ikpt , 1 ) TR = symlink ( ikpt , 2 ) ftau_sym = ftau (:,( i_sym )) sym = s (:,:,( i_sym )) ! ! Load the corresponding irreducible wfcs in kpoints_QE ngk = ngk_all_irr ( i_folder ) list_iG_irr (:) = list_iG_all_irr ( i_folder ,:) wfc_k_irr (:,:,:) = wfc_k_all_irr ( i_folder ,:,:,:) if ( present ( eig_k )) eig_k (:) = eig_all_irr ( i_folder ,:) ! ktest = matmul ( sym , k_irr ) ! if ( TR == 1 ) then ! If TR needed ! G_sym = aimed_kpoint -TR[S*QE_kpoint] = aimed_kpoint + S*QE_kpoint, such that ! aimed_kpoint = -S*QE_kpoint + G_ sym G_sym = nint ( kpoint + ktest ) else ! G_sym = aimed_kpoint - S*QE_kpoint, such that ! aimed_kpoint = S*QE_kpoint + G_ sym G_sym = nint ( kpoint - ktest ) end if ! call rotate_wfc ( wfc_k_irr , list_iG_irr , wfc_k , list_iG_k , i_sym , sym , ftau_sym , ( / 0 , 0 , 0 / )) ! ! If time-reversal is present, the wavefunction currently stored ! in wfc_k is actually for (-k). Complex conjugation must now ! be applied to recover wfc_k. ! if ( TR == 1 ) then ktest = - ktest ! call apply_TR_to_wfc ( wfc_k , list_iG_k ) ! endif ! if ( sum ( abs ( ktest + dble ( G_sym ) - kpoint ) ) > eps_5 ) then write ( * , * ) \"ERROR in get_psi_general_k_all_wfc:\" write ( * , \"(a,3f12.6)\" ) \"Aimed kpoint is     :\" , kpoint write ( * , \"(a,3f12.6)\" ) \"Symmetry induced is :\" , ktest + G_sym end if ! call wfc_by_expigr ( num_bands_intw , nspin , G_sym , list_iG_k , wfc_k ) ! endif end subroutine get_psi_general_k_all_wfc end module intw_allwfcs","tags":"","url":"sourcefile/all_wfcs.f90.html"},{"title":"User Guide – INTW","text":"INTW Documentation This is the main user guide page of the INTW project, where you will find tutorials to get started with INTW, information about the INTW test suite, and other resources that may be added in the future to help in the use of INTW.","tags":"","url":"page/index.html"},{"title":"Tutorials – INTW","text":"In this section you will find step-by-step guides for using INTW with Quantum ESPRESSO and SIESTA, created to facilitate a smooth start to INTW.","tags":"","url":"page/tutorials/index.html"},{"title":"Quantum ESPRESSO – INTW","text":"Electron-phonon interpolation with INTW Table of contents Preparation of QE data INTW-Wannier90 interface Triangulation of the Fermi surface Electron-phonon by Method I Electron-phonon by Method II In this tutorial we showcase INTW electron-phonon interpolation utilities taking hexagonal MgB2 as example and using Quantum ESPRESSO (QE) as DFT code. As part of the workflow, we also make use of the INTW-Wannier90 interface and the Fermi surface (FS) triangulation utility. Note, the provided intw.in contains all the necessary input to perform the calculations described below until the interpolation by Method I. For Method II, the &elphon block has to be rewritten. Preparation of QE data Here we do pw.x and ph.x calculations with the 6.7Max version of QE. In the working directory, we find: $ tree\n.\n├── B.pz-vbc.UPF\n├── create_intw_q_dirs.in\n├── intw.in\n├── intw_wann.in\n├── mgb2_a2F.png\n├── mgb2_bands.png\n├── mgb2_dos.png\n├── mgb2_ph_bands.png\n├── mgb2_ph_dos.png\n├── mgb2.pw2intw.in\n├── mgb2.scf.in\n├── mgb2.win\n├── Mg.pz-n-vbc.UPF\n├── phonons_333\n│ └── mgb2.ph.in\n└── Tutorial.txt With the pseudo files and the self-consistent (scf) calculation input, we run pw.x : $ ${ QE_dir } /pw.x < mgb2.scf.in > mgb2.scf.out This electronic calculation uses a $N_k$ = 12x12x12 grid. For the phonons we set a grid $N_q$ = 3x3x3. pw2intw.x reads the phonon data from an individual directory qq${iq}/ for each q-point index iq. Therefore, ph.x must be executed for one q-point at a time. For the ph.x input preparation and execution, a script can be used adapted to the needs of the user, or, create_intw_q_dirs.x code provided by INTW can be used. In this example create_intw_q_dirs.in is provided for this purpose: $ cat create_intw_q_dirs.in & inputpp prefix = \"mgb2\" phdir = \"./phonons_333/\" nq1 = 3 , nq2 = 3 , nq3 = 3 reference_file = \"mgb2.ph.in\" / Where reference_file located inside phdir is: $ cat phonons_333/mgb2.ph.in\nphonons for MgB2 & inputph outdir = './' prefix = 'mgb2' trans = .true. ldisp = .false. tr2_ph = 1 .0d-16 fildvscf = 'dvscf' fildyn = 'mgb2.dyn' verbosity = 'high' / Note that, because ldisp is set to .false. , ph.x will expect a q-point at the end of the file, which will be added by create_intw_q_dirs.x automatically. Now we run: $ ${ QE_dir } /create_intw_q_dirs.x < create_intw_q_dirs.in > create_intw_q_dirs.out This will also create the qlist.txt file inside phdir , which contains a list of the irreducible q-points: cat phonons_333/qlist.txt\n  1      0.0000000000      0.0000000000      0.0000000000\n  2      0.0000000000      0.0000000000      0.2918855809\n  3      0.0000000000      0.3849001795      0.0000000000\n  4      0.0000000000      0.3849001795      0.2918855809\n  5      0.3333333333      0.5773502692      0.0000000000\n  6      0.3333333333      0.5773502692      0.2918855809 Then we run the ph.x calculation for each q-point: $ cd phonons_333/qq1\n$ cp -r ../../mgb2.save .\n$ ${ QE_dir } /ph.x < mgb2.ph.in > mgb2.ph.out\n$ rm -fr mgb2.save cd ../.. And so on until all phonon calculations are completed. Back into the working directory and we are ready to transform the QE data into a format suitable for INTW by running pw2intw.x : $ ${ QE_dir } /pw2intw.x < mgb2.pw2intw.in > mgb2.pw2intw.out This will create mgb2.save.intw directory, where all the data required by INTW is stored: $ tree mgb2.save.intw\nmgb2.save.intw\n├── 1 -KBPP.txt\n├── 2 -KBPP.txt\n├── crystal.dat\n├── gvectors.dat\n├── iGlist.dat\n├── irrq_patterns.dat\n├── kpoints.dat\n├── mgb2.dvscf_q1\n...\n├── mgb2.dvscf_q6\n├── mgb2.dyn_q1\n...\n├── mgb2.dyn_q6\n├── scf_rhor.dat\n├── scf_vr.dat\n├── wfc00001.dat\n...\n└── wfc00133.dat Back to top :arrow_heading_up: INTW-Wannier90 interface As usual, we run Wannier90 in preprocessing mode to obtain the mgb2.nnkp file with mgb2.win as input: $ ${ W90_dir } /wannier90.x -pp mgb2 The QE calculation produced 8 bands and with the settings $ head mgb2.win num_bands = 8 num_wann = 5 dis_froz_max = 9 .0\n... We will disentangle to work with 5 bands after unitary rotation, the lowest in the energy range. In the following intw.in input we have selected use_exclude_bands = 'wannier' . Here we indicate in the &input block the grid and the Fermi energy from mgb2.scf.out, which is needed later: &input\n outdir = './'\n prefix = 'mgb2'\n nk1 = 12\n nk2 = 12\n nk3 = 12\n TR_symmetry = .false.\n use_exclude_bands = 'wannier'\n chemical_potential = 7.3852\n/ The &intw2W block is the input for intw2W90.x , which will generate mgb2.eig , mgb2.mmn and mgb2.amn upon symmetry rotation of the wavefunctions and applying the convolution formula described in the paper. &intw2W\n intw2W_fullzone = .false.\n intw2W_method = 'CONVOLUTION'\n/ We can run intw2W90.x , then Wannier90 normally, and finally w902intw.x . $ ${ INTW_dir } /intw2W90.x < intw.in\n$ ${ W90_dir } /wannier90.x mgb2\n$ ${ INTW_dir } /w902intw.x < intw.in This produces the files mgb2.u_mesh and mgb2_hr_intw.dat , containing the unitary rotations and the Hamiltonian in the real space basis, respectively. With the options in &DOS and the K_PATH card, we can interpolate the band structure and obtain a density of states at this point: $ ${ INTW_dir } /interpolate.x < intw.in gnuplot> do for [ qpt in  \"0.000000E+00 0.622657E+00 0.982148E+00 0.170113E+01 0.217332E+01 0.279597E+01 0.315546E+01 0.387445E+01\" ]{set arrow nohead from qpt,graph 0 to qpt,graph 1 lc \"black\"}\ngnuplot> set xtics (\"{/Symbol G}\" 0.000000E+00, \"M\" 0.622657E+00, \"K\" 0.982148E+00, \"{/Symbol G}\" 0.170113E+01, \"A\" 0.217332E+01, \"L\" 0.279597E+01, \"H\" 0.315546E+01, \"A\" 0.387445E+01)\ngnuplot> set zeroaxis\ngnuplot> set ylabel 'E-E_F (eV)'\ngnuplot> p 'mgb2.bnd_int' u 1:2 w l Back to top :arrow_heading_up: Triangulation of the Fermi surface The triFS.x utility needs the input file blocks &tri_FS and &FS_opt . At this point, a different energy isosurface can be selected. The mgb2_hr_intw.dat file is used internally by triFS.x. $ ${ INTW_dir } /triFS.x < intw.in Only some of the files produced by triFS.x are needed in the electron-phonon calculation later on: $ ls\n...\nmgb2. ${ ish } _FS_tri.off\nmgb2. ${ ish } _FS_tri_v_k.dat\nmgb2. ${ ish } _IBZ_FS_tri.off\nmgb2. ${ ish } _IBZ_FS_tri_v_k.dat\n... where ish =3,4,5 are band indices of the Fermi sheets identified by triFS.x . :heavy_exclamation_mark:NOTE:  bands are labelled according to set_num_bands . If we had used exclude_bands earlier, the labels would count the bands in the non-excluded set. These *.off files contain the triangulated FS in the irreducible Brillouin zone wedge (IBZ) and in the full zone. The *v_k.dat files contain the Fermi velocities. Back to top :arrow_heading_up: Electron-phonon by Method I The &ph input block describes the phonon grid and dynamical matrix options. In this case, we chose to read the $C(q)$ files, stored in directory `mgb2.save.intw', and to apply an acoustic sum rule: &ph\n nq1 = 3\n nq2 = 3\n nq3 = 3\n nqirr = 6\n qlist = \"./phonons_333/qlist.txt\"\n read_for_dynmat = 'dynq'\n apply_asr = .true.\n/ Together with the options in &DOS_ph and the card Q_PATH in the input, we can calculate the phonon bands by doing: $ ${ INTW_dir } /interpolate_phonons.x < intw.in and using Gnuplot with the same xtics for the q-path as in the previous band structure figure: ...\ngnuplot> unset key\ngnuplot> set ylabel 'omega (meV)'\ngnuplot> set linestyle 1 lc rgb \"red\" lw 2\ngnuplot> p 'mgb2.qbnd_int' u 1:2 w l ls 1, '' u 1:3 w l ls 1, '' u 1:4 w l ls 1,'' u 1:5 w l ls 1,'' u 1:6 w l ls 1,'' u 1:7 w l ls 1,'' u 1:8  w l ls 1,'' u 1:9  w l ls 1,'' u 1:10  w l ls 1\ngnuplot> reset\ngnuplot> set xlabel 'omega (Ry)'\ngnuplot> p 'mgb2.qdos_int' w l The ep_interp_on_trFS_dV.x utility calculates the electron-phonon matrix elements for $k+q,k$ pairs on the Fermi surface, including inter-sheet ones, by interpolation of the induced potential (see A. Eiguren and C. Ambrosch-Draxl, Phys. Rev. B 78 (2008) 045124). The interpolation method has to be explicity invoked by the flag ep_interp_method . In this example we specify that the sheets labelled 3-5 are to be used with the ep_interp_bands option and the range. The k-points will be read in from the .off files. :heavy_exclamation_mark:NOTE:  we must provide the commands for running non-self-consistent (nscf) QE calculations and the name of the QE input file of the scf calculation, as INTW will use it as a template to generate the nscf calculations. Here machine options can be introduced, for example, to run pw.x in parallel. & elphon nscf_code = 'QE' ep_interp_method = 'dV_interpolate' ep_interp_bands = 'ef_crossing' nfs_sheets_initial=3 nfs_sheets_final=5 command_pw = \" ${ QE_dir } /pw.x\" command_pw2intw = \"{QE_dir}/pw2intw.x\" file_pw = 'mgb2.scf.in'\n/ Upon running $ ${ INTW_dir } /ep_interp_on_trFS_dV.x < intw.in the matrix elements, fully resolved into spin blocks if nspin=2, are calculated and printed in file mgb2_ep_interp.dat with this format: do js=1,nspin\n   do is=1,nspin\n      write(unit_ep,fmt=\"(6i6,100e16.6)\") ibp, iksp, ikp, ib, iks, ik,  &\n         (aep_mat_el(ikp,ik,js,is,iat), iat=1,3*nat)\n   end do\nend do where ibp and ib are sheet indices, iksp and iks are the k-point indices inside the sheet, ikp and ik are global k-point counters, and iat runs over phonon modes. Here iksp and iks are taken from the triangulation on the full zone and the IBZ. Finally, the a2F_on_trFS.x utility reads the mgb2_ep_interp.dat , interpolates the dynamical matrix and integrates the Eliashberg function. This utility reads also the triangulation and velocity files: $ ${ INTW_dir } /a2F_on_trFS_dV.x < intw.in The first two columns of the output file mgb2_a2F_interp.dat contain $\\alpha&#94;2F(\\omega)$. The other columns are the mode-resolved quantity. Before proceeding with interpolation Method II, we rename the output to compare results later on. mv imgb2_ep_interp.dat mgb2_ep_interp_dV.dat\nmv mgb2_a2F_interp.dat mgb2_a2F_interp_dV.dat Back to top :arrow_heading_up: Electron-phonon by Method II To do the same calculation on the FS with Method II we have to calculate the electron-phonon matrix elements on the coarse grid given by $N_k$ and $N_q$. We do this with the ep_melements.x utility and updating the &elphon block of the intw.in file: &elphon\n ep_bands = 'intw'\n ep_mat_file = \"ep_mat.dat\"\n/ ${ INTW_dir } /ep_melements.x < intw.in This will store the elements in files ep_mat.dat_1 to ep_mat.dat_27 for the coarse q-point grid. Now, we interpolate these elements from the coarse grid onto the triangulated Fermi surface by Wannier interpolation (see F. Giustino et al., Phys. Rev. B 76 (2007) 165108). To do this, we need the .off files and a few more lines in the &elphon block of the intw.in file: &elphon\n ep_bands = 'intw'\n ep_mat_file = \"ep_mat.dat\"\n ep_interp_method = 'wannier'\n ep_interp_bands = 'ef_crossing'\n nfs_sheets_initial = 3\n nfs_sheets_final = 5\n/ We run the Wannier interpolation and the Eliashberg function calculation: ${ INTW_dir } /ep_interp_on_trFS_dV.x < intw.in ${INTW_dir}/a2F_on_trFS_dV.x < intw.in Finally, we rename the results files: mv imgb2_ep_interp.dat mgb2_ep_interp_wann.dat\nmv mgb2_a2F_interp.dat mgb2_a2F_interp_wann.dat and we are ready to compare the Eliashberg function from both methods: gnuplot> set ylabel 'a2F(omega)'\ngnuplot> set xlabel 'omega(Ry)'\ngnuplot> p 'mgb2_a2F_interp_dV.dat' w l,'mgb2_a2F_interp_wann.dat' w l Back to top :arrow_heading_up:","tags":"","url":"page/tutorials/qe-intw.html"},{"title":"SIESTA – INTW","text":"Using INTW with SIESTA Table of contents Silicon band structure with SIESTA and Wannier Band structure Calculation with SIESTA INTW's Wannier90 interface SIESTA's Wannier90 interface Graphene phonon dispersion Copper electron-phonon matrix elements In this tutorial we will use the 4.1.5 version of SIESTA. SIESTA uses PSF pseudo-potentials. (In the recently released 5.0.0 version PSML pseudo-potential from pseudo-dojo can be used). The input for the calculation is given in Flexible Data Format (FDF). Silicon band structure with SIESTA and Wannier In this example, first of all, we will do a small introduction to a band structure calculation with SIESTA. And in second place, we will see how to use the interface siesta2intw.x and INTW's intw2W90.x utility to construct the Wannier functions, comparing the Wannier interpolated band structure with SIESTA's band structure. At the end, we will also show how can be used SIESTA's own interface to wannier90.x . All files to run this example can be found in the 1-silicon directory. $ ls 1 -silicon/\nintw.in siesta2intw.in si.win\nbands_siesta2nxy.bash silicon.fdf\nbands_wannier2nxy.bash Si.psf Back to top :arrow_heading_up: Band structure calculation with SIESTA First, let's take a look at the input silicon.fdf file where the system and the different calculation parameters are specified: System name and label: SystemName          bulk silicon\n   SystemLabel         si Unit cell information: ```\n   NumberOfAtoms       2\n   NumberOfSpecies     1 %block ChemicalSpeciesLabel\n    1  14  Si\n   %endblock ChemicalSpeciesLabel LatticeConstant    10.2048933684 Bohr\n   %block LatticeVectors\n    -0.500  0.000  0.500\n     0.000  0.500  0.500\n    -0.500  0.500  0.000\n   %endblock LatticeVectors AtomicCoordinatesFormat  ScaledByLatticeVectors\n   %block AtomicCoordinatesAndAtomicSpecies\n    -0.125  -0.125  -0.125     1\n     0.125   0.125   0.125     1\n   %endblock AtomicCoordinatesAndAtomicSpecies\n   ``` Exchange correlation: XC.Functional LDA\n   XC.Authors PZ Basis set: PAO.BasisSize          DZ Self-consistent loop: DM.UseSaveDM           true\n   DM.MixingWeight        0.3\n   DM.NumberPulay         3\n   DM.Tolerance           1.d-5 Electronic structure parameters: SolutionMethod         diagon\n   Diag.Algorithm         expert\n   Diag.ParallelOverK     false\n   NumberOfEigenStates    10\n   OccupationFunction     FD\n   ElectronicTemperature  25 meV Brillouin-zone sampling: %block kgrid_Monkhorst_Pack\n    8   0   0    0.\n    0   8   0    0.\n    0   0   8    0.\n   %endblock kgrid_Monkhorst_Pack Band block: BandLinesScale ReciprocalLatticeVectors\n   %block BandPoints\n    0.500000    0.500000    0.500000\n    0.475000    0.475000    0.475000\n    .\n    .\n    .\n   %endblock BandPoints After taking a look at the parameters used in the fdf, we can run the calculation by typing: siesta < silicon.fdf | tee silicon.out SIESTA produces many output files, such as si.DM for the density matrix, si.EIG for the eigenvalues, si.FA for the atomic forces, Si.ion and Si.ion.xml for the basis orbitals and non-local pseudo-potential, or si.KP for the k-points (see SIESTA's documentation for more information). But, for this example, we are interested in the si.bands file, which contains the band structure. However, in order to plot the band structure the si.bands file needs to be transformed to a format suitable for plotting. Although SIESTA has its own code for that ( gnubands ), in this tutorial we have prepared a script for simplicity: ./bands_siesta2nxy.bash > bands_siesta.dat This script transforms the si.bands file into a format that can be easily plotted with different programs: xmgrace -nxy bands_siesta.dat or gnuplot -p -e \"p for [c=2:*] 'bands_siesta.dat' u 1:c w l lc 'black'\" Back to top :arrow_heading_up: INTW's Wannier90 interface In this second part, we will learn how to interpolate the band structure using INTW and wannier90.x . In order to constructing the Wannier functions with wannier90.x the si.amn , si.mmn and si.eig files are needed. INTW's intw2W90.x utility can be used used for that, but first of all, we have to transform all the data of the SIESTA calculation to format suitable for INTW by running the interface siesta2intw.x . So, let's check the siesta2intw.in input file: $ cat siesta2intw.in & inputpp outdir = \"./\" prefix = \"si\" fdf_file = \"silicon.fdf\" nk1 = 8 , nk2 = 8 , nk3 = 8 cutoff = 40 .0 nbnd_initial = 1 nbnd_final = 4 use_sym = .true.\n/ The outdir and prefix variables specify where will be placed the si.save.intw directory and the label used in the siesta calculation, respectively. The fdf_file variable specifies the fdf file used for the siesta calculation. nk1 , nk2 and nk3 indicate the k-mesh where the Fourier transform of the wave functions will be computed, being cutoff the plane-wave cut-off for the wave functions. nbnd_initial and nbnd_final can be specified to reduce the amount of wave functions to be transformed. And finally, the use_sym variable is used to reduce the number of k-points by using the symmetry of the system. :heavy_exclamation_mark:NOTE: nk1 , nk2 and nk3 don't need to match the k-points of the SIESTA calculation. siesa2intw.x will execute a normal self-consistent SIESTA calculation, and then, it will run a non self-consistent calculation to compute the wave functions for the k-points specified by nk1 , nk2 and nk3 . Now we can run siesta2intw.x by typing: siesta2intw.x < siesta2intw.in | tee siesta2intw.out :heavy_exclamation_mark:NOTE: siesa2intw.x must be executed in the same directory where the SIESTA calculation was executed. This creates the si.save.intw directory with all the information about the system in a format readable by INTW: $ tree si.save.intw\nsi.save.intw/\n├── 1 -KBPP.txt\n├── crystal.dat\n├── gvectors.dat\n├── iGlist.dat\n├── kpoints.dat\n├── wfc00001.dat\n├ .\n├ .\n├ .\n└── wfc00029.dat 1-KBPP.txt contains the pseudo-potential in its Kleyman-Bylander form. crystal.dat stores all the information related to the unit cell, symmetries, etc. wfc00001.dat to wfc00029.dat contain the Fourier transform of the wave functions for each k-point, where the list of k-points is given in kpoints.dat . Finally, gvectors.dat contains the global list of G-vectors used in the Fourier transform and iGlist.dat has the lists of G-vectors for each k-point. All the data read by INTW is written here, and therefore, now we can already use INTW in the same way as if we were using Quantum Espresso and pw2intw.x . To create the si.amn , si.mmn and si.eig files we have to run wannier90.x in pre-processing mode first to create the nnkp file: wannier90.x -pp si Since the aim of this tutorial is not to show how to use wannier, we will not analyze the si.win file, but for the curious, since we have specified the band range from nbnd_initial=1 to nbnd_final=4 in siesta2intw.x we will use four s-orbitals, centered in the bonds, as our initial guess. Now, that we have the si.save.intw and the si.nnkp file, we can run intw2W90.x to generate the si.amn , etc. But\nfirst, let's check the input file for intw2W90.x : $ cat intw.in & input outdir = './' prefix = 'si' nk1 = 8 nk2 = 8 nk3 = 8 TR_symmetry = .false. use_exclude_bands = 'wannier' / & intw2W intw2W_fullzone = .false. intw2W_method = 'CONVOLUTION' / & ph\n/ In the input namelist, outdir indicates where is placed the si.save.intw directory, and prefix the label used in SIESTA. nk1 , nk2 and nk3 indicate the k-mesh, which must be the same used for siesta2intw.x , TR_symmetry indicates if time-reversal symmetry can be used to obtain the full k-mesh form the irreducible k-points or not and use_exclude_bands = 'wannier' specifies to use the exclude_bands specified in wannier90 input. In the intw2W namelist, intw2W_fullzone indicates wether the full Brillouin zone is present in the si.save.intw directory or not, while intw2W_method specifies the method used to compute the amm's. Finally, the ph namelist is empty in this example, but it is used to specify information about the phonon structure. Now, we can run intw2W90.x by tying: intw2W90.x < intw.in | tee intw2W90.out Which will create si.amn , si.mmn and si.eig files, and finally we can run wannier90.x : wannier90.x si This will construct the Wannier functions, and use them to interpolate the band structure. The interpolated band structure can be found in si_bands.dat and can be plotted using the gnuplot script si_bands.gnu . However, in order to compare the interpolated bands with the original bands calculated with SIESTA, for simplicity, we have prepared an script to write the bands in the same format used previously: ./bands_wannier2nxy.bash > bands_wannier_intw.dat And therefore, the band structure can be compared directly by xmgrace -nxy bands_siesta.dat -nxy bands_wannier_intw.dat or by gnuplot -p -e \"p for [c=2:*] 'bands_siesta.dat' u 1:c w l lc 'black', for [c=2:*] 'bands_wannier_intw.dat' u 1:c w l lc 'red'\" Back to top :arrow_heading_up: SIESTA's Wannier90 interface SIESTA has its own interface to wannier90.x , so si.mmn , si.amn and si.eig files can be generated adding the following lines to the input fdf file: Siesta2Wannier90.WriteMmn true\nSiesta2Wannier90.WriteAmn true\nSiesta2Wannier90.WriteEig true :heavy_exclamation_mark:NOTE: Remember executing wannier90.x in pre-processing mode to create the si.nnkp file before executing SIESTA. Back to top :arrow_heading_up: Graphene phonon dispersion INTW contains set of utilities to compute phonon structures using SIESTA and finite differences, siesta2ph , which consists of three independent utilities: siesta2ph.x , siesta2fc.x and siesta2dv.x . The first one, siesta2ph.x , reads SIESTA's fdf file, creates a super-cell of the system and computes the minimum set of atomic displacements needed to compute the phonon structure (the irreducible displacements), creating all the fdf input files to run SIESTA. Then, once SIESTA has been executed for all the irreducible displacements, siesta2fc.x can be used to compute the interatomic force constants and dynamical matrices of the system, or, optionally, to compute the phonon dispersion along a path, and siesta2dv.x can be used to compute the potential induced by the displacement of the atoms from their equilibrium positions, which is an essential quantity to compute electron-phonon matrix elements. In this example we will learn how to use this utilities to compute the interatomic force constants, the dynamical matrices and the phonon dispersion of graphene, together with the induced potential. Folder 2-graphene has all the files needed to run this example: $ ls 2 -graphene\nC.psf graphene.fdf path.dat siesta2ph.in First of all, let's check the input file for all the three utilities of siesta2ph : $ cat siesta2ph.in & input prefix = \"graphene.fdf\" v0dir = \"./441/v0/\" phdir = \"./441/0.01/\" nr1 = 4 nr2 = 4 nr3 = 1 dx = 0 .01 lpm = .true. use_sym = .true. irreducible_q = .true. kpath_file = \"path.dat\" xsf = .true. full_xsf = .false. dv_precision = \"dp\" verbose = .true.\n/ prefix specifies the actual fdf file of the system being studied. v0dir and phdir can be used to properly organize all the files generated by siesta2ph.x . v0dir and phdir specify where will be located the fdf of the super-cell used in the phonon structure calculation, and where will be created the fdf files for the irreducible displacements, respectively. nr1 , nr2 and nr3 indicate the size of the super-cell to be used, while dx is the amplitude used for the atomic displacements in Bohr atomic units. lpm can be used to displace the atoms also in the negative direction in order to use a more precise second order centered finite difference formula. use_sym is used to specify whether symmetries will be used to calculate irreducible displacements or whether all atoms will be displaced in all directions. On the other hand, irreducible_q is used to indicate if the dynamical matrices and induced potentials will be computed for the whole q-points commensurate with nr1 , nr2 and nr3 , or just for the irreducible q-points. The kpath_file variable designates the name of the file where the k-path for computing the phonon dispersion is stored. While xsf indicates if the induced potentials are stored in a 2D XSF file to be plotted by XCrysDen, full_xsf determines if the xsf files are stored only for the irreducible displacements, or for all possible atomic displacements. Additionally, dv_precision specifies the precision used to compute the induced potentials, and can be used to reduce the amount of disk space used. And finally, verbose specifies the level of verbosity of the output. The first step to compute the phonon structure with siesta2ph is to create the fdf files for the irreducible displacements using siesta2ph.x : siesta2ph.x < siesta2ph.in | tee siesta2ph.out This creates all the directory structure and the fdf files needed: $ tree 441/\n   441/\n   ├── 0.01\n   │   ├── disp-0001\n   │   │   └── supercell-graphene.fdf\n   │   ├── disp-0002\n   │   │   └── supercell-graphene.fdf\n   │   ├── disp-0003\n   │   │   └── supercell-graphene.fdf\n   │   └── disp-0004\n   │       └── supercell-graphene.fdf\n   └── v0\n         └── supercell-graphene.fdf :heavy_exclamation_mark:NOTE: Notice that even if only two irreducible displacements have been found by siesta2ph.x , four displacement files have been created because lpm=.true. has been specified in the input. Once that all the fdf files have been created for all the irreducible displacements, the next step is to execute a SIESTA calculation for each of them. Usually, it is very convenient to run first the calculation of the super-cell with the atoms in their equilibrium positions (the fdf in v0 ), in order to use the density matrix of this calculation as starting point for the displaced atoms calculations: cp C.psf 441/v0/\n   cd 441/v0/\n   mpirun -n 4 siesta < supercell-graphene.fdf | tee out And after this, we can execute the calculations for all the displacements by using an script included in siesta2ph for this purpose: cd ../../\n   run-disps.x --dm 441/v0/g.DM -n 4 -v 441/0.01/ You can type ` run - disps . x -- help ` for all the information about the command line arguments of the script . :heavy_exclamation_mark:NOTE: Remember to include DM.UseSaveDM true in the original fdf file in order to take advantage of the close-to-convergence charge density as a starting point for the calculations. :heavy_exclamation_mark:NOTE: Since in this calculations the atoms are displaced from their equilibrium positions, it is important to use MD.Steps 0 in the input fdf to avoid relaxing the system. Now that all SIESTA calculations have been executed, we already can compute the force constants, dynamical matrices and phonon dispersion with siesta2fc.x : siesta2fc.x < siesta2ph.in | tee siesta2fc.out This will generate the interatomic force constants file fc.dat , the phonon dispersion file phonons.dat and the dynamical matrices files dyn0001.dat to dyn0004.dat for each q-point in the phdir directory. To plot the phonon dispersion we can use: xmgrace -nxy 441/0.01/phonons.dat or gnuplot -p -e \"p for [c=2:*] '441/0.01/phonons.dat' u 1:c w l lc 'black'\" And finally, the induced potential can be computed by siesta2dv.x : siesta2dv.x < siesta2ph.in | tee siesta2dv.out This creates the folder dvscf inside phdir , where induced potentials for each q-point are stored in files dvscf0001.dat to dvscf0004.dat . Since xsf=.true. was specified, the xsf files are also created in phdir . This files can be plotted with XCrySDen: xcrysden --xsf 441/0.01/dVR_ia001_id1.xsf dVR_ia001_id1.xsf file contains the potential induced in the super-cell by the displacement of the first atom along the first Cartesian direction $x$: $\\partial V_{I\\alpha} = dV/du_{I}&#94;{\\alpha}$ for the atomic index $I=1$ and the Cartesian index $\\alpha=x$. In a similar way, dVq_iq01_ia001_id1.xsf contains the potential induced in the super-cell, but for the displacement pattern with the periodicity of the first q-point: $\\partial V_{I\\alpha}(\\mathbf{q}) = dV/(u_{1}&#94;{x} e&#94;{i\\mathbf{q}\\cdot\\mathbf{R}})$, being $\\mathbf{R}$ a lattice vector. And finally, dvq_iq01_ia001_id1.xsf contains the periodic part of the same induced potential: $\\partial v_{I\\alpha}(\\mathbf{q}) = \\partial V_{I\\alpha}(\\mathbf{q}) e&#94;{-i\\mathbf{q}\\cdot\\mathbf{r}}$, which is the same induced potential stored in dvscf0001.dat . :heavy_exclamation_mark:NOTE: In order to compute the induced potential SaveTotalPotential T must be added to de fdf (if you only want to compute the force constants it's not needed). :heavy_exclamation_mark:NOTE: At this moment, running the v0 calculation is mandatory, as some of its output is read by siesta2dv.x Back to top :arrow_heading_up: Copper electron-phonon matrix elements In this third example we will show how to calculate the electron-phonon matrix elements for copper using INTW's ep_melements.x utility. For that, first of all, we will compute the electronic and phonon structures of cooper using SIESTA and siesta2ph . In a second step, we will transforming all the calculation data to a format readable by INTW with siesta2intw.x . And finally, we will execute ep_melements.x to compute the electron-phonon matrix elements. Folder 3-copper has all the files needed to run the example: $ ls\ncopper.fdf Cu.psf intw.in siesta2intw.in siesta2ph.in The first step for a calculation of this type would be computing the electronic structure of the system to be studied: mpirun -n 4 siesta < copper.fdf | tee copper.fdf :heavy_exclamation_mark:NOTE: Before continuing with the calculation of the phonon structure, users should ensure that the parameters used in the fdf yield an electronic structure that is accurate enough for the requirements of their calculations. After the electronic structure, we will calculate the dynamical matrices and the induced potentials with siesta2ph.x , siesta2fc.x and siesta2dv.x . Following the procedure that we have seen in the previous example: Create the input files of the irreducible displacements: siesta2ph.x < siesta2ph.in | tee siesta2ph.out Execute all SIESTA calculations: cp Cu.psf 222/v0/\n cd 222/v0/\n mpirun -n 4 siesta < supercell-copper.fdf | tee out\n cd ../../\n run-disps.x --dm 222/v0/cu.DM -n 4 -v 222/0.02/ Compute the dynamical matrices and induced potentials: siesta2fc.x < siesta2ph.in | tee siesta2fc.out\n siesta2dv.x < siesta2ph.in | tee siesta2dv.out After this steps, we already have computed all the information about the electronic and phonon structures that we will need to calculate the electron-phonon matrix elements. Then, the second step is to run siesta2intw.x to store all the data in a format that INTW can read. However, in this case, together with the electronic structure, we also need the phonon structure. Therefore, let's check the flags that we have to add in siesta2intw.in : $ cat siesta2intw.in\n   &inputpp\n     outdir=\"./\"\n     prefix=\"cu\"\n     fdf_file=\"copper.fdf\"\n     nk1=4, nk2=4, nk3=4\n     nbnd_final=10\n     cutoff=80.0\n     phonons=.true.\n     phdir=\"./222/0.02/\"\n     nqirr=3\n   / phonons=.true. indicates that also the phonon structure has to be copied to the cu.save.intw directory, phdir specifies where are placed the dynamical matrices and induced potentials, and nqirr indicates the number of irreducible q-points to be copied. So, let's run siesta2intw.x by typing: siesta2intw.x < siesta2intw.in | tee siesta2intw.out This will create the same files that we have seen in the first examples inside cu.save.intw , plus cu.dyn_q* files for the dynamical matrices, and cu.dvscf_q* and irrq_patterns.dat files for the induced potentials and the displacement patterns related to them, respectively. Additionally, qlist.txt file will also be created, which is needed by INTW and contains a list of the irreducible q-points in Cartesian coordinates. Now that we have all the required information in a format that INTW can read, we can run INTW's ep_melements.x utility to compute the electron-phonon matrix elements. But first, let's check intw.in file: $ cat intw.in\n   &input\n     outdir = './'\n     prefix = 'cu'\n     nk1 = 4\n     nk2 = 4\n     nk3 = 4\n     TR_symmetry = .false.\n     use_exclude_bands = 'none'\n   /\n   &intw2W\n     intw2W_fullzone = .false.\n     intw2W_method   = 'CONVOLUTION'\n   /\n   &ph\n     nq1 = 2\n     nq2 = 2\n     nq3 = 2\n     nqirr = 3\n   / In this example, use_exclude_bands = 'none' indicates to don't exclude any band, i.e. to use all bands from the calculation. And in addition to the parameters that we have already seen in the first example, in this case we also need to specfy the ph namelist, where nq1 , nq2 and nq3 indicate the q-mesh, and nqirr the number of irreducible q-points. So, let's run ep_melements.x by typing: ep_melements.x < intw.in | tee ep_melements.out And as you can see, the electron-phonon matrix elements for each q-point have been calculated and saved into files ep_mat.dat_1 to ep_mat.dat_8 : $ ls ep_mat.*\n   ep_mat.dat_1  ep_mat.dat_2  ep_mat.dat_3  ep_mat.dat_4\n   ep_mat.dat_5  ep_mat.dat_6  ep_mat.dat_7  ep_mat.dat_8 :heavy_exclamation_mark:NOTE: INTW will compute the matrix elements for the entire nq1, nq2, nq3 q-mesh. Back to top :arrow_heading_up:","tags":"","url":"page/tutorials/siesta-intw.html"},{"title":"Test suite – INTW","text":"The test directory contains the tests for testing INTW. Remember running make before executing the tests, since some tests will need to be compiled. Then run make test or ctest command to execute all the tests. ctest gives more options to execute the test, for example with ctest -V the output of the tests is showed. Some theory about testing There are three main methods to test a software: Unit testing, Integration testing and Functional testing. Unit testing means testing individual modules of an application in isolation (without any interaction with dependencies) to confirm that the code is doing things right. Integration testing means checking if different modules are working fine when combined together as a group. Functional testing means testing a slice of functionality in the system (may interact with dependencies) to confirm that the code is doing the right things. INTW test suite INTW is prepared to develop tests in different ways: It is possible to write a script to execute a INTW utility program, and then compare the obtained results with previous reference calculations (Functional testing). Another option is to write a fortran function, where it is possible to run individual INTW subroutines (Unit testing), or even more complex programs (Integration testing). 1. Scripts The scripts could be written in different languages, for example bash or python. In the test_dummy folder there are examples with both languages. This scripts should run a program, check the results and compare them with a previous reference calculation, and exit with error code 0 if the result is the expected, or if the result is not correct with error code 1 . This type of test would be well suited to check the code when major changes are made on it. One example of such a test could be for example to compute the electron-phonon matrix elements of a system and compare it with a previous calculation. In this way we can check if all the subroutines together work as they should be. 2. Fortran functions In this case, the function could be as simple as reading the calculation parameters, or as complex as computing the electron-phonon matrix elements. But I think that has no sense to write a complex function to compute the electron-phonon matrix elements, because the test should be compiled before running the test, and for that purpose I think that it would be better to write a script that runs an existing INTW utility. This type of tests should be used to check very specific parts of the code. For example, one test could check if the symmetry operations are read and used correctly. Or another test could read the pseudopotentials and check if all the data is read correctly. On the test_IO file there is a very simple test of this type that could be used as an example. Test module The module directory contains a collection of useful functions for testing. Adding new tests Read CMakeList.txt file in test directory to learn how to add new tests.","tags":"","url":"page/tests.html"},{"title":"Other – INTW","text":"More technical documentation can be found in the doc directory of INTW.","tags":"","url":"page/other.html"}]}