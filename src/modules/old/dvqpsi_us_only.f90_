!

!
!
!----------------------------------------------------------------------
subroutine dvqpsi_us_only (xk, xq, nat,  nG_max, nbands, npol, igk, igkq,  wfc_k,  dvpsi)
  !----------------------------------------------------------------------
  !
  ! This routine calculates dV_bare/dtau * psi for one perturbation
  ! with a given q. The displacements are described by a vector uact.
  ! The result is stored in dvpsi. The routine is called for each k point
  ! and for each pattern u. It computes simultaneously all the bands.
  ! This routine implements Eq. B29 of PRB 64, 235118 (2001).
  ! Only the contribution of the nonlocal potential is calculated here.
  !
  !
  USE kinds, only : DP
  USE intw_reading, only : tpiba
  USE intw_fft, ONLY : gvec_cart
  USE intw_useful_constants, ONLY : cmplx_0

  USE intw_reading, only :  ityp, ntyp 
  USE intw_reading, only :  noncolin
  USE intw_uspp, ONLY: okvan, nkb, vkb, vkqb, deeq
  USE intw_uspp,         ONLY : nhtol, nhtoj, nhtolm, ijtoh, dvan, qq, indv,&
                           ap, qq_so, dvan_so, okvan

  USE intw_uspp_param, ONLY: nh, nhm
  USE intw_phus,      ONLY : int1, int1_nc, int2, int2_so, alphap, becp1
  USE intw_becmod,               ONLY : calbec


  implicit none
  !
  !-Input xq, nat, uact, addnlcc, ng_max, igk, evc, dvpsi)
  !
  integer, intent(in)     :: nat
  real   (DP), intent(in) :: xq (3), xk(3)
  integer, intent(in)     :: nG_max,nbands,npol 
  integer, intent(in)     :: igk(ng_max), igkq(ng_max)

  complex(kind=dp),intent(in)     ::  wfc_k (nG_max,nbands,npol)
  complex(kind=dp),intent(inout)     :: dvpsi (nG_max,nbands,npol,3*nat)

   complex(kind=dp) :: aux1(nG_max*npol, nbands)


  logical :: lspinorb

  integer :: ik, nsp
  ! input: the k point
  ! input: the pattern of displacements
  !
  !   And the local variables
  !

  integer :: na, nb, mu, nu, ikk, ikq, ig, igg, nt, ibnd, ijkb0, &
       ikb, jkb, ih, jh, ipol, is, js, ijs, imode
  ! counter on atoms
  ! counter on modes
  ! the point k
  ! the point k+q
  ! counter on G vectors
  ! auxiliary counter on G vectors
  ! counter on atomic types
  ! counter on bands
  ! auxiliary variable for counting
  ! counter on becp functions
  ! counter on becp functions
  ! counter on n index
  ! counter on m index
  ! counter on polarizations

  real(DP), parameter :: eps = 1.d-12

  complex(DP), allocatable :: ps1 (:,:), ps2 (:,:,:), aux (:), deff_nc(:,:,:,:)
  real(DP), allocatable :: deff(:,:,:)
  complex(DP), allocatable :: ps1_nc (:,:,:), ps2_nc (:,:,:,:)
  ! work space

  logical :: ok
  integer :: current_spin=1

   lspinorb=noncolin
   nsp=ntyp

  call start_clock ('dvqpsi_us_on')
  if (noncolin) then
     allocate (ps1_nc(nkb , npol, nbands))
     allocate (ps2_nc(nkb , npol, nbands , 3))
  else
     allocate (ps1 ( nkb , nbands))
     allocate (ps2 ( nkb , nbands , 3))
  end if
  allocate (aux ( ng_max))

       aux1=(0.d0,0.d0)

       DO ibnd = 1, nbands
           DO ig = 1, nG_max
            do ipol=1,npol
              aux1(ig+(ipol-1)*npol,ibnd) = wfc_k(ig,ibnd,ipol)
            enddo
           enddo
       enddo

       CALL calbec (nG_max, vkb, aux1 , becp1(1) )

       DO ipol = 1, 3
        aux1=(0.d0,0.d0)
        DO ibnd = 1, nbands
           DO ig = 1, nG_max
              if ((igk(ig)>0).and.(igk(ig)<nG_max)) then
              aux1(ig,ibnd) = wfc_k(ig,ibnd,1) * tpiba * ( 0.D0, 1.D0 ) * &
                              ( xk(ipol) + gvec_cart(ipol,igk(ig)) )

              else
              aux1(ig,ibnd) = cmplx_0
              end if
           END DO
           IF (npol==2) THEN
              DO ig = 1, nG_max
                 if ((igk(ig)>0).and.(igk(ig)<nG_max)) then

                 aux1(ig+ng_max,ibnd)=wfc_k(ig+nG_max,ibnd,2)*tpiba*(0.D0,1.D0)*&
                              ( xk(ipol) + gvec_cart(ipol,igk(ig)) )
                 else
                  aux1(ig+ng_max,ibnd)=cmplx_0
                 end if

              END DO !ig
           END IF !npol
        END DO !ibnd
        CALL calbec (nG_max, vkb, aux1, alphap(ipol,1) )
     END DO !ipol


  !
  !   we first compute the coefficients of the vectors
  !
  do imode=1,3*nat

  na   = (imode-1) / 3  + 1
  ipol = modulo(imode-1,3) + 1  

  if (noncolin) then
     ps1_nc(:,:,:)   = (0.d0, 0.d0)
     ps2_nc(:,:,:,:) = (0.d0, 0.d0)
  else
     ps1(:,:)   = (0.d0, 0.d0)
     ps2(:,:,:) = (0.d0, 0.d0)
  end if

  do ibnd = 1, nbands

     ijkb0 = 0
     do nt = 1, ntyp
!        do na = 1, nat
           if (ityp (na) .eq.nt) then
!              mu = 3 * (na - 1)
              do ih = 1, nh (nt)
                 ikb = ijkb0 + ih
                 do jh = 1, nh (nt)
                    jkb = ijkb0 + jh
!                    do ipol = 1, 3
!                       if ( abs (uact (mu + 1) ) + &
!                            abs (uact (mu + 2) ) + &
!                            abs (uact (mu + 3) ) > eps) then
                          IF (noncolin) THEN
                             ijs=0
                             DO is=1,npol
                                DO js=1,npol
                                   ijs=ijs+1
                                   ps1_nc(ikb,is,ibnd)=ps1_nc(ikb,is,ibnd) +  &
                                      dvan_so(ih,jh,ijs, ityp(na) ) * &
                                      alphap(ipol, 1)%nc(jkb,js,ibnd)
                                   ps2_nc(ikb,is,ibnd,ipol)=               &
                                          ps2_nc(ikb,is,ibnd,ipol)+        &
                                          dvan_so(ih,jh,ijs, ityp(na) ) * &
                                          becp1(1)%nc(jkb,js,ibnd) *      &
                                          (0.d0,-1.d0) *  tpiba
                                END DO
                             END DO
                          ELSE
                             ps1 (ikb, ibnd) = ps1 (ikb, ibnd) +   dvan (ih, jh, ityp(na))*   &
                                alphap(ipol, 1)%k(jkb, ibnd) 
                             ps2 (ikb, ibnd, ipol) = ps2 (ikb, ibnd, ipol) + &
                                  dvan (ih, jh, ityp(na)) *becp1(1)%k (jkb, ibnd) *  &
                                  (0.0_DP,-1.0_DP)  * tpiba
                          ENDIF

!                       END IF  ! uact>0
!                    enddo ! ipol
                 enddo ! jh
              enddo ! ih
              ijkb0 = ijkb0 + nh (nt)
           endif
!        enddo  ! na
     enddo ! nt
  enddo ! nbands

  !
  !      This term is proportional to beta(k+q+G)
  !
  if (nkb.gt.0) then
     if (noncolin) then
        !call zgemm ('N', 'N', ng_max, nbands*npol, nkb, &
        ! (1.d0, 0.d0), vkb, ng_max, ps1_nc, nkb, (1.d0, 0.d0) , dvpsi, ng_max)
        do is=1,npol
          call zgemm ('N', 'N', ng_max, nbands, nkb, &
         (1.d0, 0.d0), vkqb, ng_max, ps1_nc(:,is,:), nkb, (1.d0, 0.d0) , dvpsi (:,:,is,imode), ng_max)
        enddo

     else
        call zgemm ('N', 'N', ng_max, nbands, nkb, &
         (1.d0, 0.d0) , vkqb, ng_max, ps1, nkb, (1.d0, 0.d0) , dvpsi (:,:,1,imode), ng_max)
     end if
  end if
  !
  !      This term is proportional to (k+q+G)_\alpha*beta(k+q+G)
  !
  do ikb = 1, nkb
     do ipol = 1, 3
        ok = .false.
        IF (noncolin) THEN
           do ibnd = 1, nbands
              ok = ok.or.(abs (ps2_nc (ikb, 1, ibnd, ipol) ).gt.eps).or. &
                         (abs (ps2_nc (ikb, 2, ibnd, ipol) ).gt.eps)
           end do
        ELSE
           do ibnd = 1, nbands
              ok = ok.or. (abs (ps2 (ikb, ibnd, ipol) ) .gt.eps)
           enddo
        ENDIF
        if (ok) then
           do ig = 1, ng_max
              igg = igkq (ig)
              if ((igg>0).and.(igg<nG_max)) then 
               aux (ig) =  vkqb(ig, ikb) * (xk(ipol) + xq(ipol) + gvec_cart(ipol, igg) )
              else
               aux (ig) =  cmplx_0
              end if
           enddo
           do ibnd = 1, nbands
              IF (noncolin) THEN
              !   call zaxpy(ng_max,ps2_nc(ikb,1,ibnd,ipol),aux,1,dvpsi(1,ibnd),1)
              !   call zaxpy(ng_max,ps2_nc(ikb,2,ibnd,ipol),aux,1, &
              !                                           dvpsi(1+ng_max,ibnd),1)
                  do is=1,npol
                   call zaxpy(ng_max,ps2_nc(ikb,is,ibnd,ipol),aux,1,dvpsi (1,ibnd,is,imode),1)
                  enddo
              ELSE
                   call zaxpy (ng_max, ps2(ikb,ibnd,ipol), aux, 1, dvpsi (1,ibnd,1,imode), 1)
              END IF
           enddo
        endif
     enddo

  enddo

  enddo !imode


  deallocate (aux)
  IF (noncolin) THEN
     deallocate (ps2_nc)
     deallocate (ps1_nc)
  ELSE
     deallocate (ps2)
     deallocate (ps1)
  END IF


  call stop_clock ('dvqpsi_us_on')
  return
end subroutine dvqpsi_us_only


